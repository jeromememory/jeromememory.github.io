<!DOCTYPE html>












  


<html class="theme-next mist use-motion" lang="zh-CN">

<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-bounce.min.css?v=1.0.2">















  
  
  <link rel="stylesheet" href="/lib/fancybox/source/jquery.fancybox.css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  

  

  
    
      
    

    
  

  
    
    
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic|Roboto Slab:300,300italic,400,400italic,700,700italic|Roboto Mono:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext">
  






<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.1.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/happy.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/happy.png?v=7.1.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/happy.png?v=7.1.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '7.1.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":true,"dimmer":false},
    back2top: true,
    back2top_sidebar: true,
    fancybox: true,
    fastclick: true,
    lazyload: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"shrinkIn","post_header":"slideLeftIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideDownIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  







  <meta name="description" content="第二章 Java内存区域与内存溢出异常1. 运行时数据区域包括 方法区、堆（前两者都是共享的）、虚拟机栈、本地方法栈、程序计数器（三者是线程私有）。 方法区：与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量，别名称为Non-Heap。 堆：Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，此内存区域的唯一">
<meta name="keywords" content="jvm笔记,oom,垃圾回收,Class 文件组成,类加载,字节码执行引擎,Java 内存模型,线程安全,锁">
<meta property="og:type" content="article">
<meta property="og:title" content="jvm笔记">
<meta property="og:url" content="http://jeromememory.github.io/2019/12/04/深入理解java虚拟机笔记.html">
<meta property="og:site_name" content="jeromememory">
<meta property="og:description" content="第二章 Java内存区域与内存溢出异常1. 运行时数据区域包括 方法区、堆（前两者都是共享的）、虚拟机栈、本地方法栈、程序计数器（三者是线程私有）。 方法区：与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量，别名称为Non-Heap。 堆：Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，此内存区域的唯一">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://image.baidu.com/search/down?url=https://tva1.sinaimg.com/large/00831rSTgy1gcjdgfqvx5j30u0140b2a.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcladf39x1j30t80tk0yl.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckg5qiid9j30n706kgmu.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gck8v86moxj310a0n2q53.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gck930bpd0j312q0sagxf.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcnsflnw07j30uk0u0424.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckfy191awj30kb06bgnj.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckippfkaej314y0h613y.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckiy6h77ij311o0e8mzj.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckjrgkib3j30u011gqje.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckksagpb7j30ne0moaf0.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcl4cx2bmgj31bk0q6aeh.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcldmwegn7j30uc0u0anj.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcle1chnjmj314y0u0wkx.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gclsekqvuzj319c0rqk8l.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmkb1kva4j30t40dwq6o.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmkqj6r62j30u010wtix.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmkqt9x0nj30u014n7ez.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmldpbr9gj311a0h6454.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcms4wlbchj31980qan4d.jpg">
<meta property="og:image" content="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmx1m1x0uj31780gk40b.jpg">
<meta property="og:updated_time" content="2023-05-09T12:44:18.449Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jvm笔记">
<meta name="twitter:description" content="第二章 Java内存区域与内存溢出异常1. 运行时数据区域包括 方法区、堆（前两者都是共享的）、虚拟机栈、本地方法栈、程序计数器（三者是线程私有）。 方法区：与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量，别名称为Non-Heap。 堆：Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，此内存区域的唯一">
<meta name="twitter:image" content="https://image.baidu.com/search/down?url=https://image.baidu.com/search/down?url=https://tva1.sinaimg.com/large/00831rSTgy1gcjdgfqvx5j30u0140b2a.jpg">



  <link rel="alternate" href="/atom.xml" title="jeromememory" type="application/atom+xml">



  
  
  <link rel="canonical" href="http://jeromememory.github.io/2019/12/04/深入理解java虚拟机笔记">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>jvm笔记 | jeromememory</title>
  






  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?5b603f3e8ef364f6e89d9e698962ba05";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>







  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>
 
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">jeromememory</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-bookmark"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-互动">

    
    
    
      
    

    

    <a href="/guestbook/" rel="section"><i class="menu-item-icon fa fa-fw fa-comments"></i> <br>互动</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  
    

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://jeromememory.github.io/2019/12/04/深入理解java虚拟机笔记.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jerome">
      <meta itemprop="description" content="生活总是充满了惊喜">
      <meta itemprop="image" content="https://i.loli.net/2019/09/25/Dqk7oaQtwAHINWT.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="jeromememory">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">jvm笔记

              
            
          </h1>
        

        <div class="post-meta">
          
            <i class="fa fa-thumb-tack"></i>
            <font color="7D26CD">置顶</font>
            <span class="post-meta-divider">|</span>
          
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-04 21:46:58" itemprop="dateCreated datePublished" datetime="2019-12-04T21:46:58+08:00">2019-12-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2023-05-09 20:44:18" itemprop="dateModified" datetime="2023-05-09T20:44:18+08:00">2023-05-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/JVM/" itemprop="url" rel="index"><span itemprop="name">JVM</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="post-meta-item-icon">
            <i class="fa fa-eye"></i>
             阅读次数： 
            <span class="busuanzi-value" id="busuanzi_value_page_pv"></span>
            </span>
          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">43k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">39 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="第二章-Java内存区域与内存溢出异常"><a href="#第二章-Java内存区域与内存溢出异常" class="headerlink" title="第二章 Java内存区域与内存溢出异常"></a>第二章 Java内存区域与内存溢出异常</h1><h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h2><p>包括 方法区、堆（前两者都是共享的）、虚拟机栈、本地方法栈、程序计数器（三者是线程私有）。</p>
<p>方法区：与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的<strong>类信息</strong>、<strong>常量</strong>、<strong>静态变量</strong>，别名称为<strong>Non-Heap</strong>。</p>
<p>堆：Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，此内存区域的唯一目的是<font color="red">存放对象实例</font>，同时Java堆是垃圾收集管理的主要区域，很多时候也被称为 <code>GC堆</code>。</p>
<p>虚拟机栈：描述的是Java方法执行的内存模型，即每个方法会在执行的同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。经常有人把Java内存分为堆内存和栈内存，这里的栈内存就是指的虚拟机栈。</p>
<p>本地方法栈：与虚拟机栈发挥的功能基本一致，区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。</p>
<p>程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p>
<p>运行时常量池：<strong>方法区的一部分</strong>。常量池（用于存放编译期生成的各种字面量和符号引用）。</p>
<p>直接内存：并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。「NIO 中会使用」 <font color="red">对它的使用还是不是特别了解…</font></p>
<blockquote>
<p>堆外内存：<a href="https://blog.csdn.net/y3over/article/details/88791958" target="_blank" rel="noopener">https://blog.csdn.net/y3over/article/details/88791958</a></p>
</blockquote>
<h2 id="2-OutOfMemoryError异常"><a href="#2-OutOfMemoryError异常" class="headerlink" title="2. OutOfMemoryError异常"></a>2. OutOfMemoryError异常</h2><p>包括 <strong>Java堆溢出</strong>、<strong>虚拟机栈和本地方法栈溢出</strong>、<strong>方法区和运行时常量池溢出</strong>、<strong>本机直接内存溢出</strong>。</p>
<ul>
<li>堆溢出，主要就是不停的 new 对象即可；「-Xms」</li>
<li>栈溢出，主要是定义大量的本地变量，然后递归，使得爆栈，这样会有 StackOverflowError，如果想要有 OOM，最好的方法就是不停的创建线程，因为系统分配给栈的内存是有限的，比如一般总的是 2G，然后减去堆和方法区的容量，就是栈的容量了，如果不断地 new 线程的话，那么总有一个线程会内存不够，此时就能够弹出 OOM 了；「」</li>
<li>方法区中的运行时常量池的溢出，一般也就是使用 String.inter() 方法，这个方法是一旦池中没有需要的常量，就定义一个放到池中去，否则就拿出这个常量的地址，我不断的定义常量放入常量池，那么就很容易 OOM；「PermGen Space」</li>
<li>方法区溢出，最基本的思路就是运行时产生大量的类去填满方法区直到溢出，这里借助的是 <font color="red">GGLib 直接操作字节码生成大量的动态类</font>。「这个地方我不太会…」「-XX:PermSize」</li>
<li>本机直接内存溢出「-XX:MaxDirectMemorySize」</li>
</ul>
<h2 id="3-补充：虚拟机部分参数"><a href="#3-补充：虚拟机部分参数" class="headerlink" title="3. 补充：虚拟机部分参数"></a>3. 补充：<a href="https://www.cnblogs.com/mingforyou/archive/2012/03/03/2378143.html" target="_blank" rel="noopener">虚拟机部分参数</a></h2><p>-vmargs -Xms128M -Xmx512M -XX:PermSize=64M -XX:MaxPermSize=128M<br>-vmargs 说明后面是VM的参数，所以后面的其实都是JVM的参数了<br>-Xms128m JVM初始分配的堆内存<br>-Xmx512m JVM最大允许分配的堆内存，按需分配<br>-XX:PermSize=64M JVM初始分配的非堆内存<br>-XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配</p>
<h1 id="第三章-垃圾收集器与内存分配策略"><a href="#第三章-垃圾收集器与内存分配策略" class="headerlink" title="第三章 垃圾收集器与内存分配策略"></a>第三章 垃圾收集器与内存分配策略</h1><p>问题：</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
<p>Q：哪些内存需要回收？</p>
<blockquote>
<ul>
<li><p>其中，程序计数器、虚拟机栈、本地方法栈三个区域随线程而生、随线程而灭，每一个栈帧分配多少内存基本上是在类结构确定下来时就已知的（尽管 JIT 编译期会在运行期间进行一些优化，但大体可以理解为编译期间就可知），所以这几个区域的分配和回收都具备确定性，不需要过多考虑回收的问题，但是 Java 堆和方法区 就不一样了，这里是公共区域，不是线程私有的，所以只有在运行期间才能确定内存的占用分配情况，这部分的内存的分配和回收都是动态的，所以 GC 就是指的这一块的内存。</p>
</li>
<li><p>很多人认为方法区（或者说 HotSpot 虚拟机中的永久代）是没有垃圾收集机制的，的确在 java 虚拟机规划中确实没有要求要在方法区实现垃圾收集，因为性价比很低，在堆中，尤其是新生代中，常规应用一次垃圾收集可以回收 70% - 95% 的空间，而方法区的垃圾收集效率远低于此。</p>
<p>但是，其实还是有必要进行垃圾收集的，<font color="red">尤其是在大量使用反射、动态代理、GGLib等 bytecode 框架的场景是需要具备类卸载的功能防止方法区 OOM 的。</font>永久代的垃圾收集主要回收两部分：废弃常量和无用的类，废弃常量的收集比较简单，就是没人用了，就会被请出常量池，但是无用的类这个条件就很严苛了，只有同时，注意使用时满足下面 3 个条件才能算是“无用的类”：</p>
<ul>
<li>该类所有实例被回收；</li>
<li>加载该类的 ClassLoader 已经被回收；</li>
<li>该类对应的 java.lang.Class 对象没有被使用，且无法在任何地方通过反射访问该类的方法。「这个好像非常的严格…」</li>
</ul>
</li>
</ul>
</blockquote>
<p>Q：什么时候回收？</p>
<blockquote>
<ol>
<li>第一步肯定是确定这个对象是否还“活着”。那么如何确定呢？有哪些方法呢？</li>
</ol>
<ul>
<li><p>第一种方法虽然不是 Java 中使用的，但是也有一些著名案例使用过。那就是计数算法：给对象添加一个计数器，引用了一次就加一，引用失效就减一，在任何时刻计数器都为0的对象就是不可能再被使用的，就可以回收。但是这里漏掉了一种情况，就是类似于死锁的情况，一个引用互相持有另外一个引用，这样虽然计数器的值都为 1 ，但是二者其实已经不可能再被访问了，理应被回收，但这个算法做不到；</p>
</li>
<li><p>第二种方法就是 Java 和 C# 用的方法了，为根搜索算法，算法的基本思路就是：如果 GC Roots 对象到这个对象不可达，则这个对象不可用。</p>
<p>大家可能会问了，什么是 GC Roots 对象，又如何定义不可达？</p>
<ul>
<li>可以做 GC Roots 的，其实就是部分对象：<ul>
<li>栈中本地变量表 or native 方法栈中引用的对象；</li>
<li>方法区(non-heap)中的类静态属性引用的变量；</li>
<li>方法区(non-heap)中的常量引用的对象；</li>
</ul>
</li>
<li>那么又如何定义不可达呢？即以 GC Roots 的对象为起始点，从这些节点向下搜索，所走过的路径称为引用链，当GC Roots 和这个对象不存在引用链，那就是不可达。</li>
</ul>
</li>
</ul>
<ol start="2">
<li>现在我们已经清楚了如何判断一个对象是 “活着” 还是 “死亡” 了，那是不是对象 “活着” 它就不会被回收呢，对象 “死亡” 我们就要将其回收呢，答案是否定的（如果是肯定的我还说个毛啊哈哈哈哈）。注意，这里的两句话都是不对的。</li>
</ol>
<ul>
<li><p>首先是 “活着” 的对象不是一定不被回收的，要“活着”，也要看它怎么活，怎么个活法，就是对应着这个链路的强度，在 jdk1.2 以后，引用分为了四类，这个我在 多线程（四）— ThreadLocal 一文中的内存泄漏也有提及。以下的顺序，就是引用从强到弱的顺序。</p>
<ul>
<li>强引用。听这个名字就知道这是上等人，这就是我们在程序代码中普遍存在的，类似于 “Object obj = new Object()” ，只要对象的强引用还在，他就一定能好好的活着，不会被 GC 回收；「Reference类」</li>
<li>软引用。就是一些有用但是又不是必要的，类似于工具人，被软引用关联的对象，在系统即将要发生OOM时，会将这些对象进行回收，回收之后发现还是内存不够，才会抛出 OOM 异常。「softReference类」</li>
<li>弱引用。这个更没用，他的生存周期很短，只能活在下一次 GC 工作之前，当 GC 开始干活时，被弱引用关联的对象就得滚蛋了。「WeakReference」<font color="red">这里再唠叨一下，ThreadLocalMap 中的 key 对 ThreadLocal 的引用就是弱引用，目的就是为防止内存泄漏添加一个保障，当 ThreadLocal 失去了强引用后，会被 GC 处理，而此时 key 为 null，可以触发ThreadLocalMap中清除脏 Entry 的方法防止内存泄漏。</font></li>
<li>虚引用。这个又被称为幽灵引用或者幻影引用(妈的我有点怕鬼..)，一个对象被这个虚引用关联，等于没关联，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例，唯一的作用就是可以在这个对象被 GC 回收时收到一个系统通知，就是阎王爷来收尸前派来告诉你要死的那几个小兵的作用(把我自己说怕了…)。「PhantomReference」</li>
</ul>
</li>
<li><p>再来解决第二个问题，那就是“死亡” 的对象，也不一定就要被回收，他只是处于缓刑阶段，还可以通过上诉来活着哈哈。(这一章是真的有意思啊) 要真正宣告一个对象死亡，至少要经历两次标记过程：第一次标记就是标记它不可达，即“死亡”的状态，同时他有一次“上诉”的机会，很明显上诉成功就不会死，上诉失败那肯定死定了。那，如何才能拥有这次难得的机会呢？那就是这个被标记为“死亡”的对象有覆盖 finalize() 方法，并且第一次调用，注意，他只有一次“上诉”的机会。当满足上诉机会的时候，即复写 finalize() 并且是第一次调用，它会被放置到 F-Queue中，并在稍后由一条由虚拟机自动创建的、低优先级的 Finalizer 去触发这个 他复写的 finalize()「注意，这里的 Finalizer由于优先级比较低，所以我们需要在线程中等待他一段时间，以确保它已经执行了。同时，注意，这个 Finalizer 很严苛，它不会允许 finalize() 一直执行，是有时间限制的，就跟上诉一样，是有期限的，过了这个期限就没用了。」，那转机肯定就在这个 finalize() 中了，只要“死亡”的对象在这个时候将自己与引用链上的任何一个对象建立关联，比如自己赋值给某个类成员变量，这就意味着上诉成功并且得到解放啦！当然如果没抓住这次机会，那肯定就死定了。</p>
<p>注意这里 finalize() 只有一次机会哦。在周老师的书中，也建议我们避免使用它，虽然挺好玩的…但是 finalize() 没啥用，而且运行代价高昂，不确定性大，它能做的工作 try-finally 完全可以做的更好。</p>
</li>
</ul>
</blockquote>
<p>Q：如何回收？</p>
<blockquote>
<p>这个问题比较宽泛，我们做一件事，首先需要理论的指导，然后再去实践。在如何回收这件问题上，我们先要提出一些垃圾收集（回收）的算法，然后再利用这个方法论去具体实现内存的回收——-垃圾收集器。</p>
</blockquote>
<blockquote>
<p>垃圾收集算法。其实就是以一种方法为基础，然后两种方法在某个领域（新生代 or 老年代）更专业，最后一种方法集大成。</p>
<ul>
<li>最基础的方法，标记-清除算法。分为两步，即“标记” 和 “清除”：首先标记出要回收的对象，然后再标记完成后统一回收掉。缺点：一个是效率问题，标记和清除都是需要较多时间，效率低，一个是空间问题，标记清除之后容易产生大量不连续的内存碎片，非常容易造成下一次想分配对象时找不到连续内存而不得触发再一次的 GC ；</li>
<li>复制算法。主要是用在新生代中，因为新生代 98% 的对象都是死得快的…所以我们可以将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间<font color="red">「为什么要设立 Survivor 区，为何是两块，为何不是一块、三块、四块？设立 Survivor 区主要是考虑到防止频繁 full gc，而设立两块，则是为了解决minor gc内存碎片的问题，设立太多反而会造成 Survivor空间太小，导致full gc 频繁，所以两块 Survivor 是最好的。」</font>，然后每次使用 Eden 和 一块 Survivor，另外一块 Survivor 就可以用来存垃圾收集完之后还存活着的对象，这样清理也方便，效率得到解决，同时也不会有空间上的问题，因为可以在复制的时候直接移动堆顶指针按顺序分配就行了。但是吧，这也有个很明显的缺点，就是 Survivor 这块内存被浪费了，并且我们并不能保证每次回收之后的对象大小不超过 Survivor，当 Survivor 空间不够时，我们还需要用到一个策略：<strong>分配担保</strong>。即当 Survivor 空间不够时，这些对象会直接通过分配担保策略进入到老年代；</li>
<li>标记-整理算法。因为老年代存活率很高，肯定就不能用复制算法了，这里的标记-整理算法，就是对标记-清除的升级，在清理之前，由于不能像复制算法一样直接清理，只能是让所有存活的对象都向一端移动，然后再清理掉边界以外的内存； 「G1 就用了这种算法。」</li>
<li>分代收集算法。只是根据对象的存活周期的不同将内存划分为新生代和老年代，然后新生代使用复制算法，老年代使用标记-清理 or 标记-整理。</li>
</ul>
</blockquote>
<blockquote>
<p>垃圾收集算法的实现——垃圾收集器</p>
<p>既然垃圾收集算法，是按照新生代和老年代分别去设计的，那自然垃圾收集器肯定也是按照新生代和老年代去实现。</p>
<p><img src="https://image.baidu.com/search/down?url=https://image.baidu.com/search/down?url=https://tva1.sinaimg.com/large/00831rSTgy1gcjdgfqvx5j30u0140b2a.jpg" alt="垃圾收集器"></p>
<p><strong>新生代的收集器包括</strong></p>
<ol>
<li>Serial</li>
<li>ParNew</li>
<li>Parallel Scavenge</li>
</ol>
<p><strong>2.老年代的收集器包括</strong></p>
<ol>
<li>Serial Old</li>
<li>Parallel Old</li>
<li>CMS</li>
</ol>
<p><strong>3.回收整个Java堆(新生代和老年代)</strong></p>
<ol>
<li>G1收集器</li>
</ol>
<p>具体的搭配如上图所示。下面具体讲一下用的场景和优缺点。</p>
<p>新生代收集器：</p>
<ol>
<li><p><strong>Serial串行收集器-复制算法</strong></p>
<p>Serial收集器是新生代单线程收集器，优点是简单高效，是最基本、发展历史最悠久的收集器。它在进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集完成。但依然是虚拟机运行在Client模式下默认新生代收集器，对于运行在Client模式下的虚拟机来说是一个很好的选择。</p>
</li>
<li><p><strong>ParNew收集器-复制算法</strong></p>
<p>也是<strong>新生代并行收集器</strong>，其实就是Serial收集器的多线程版本。主义只能做到并行，不能并发。除了使用多线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数、收集算法、Stop The World、对象分配规则、回收策略等都与Serial 收集器完全一样。</p>
<blockquote>
<p>并行：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</p>
<p>并发：用户线程和多垃圾收集线程同时执行（但不一定是并行的，可能是交替执行）</p>
</blockquote>
</li>
<li><p><strong>Parallel Scavenge（并行回收）收集器-复制算法</strong><br>新生代并行收集器，追求高吞吐量，高效利用 CPU。该收集器的目标是达到一个可控制的吞吐量（Throughput）。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即 吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），所以该收集器也被常称为 “吞吐量优先”收集器。</p>
<p>它和 ParNew 的主要区别有两个：</p>
<ul>
<li>关注点不一样，一个是为了停顿时间更短，这适合用户交互，一个则是为了最高的利用 CPU 时间，适合后台运算；</li>
<li>Parallel Scanvenge 有 <strong><em>GC 自适应的调节策略</em></strong>，无需自己设置新生代大小、Eden 和 Survivor的比例等等，只需要把基本的内存数据（如堆大小、吞吐量）设置好即可。</li>
</ul>
<p>好像都是优点，但是其有一个致命的缺陷，就是它不能跟 CMS 搭配，所以CMS 还是一般和 ParNew 联合使用。</p>
</li>
</ol>
<p>老年代收集器：</p>
<ol>
<li><p><strong>Serial Old 收集器-标记 - 整理算法</strong></p>
<p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程(串行)收集器，使用标记整理算法。这个收集器的主要意义也是在于<strong>给Client模式下的虚拟机使用</strong>。</p>
<p><strong>如果在Server模式下，主要两大用途：</strong></p>
<p>（1）在JDK1.5以及之前的版本中与Parallel Scavenge收集器搭配使用；</p>
<p>（2）作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p>
</li>
<li><p><strong>Parallel Old 收集器-标记 - 整理算法</strong></p>
<p>Parallel Old 是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在1.6中才开始提供。</p>
</li>
<li><p><strong>CMS 收集器-标记 - 清除算法</strong></p>
<p>CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。适用于互联网站的服务器端。提高响应速度。</p>
<p>它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤：</p>
<ol>
<li>初始标记。标记 GC Roots 能直接关联到的对象，速度非常快；</li>
<li>并发标记，收集器线程和用户线程同步进行；</li>
<li>重新标记，修正并发标记期间的变化；</li>
<li>并发清除。</li>
</ol>
<p>所以优点很明显：1. 并发收集；2. 低停顿，所以又称为 “并发低停顿收集器”；</p>
<p>缺点也有：</p>
<ol>
<li>对 CPU 资源敏感，默认启用 （CPU 数量 + 3）/4，cpu少的话那影响很大；</li>
<li>无法处理浮动垃圾「清理阶段可能会有新的垃圾产生」，可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。在JDK1.5的默认设置下，CMS收集器当老年代使用了68%的空间后就会被激活。</li>
<li>CMS是基于“标记-清除”算法实现的收集器，手机结束时会有大量空间碎片产生。空间碎片过多，可能会出现老年代还有很大空间剩余，但是无法找到足够大的连续空间来分配当前对象，<strong>不得不提前触发FullGC</strong>。</li>
</ol>
</li>
</ol>
<p>新生代和老年代垃圾收集器：</p>
<p><strong>G1 收集器-分代收集算法</strong> — 兼顾 吞吐量 &amp; 低停顿</p>
<ol>
<li><p>独特的分代垃圾回收器,分代GC: 分代收集器, 同时兼顾年轻代和老年代；</p>
</li>
<li><p>使用分区算法, 不要求eden, 年轻代或老年代的空间都连续；</p>
</li>
<li><p>并行性: 回收期间, 可由多个线程同时工作, 有效利用多核cpu资源；</p>
</li>
<li><p>空间整理: 回收过程中, 会进行适当对象移动, 减少空间碎片；</p>
</li>
<li><p>可预见性: G1可选取部分区域进行回收, 可以缩小回收范围, 减少全局停顿。 </p>
</li>
</ol>
<p><strong>G1收集器的阶段分以下几个步骤：</strong></p>
<p>1、初始标记（它标记了从GC Root开始直接可达的对象）；</p>
<p>2、并发标记（从GC Roots开始对堆中对象进行可达性分析，找出存活对象）；</p>
<p>3、最终标记（标记那些在并发标记阶段发生变化的对象，将被回收）；</p>
<p>4、筛选回收（首先对各个Region的回收价值和成本进行排序，根据用户所期待的GC停顿时间指定回收计划，优先回收垃圾最多的Region，因此称为 Garbage First）。</p>
<p>经常使用的参数：</p>
<p>-XX:+UseSerialGC：在新生代和老年代使用串行收集器<br>-XX:+UseParNewGC：在新生代使用并行收集器<br>-XX:+UseParallelGC ：新生代使用并行回收收集器，更加关注吞吐量<br>-XX:+UseParallelOldGC：老年代使用并行回收收集器<br>-XX:ParallelGCThreads：设置用于垃圾回收的线程数<br>-XX:+UseConcMarkSweepGC：新生代使用并行收集器，老年代使用CMS+串行收集器<br>-XX:ParallelCMSThreads：设定CMS的线程数量<br>-XX:+UseG1GC：启用G1垃圾回收器</p>
</blockquote>
<p>上面三个问题，基本解决了垃圾收集方面的问题了，那回过头来，对象又是如何分配内存的呢？</p>
<blockquote>
<ol>
<li><p>对象优先在新生代 Eden 区中分配，当 Eden 区没有足够的空间进行分配时，虚拟机会发起一次 Minor GC，将 GC 后还存活的对象转移Survivor区，如果Survivor区溢出了会转移到老年代中。</p>
<blockquote>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为 Java 对象大都具有死得快的特性，所以 Minor GC 会非常的频繁，速度也很快；</p>
<p>老年代GC（Major GC/Full GC）:指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次 Minor GC，当然也并非绝对，在 ParallelScaVenge 就有直接进行 Major GC 的策略选择过程。Major GC 的速度比 Minor GC 慢 10倍以上。</p>
</blockquote>
</li>
<li><p>大对象会直接进入老年代，因为就算安排进新生代的 Eden 区，Eden 区及两个 Survivor区之间会进行大量的内存拷贝，而且极有可能 Survivor 装不下进而触发<strong>分配担保机制</strong>转移到老年代，与其这样，不如直接将大对象直接进入老年代。 </p>
</li>
</ol>
</blockquote>
<p>上文一直在讲新生代和老年代，那二者到底是如何界定呢？</p>
<blockquote>
<p>虚拟机给每个对象都定义了一个对象年龄计数器，如果对象在新生代的 Eden 区域出生并且经过第一次 Minor GC 后仍然留在 Survivor 中，那么他的对象年龄变为 1 岁，从此之后，该对象在 Survivor 每熬过一次 Minor GC ，年龄就会增加一岁，默认会到 15 岁才晋升到老年代中，阈值可以通过参数 -XX:MaxTenuringThreshold设置。</p>
<p>当然，为了适应不同程序的内存情况，虚拟机并不会总是按照对象年龄大于MaxTenuringThreshold才晋升到老年代，如果 <strong>Survivor 空间中相同年龄的对象的总大小已经超过了 Survivor 的空间的一半</strong>，则年龄大于或等于该年龄的对象直接就可以晋升到老年代。</p>
</blockquote>
<p>那为何要有这种动态年龄计算呢？</p>
<blockquote>
<p>如果固定按照MaxTenuringThreshold设定的阈值作为晋升条件：</p>
<p>a）MaxTenuringThreshold设置的过大，原本应该晋升的对象一直停留在Survivor区，直到Survivor区溢出，一旦溢出发生，Eden+Svuvivor中对象将不再依据年龄全部提升到老年代，这样对象老化的机制就失效了。 </p>
<p>b）MaxTenuringThreshold设置的过小，“过早晋升”即对象不能在新生代充分被回收，大量短期对象被晋升到老年代，老年代空间迅速增长，引起频繁的Major GC。分代回收失去了意义，严重影响GC性能。</p>
</blockquote>
<p>在本章的最后，再来详细叙述一下空间<strong>分配担保</strong>。</p>
<blockquote>
<ol>
<li><p>在发生 Minor GC时，虚拟机 会检测一下之前每次晋升到老年代的平均大小是否大于老年代的剩余空间大小（因为在实际回收之前是无法确定本轮的对象大小是多少，只能按以往的经验值估计）</p>
</li>
<li><p>如果大于，说明，崩了，只能进行 Full GC了;</p>
</li>
<li><p>如果小于，则再查看 HandlePromotionFailure（处理晋升失败）的设置（默认打开，不然Full GC 太频繁了，慢的一批），</p>
</li>
<li>如果允许，则只会进行 Minor GC，如果Minor GC后担保失败，那就没办法了只能选择Full GC，否则如果不允许失败，那就只能进行 Full GC。</li>
</ol>
</blockquote>
<font color="red">谈到这么多次 Full GC，Minor GC那我想问一个问题，如果 Full GC  or Minor GC 频繁，有哪些原因导致？</font>

<blockquote>
<p>Full GC 频繁：</p>
<p>先来分析一下，什么时候会触发 Full GC:</p>
<ol>
<li>程序执行了System.gc()    //建议jvm执行fullgc，并不一定会执行</li>
<li>执行了jmap -histo:live pid命令    //这个会立即触发fullgc…这个可以不讲</li>
<li>在执行minor gc的时候进行的一系列检查    // 三次 fullgc 的可能</li>
<li>使用了很多短命的大对象      // 大对象直接进入到老年代</li>
<li>在程序中长期持有了对象的引用          //对象年龄达到指定阈值也会进入老年代</li>
</ol>
<p>首先 1 2 这两情况我们不考虑，第 4  5 种情况也不用分析了，重点是第 3 种情况，minor gc 后导致 full gc，我觉得原因可能有：</p>
<ol start="2">
<li>Eden 设置过小 or Survivor 设置过小，导致频繁触发 minor gc  or 担保策略触发，这种情况下一次 full gc后，剩余的对象应该很少。</li>
<li>可能是老年代内存设置过小，导致很容易 full gc。这种情况下，一次 full gc 后，在老年代中内存应该不会减少很多，回收率很低。</li>
</ol>
<p>所以总的来说，先看一次回收 full gc 后的结果，然后再进行判断。</p>
</blockquote>
<blockquote>
<p>Minor GC 频繁：</p>
<p>那就只能是 Eden 设置的太小了。</p>
</blockquote>
<font color="red">JVM 调优的基本思路：</font>

<p>如果是 CMS</p>
<ol>
<li>通过看JDK自带的图形化工具，检查线程的状态。了解到一个Java进程有多少线程，每个线程什么状态，是不是在等着锁：进程的CPU和内存占用了多少；</li>
<li>如果发现程序跑得很慢，就用图形化界面去看 GC 日志；</li>
<li>总的来说就是要去合理设置年轻代和老年代的大小，这是一个迭代的过程，可以采用 JVM 默认的配置通过压力测试去分析 GC 日志；</li>
<li>如果发现经常 Minor GC，并且回收率并不高，则说明 Eden 区设置的过小；</li>
<li>如果发现经常 Full GC，先考虑是不带自己写的代码有问题，比如执行了 System.gc()、使用了过多全局变量、使用了很多短命的大对象，然后如果排查不出来；</li>
<li>再考虑参数调优，如果发现 Full GC 后内存占有率下来了，说明清除了大量垃圾，可以考虑调大年轻代 Eden or Survivor，如果没下来，可能是 内存泄漏 or 老年代太小。</li>
</ol>
<p>如果是 G1，则直接调大堆的内存应该就行了。因为G1收集器采用了局部区域收集策略，单次垃圾收集的时间可控，可以管理较大的Java堆。</p>
<p><img src="https://image.baidu.com/search/down?url=https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcladf39x1j30t80tk0yl.jpg" alt="img"></p>
<h1 id="第六章-类文件结构"><a href="#第六章-类文件结构" class="headerlink" title="第六章 类文件结构"></a>第六章 类文件结构</h1><h2 id="编译过程"><a href="#编译过程" class="headerlink" title="编译过程"></a>编译过程</h2><p>这一章其实还是比较简单但是枯燥的，主要是讲了 Class 文件字节码结构。</p>
<p>将 .java 文件变成 .class 文件，就是我们常说的编译过程，这一过程是靠 javac 这个编译器完成的。Java 和 C/C++ 不一样，C/C++ 是通过直接将源代码编译成目标机器码（CPU直接执行的指令集合），而 Java 则是在中间加了一层字节码，也就是把 java文件转换成 class 字节码，然后 JVM 能够识别字节码，也就是能够加载 .class 文件（进而再通过 JVM 将字节码转换为机器码，这一步也可没有）。</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckg5qiid9j30n706kgmu.jpg" alt="img"></p>
<blockquote>
<p>————————————————<br>版权声明：本文为CSDN博主「麦田」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/itmyhome1990/article/details/78847266" target="_blank" rel="noopener">https://blog.csdn.net/itmyhome1990/article/details/78847266</a></p>
</blockquote>
<h2 id="Class-文件组成"><a href="#Class-文件组成" class="headerlink" title="Class  文件组成"></a>Class  文件组成</h2><p>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里（譬如类或接口也可以通过类加载器直接生成）。Class 文件是一组以 8 位字节为基础单位的二进制流。</p>
<p>根据 Java 虚拟机规范的规定，Class 文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：无符号数和表</p>
<p>无符号数属于基本的数据类型，以u1、 u2、 u4、 u8来分别代表1个字节、 2个字节、 4个字节和8个字节的无符号数，无符号数可以用来描述数字、 索引引用、 数量值或者按照UTF-8编码构成字符串值。</p>
<p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。 表用于描述有层次关系的复合结构的数据，整个 Class 文件本质上就是一张表，它由如下表所示的数据项构成。</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gck8v86moxj310a0n2q53.jpg" alt="img"></p>
<p>如上图所示，整个 Class 文件 按如下排列：<strong>魔数(4) – 次版本号(2) – 主版本号(2) – 常量池常量数(2) – 常量池表(不确定长度) – 访问标志(2) – 类索引(2) – 父类索引(2) – 实现的接口数(2) – 实现的接口集合(2) – 实现的字段数(2) – 字段集合表(不确定长度) – 方法数(2) – 方法集合表(不确定长度) – 属性数(2) – 属性集合表(不确定长度)。</strong></p>
<h3 id="具体组成部分"><a href="#具体组成部分" class="headerlink" title="具体组成部分"></a>具体组成部分</h3><h4 id="1-魔数"><a href="#1-魔数" class="headerlink" title="1. 魔数"></a>1. 魔数</h4><p>每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。</p>
<h4 id="2-Class文件的版本"><a href="#2-Class文件的版本" class="headerlink" title="2. Class文件的版本"></a>2. Class文件的版本</h4><p>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（MinorVersion），第7和第8个字节是主版本号（Major Version）。 Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p>
<h4 id="3-常量池"><a href="#3-常量池" class="headerlink" title="3. 常量池"></a>3. 常量池</h4><p>常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</p>
<p>常量池中主要存放两大类常量：<code>字面量（Literal）和符号引用（Symbolic References）</code>。字面量比较接近于Java语言层面的常量概念，如文本字符串、 声明为final的常量值等。 而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p>
<ul>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
</ul>
<p>常量池中的每一项又对应着一个表，总共11种数据类型的结构，注意 tag = 2 这个值没有：</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gck930bpd0j312q0sagxf.jpg" alt="image-20200306154209266"></p>
<h4 id="4-访问标志"><a href="#4-访问标志" class="headerlink" title="4. 访问标志"></a>4. 访问标志</h4><p>在常量池结束之后，紧接着的两个字节代表访问标志(access_flags),这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。</p>
<h4 id="5-类索引、-父类索引与接口索引集合"><a href="#5-类索引、-父类索引与接口索引集合" class="headerlink" title="5. 类索引、 父类索引与接口索引集合"></a>5. 类索引、 父类索引与接口索引集合</h4><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。 类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。 由于Java语言不允许多重继承，所以父类索引只有一个，除了java.lang.Object之外，所有的Java类都有父类，因此除了java.lang.Object外，所有Java类的父类索引都不为0。 接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。</p>
<p>类索引、 父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p>
<p>对于接口索引集合，入口的第一项——u2类型的数据为接口计数器（interfaces_count），表示索引表的容量。 如果该类没有实现任何接口，则该计数器值为0，后面接口的索引表不再占用任何字节。</p>
<h4 id="6-字段表集合"><a href="#6-字段表集合" class="headerlink" title="6. 字段表集合"></a>6. 字段表集合</h4><p>字段表（field_info）用于描述<strong>接口或者类中声明的变量</strong>。其实也就是类的静态变量或者是实例成员变量。 字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。 我们可以想一想在Java中描述一个字段可以包含什么信息？可以包括的信息有：字段的作用域（public、 private、 protected修饰符）、 是实例变量还是类变量（static修饰符）、 可变性（final）、 并发可见性（volatile修饰符，是否强制从主内存读写）、 可否被序列化（transient修饰符）、 字段数据类型（基本类型、 对象、 数组）、 字段名称。 上述这些信息中，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。 而字段叫什么名字、 字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。</p>
<h4 id="7-方法表集合"><a href="#7-方法表集合" class="headerlink" title="7. 方法表集合"></a>7. 方法表集合</h4><p>和字段表基本一样，仅在访问标志和属性表集合的可选项有些区别。就是看方法有没有被 synchronized、abstract、final等修饰。</p>
<h4 id="8-属性表集合"><a href="#8-属性表集合" class="headerlink" title="8. 属性表集合"></a>8. 属性表集合</h4><p>属性表集合中包含了大量的数据信息，上面的所有类型都有十分严格顺序，长度，大小。而属性表中就没有那么严格了，我们编写的最多的Code就存放在属性表集合中的CODE表中，一共有21项比如还包含：Exception表等等。具体的每一个项都是有意义的，有点多简单的介绍一下主要的：</p>
<p>1、Code 属性</p>
<p>Java方法体里面的代码经过Javac编译之后，最终变为字节码指令存储在Code属性内，Code属性出现在方法表的属性集合中，但在接口或抽象类中就不存在Code属性。</p>
<p>2、Exception属性</p>
<p>列举出方法中可能抛出的受查异常。</p>
<p>3、LineNumberTable属性</p>
<p>描述Java源码行号与字节码行号（字节码的偏移量）之间的对应关系。主要是如果抛出异常时，编译器会显示行号，就是这个属性的作用。</p>
<p>4、LocalVariableTable属性</p>
<p>描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系。用处在于当别人使用这个方法是能够显示出方法定义的参数名。</p>
<p>5、SourseFile属性</p>
<p>记录生成这个Class文件的源码文件名称，抛出异常时能够显示错误代码所属的文件名。</p>
<p>6、ConstantValue属性</p>
<p>通知虚拟机自动为静态变量赋值，只有被static字符修饰的变量（类变量）才可以有这项属性。</p>
<p>7、InnerClass属性</p>
<p>用于记录内部类与宿主类之间的关联。</p>
<p>8、Deprecated和Synthetic属性</p>
<p>这两个都是标志类型的布尔属性，Deprecated表示不再推荐使用，注解@deprecated<br>Synthetic表示此字段或方法是由编译器自行添加的。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>为了更好的理解 Class 的组成部分，我决定写一个 demo，让我们一步步来分析一下。</p>
<h3 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JVM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.A();</span><br><span class="line">        System.out.println(<span class="number">2222</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test_heap_outOfMemory t = <span class="keyword">new</span> test_heap_outOfMemory();</span><br><span class="line">        t.C();</span><br><span class="line">        SubClass subClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">        subClass.A();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Byte-Code-viewer"><a href="#Byte-Code-viewer" class="headerlink" title="Byte Code viewer"></a>Byte Code viewer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span>/<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">JVM</span>/<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: SubClass.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">3</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL JVM/SuperClass.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LJVM/SubClass; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 6 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    INVOKESPECIAL JVM/SuperClass.<span class="title">A</span> <span class="params">()</span>V</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LINENUMBER 7 L1</span></span><br><span class="line"><span class="function">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">    SIPUSH <span class="number">2222</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br><span class="line">   L2</span><br><span class="line">    LINENUMBER <span class="number">8</span> L2</span><br><span class="line">    RETURN</span><br><span class="line">   L3</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LJVM/SubClass; L0 L3 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 11 L0</span></span><br><span class="line"><span class="function">    NEW JVM/test_heap_outOfMemory</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL JVM/test_heap_outOfMemory.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 1</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LINENUMBER 12 L1</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    INVOKEVIRTUAL JVM/test_heap_outOfMemory.<span class="title">C</span> <span class="params">()</span>V</span></span><br><span class="line"><span class="function">   L2</span></span><br><span class="line"><span class="function">    LINENUMBER 13 L2</span></span><br><span class="line"><span class="function">    NEW JVM/SubClass</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL JVM/SubClass.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 2</span></span><br><span class="line"><span class="function">   L3</span></span><br><span class="line"><span class="function">    LINENUMBER 14 L3</span></span><br><span class="line"><span class="function">    ALOAD 2</span></span><br><span class="line"><span class="function">    INVOKEVIRTUAL JVM/SubClass.<span class="title">A</span> <span class="params">()</span>V</span></span><br><span class="line"><span class="function">   L4</span></span><br><span class="line"><span class="function">    LINENUMBER 17 L4</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L5</span></span><br><span class="line"><span class="function">    LOCALVARIABLE args [Ljava/lang/String</span>; L0 L5 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE t LJVM/test_heap_outOfMemory; L1 L5 <span class="number">1</span></span><br><span class="line">    LOCALVARIABLE subClass LJVM/SubClass; L3 L5 <span class="number">2</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="jsclasslib"><a href="#jsclasslib" class="headerlink" title="jsclasslib"></a>jsclasslib</h3><p>我们使用 jsclasslib 这个可视化界面来看一下具体的 class 信息。</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcnsflnw07j30uk0u0424.jpg" alt="image-20200309170821767"></p>
<p>首先可以看到， jdk的版本的主版本号是 1.8，次版本号是 0，常量池的总数是34，访问标志，即该类是 public or default，然后左边对应的有常量池、接口表、字段表、属性表、方法表。</p>
<blockquote>
<p>详细分析可以看这个：<a href="https://juejin.im/post/5b5ac6d76fb9a04f8d6bc7d6#heading-29" target="_blank" rel="noopener">https://juejin.im/post/5b5ac6d76fb9a04f8d6bc7d6#heading-29</a></p>
</blockquote>
<h1 id="第七章-虚拟机类加载机制"><a href="#第七章-虚拟机类加载机制" class="headerlink" title="第七章 虚拟机类加载机制"></a>第七章 虚拟机类加载机制</h1><blockquote>
<p>参考：<a href="https://juejin.im/post/5ae2d580f265da0b851c95ea#heading-17" target="_blank" rel="noopener">https://juejin.im/post/5ae2d580f265da0b851c95ea#heading-17</a></p>
</blockquote>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>在第六章，讲到了 Class 文件，那我们是如何将 Class 文件加载到虚拟机，然后运行和使用呢？</p>
<h3 id="1-1-虚拟机类加载机制的概念"><a href="#1-1-虚拟机类加载机制的概念" class="headerlink" title="1.1 虚拟机类加载机制的概念"></a>1.1 虚拟机类加载机制的概念</h3><p>虚拟机把描述类的数据从class文件<strong>加载</strong>到内存，并对数据进行<strong>校验</strong>、<strong>转换解析</strong>和<strong>初始化</strong>。最终形成可以被虚拟机最直接使用的java类型的过程就是虚拟机的<strong>类加载机制</strong>。</p>
<h3 id="1-2-Java语言的动态加载和动态连接"><a href="#1-2-Java语言的动态加载和动态连接" class="headerlink" title="1.2  Java语言的动态加载和动态连接"></a>1.2  Java语言的动态加载和动态连接</h3><p>另外需要注意的很重要的一点是：<strong>java语言中类型的加载连接以及初始化过程都是在程序运行期间完成的</strong>，这种策略虽然会使类加载时稍微增加一些性能开销，但是会为java应用程序提供高度的<strong>灵活性</strong>。java里天生就可以动态扩展语言特性就是依赖运行期间动态加载和动态连接这个特点实现的。比如，如果编写一个面向接口的程序，可以等到运行时再指定其具体实现类。</p>
<p>注意，下文的 Class 文件其实是指一串二进制的字节流，可以没有必要是文件形式，同时，每个 Class 文件都可能代表一个类或接口。</p>
<h2 id="2-类加载时机"><a href="#2-类加载时机" class="headerlink" title="2. 类加载时机"></a>2. 类加载时机</h2><p>类的整个生命周期包括：</p>
<p>加载(Loading) —— 验证(Verification) —— 准备(Preparation) —— 初始化(Initialization) ——- 使用(Using) —— 卸载(Unloading) ，其中 验证、准备、解析 统称为连接(Linking)</p>
<font color="blue">需要注意的是，只有加载、验证、准备、初始化、卸载这 5 个阶段的顺序是确定的，当然确定的也只是开始的时间，因为这些阶段都是互相交叉地混合进行，通常会在一个阶段执行的过程中去对调用和激活另外一个阶段。而解析阶段，可以在初始化后再开始，这就是为了支持 Java 的运行时绑定。</font> 

<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckfy191awj30kb06bgnj.jpg" alt="img"></p>
<p>虚拟机 jvm 并没有规范什么时候开始加载，但是规定了初始化的时间，有且只有4种情况才会立即对类进行“初始化”(自然加载、验证、准备都要在之前开始)：</p>
<ul>
<li><p>使用 new 关键字实例化对象的时候、读取或设置一个类的静态字段的时候（注意：<strong>final修饰并且在编译前间就已经将结果放置在了常量池中的静态字段除外</strong>），以及调用一个类的静态方法的时候；</p>
</li>
<li><p>使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有初始化，则需要先触发其初始化。「反射的过程我在另外一篇文章已经讲过了。」</p>
</li>
<li><p>当初始化一个类的时候，如果发现其父类没有被初始化就会先初始化它的父类。</p>
</li>
<li><p>当虚拟机启动的时候，用户需要指定一个要执行的主类（就是包含main()方法的那个类），虚拟机会先初始化这个类；</p>
</li>
</ul>
<p>以上 4 种称之为对类的主动使用，会触发相应的初始化，而比较典型几种被动使用，不会触发初始化的情况有：</p>
<ul>
<li>通过子类访问父类的 static 变量，不会引起子类的初始化；</li>
<li>定义引用数组，不会初始化类；</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Obj[] arrays = <span class="keyword">new</span> Obj[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>上面说的，用 final 修饰并且在编译期间(生成.class文件期间)就已经将结果写入了常量池中。</li>
</ul>
<p>当然，对于接口来说，与类相比在初始化阶段也略有不同（主动使用只有3种情况），就是在初始化一个接口时，如果发现父亲接口没有初始化，并不会去初始化父亲接口，而是等用到了才会去初始化。</p>
<h2 id="3-类加载过程"><a href="#3-类加载过程" class="headerlink" title="3. 类加载过程"></a>3. 类加载过程</h2><p>接下来详细讲一下类加载的全过程，也就是加载、验证、准备、解析、初始化这 5 个阶段的过程。</p>
<h3 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h3><p><strong>“加载”</strong> 是 <strong>“类加载”</strong> 过程的一个阶段，切不可将二者混淆。</p>
<p><strong>加载阶段由三个基本动作组成：</strong></p>
<ol>
<li>通过类型的完全限定名，产生一个代表该类型的二进制数据流（根本没有指明从哪里获取、怎样获取，可以说一个非常开放的平台了）；</li>
<li>解析这个二进制数据流为方法区内的运行时数据结构；</li>
<li>在 Java 堆中创建一个表示该类型的java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p><strong>通过类型的完全限定名，产生一个代表该类型的二进制数据流的几种常见形式：</strong></p>
<ul>
<li>从zip包中读取，成为日后JAR、EAR、WAR格式的基础；</li>
<li>从网络中获取，这种场景最典型的应用就是Applet；</li>
<li>运行时计算生成，这种场景最常用的就是动态代理技术了；</li>
<li>由其他文件生成，比如我们的JSP。</li>
</ul>
<h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是<strong>为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</strong>。</p>
<p>虚拟机如果不检查输入的字节流，并对其完全信任的话，很可能会因为载入了有害的字节流而导致系统崩溃，所以验证是虚拟机对自身保护的一项重要工作。这个阶段是否严谨，直接决定了java虚拟机是否能承受恶意代码的攻击。</p>
<p>从整体上看，验证阶段大致上会完成4个阶段的校验工作：<strong>文件格式验证、元数据验证、字节码验证、符号引用验证</strong>。</p>
<ul>
<li><p>文件格式验证。主要是确保输入的字节流能够正确的解析并存储于方法区之中，这阶段的验证基于字节流进行，该验证结束后，字节流就进入到了内存中的方法区，进行存储，所以后续三个验证阶段全是基于方法区的存储结构；</p>
</li>
<li><p>元数据验证。现在其实 jdk1.8 之后没有方法区了，改名叫做元数据区。这个阶段是对字节码描述的信息进行语义分析，保证是 java规范的信息；</p>
</li>
<li><p>字节码验证。验证中最复杂的，主要工作是进行数据流和控制流分析，保证类的方法在运行时不会做出危害虚拟机安全的行为；</p>
</li>
<li><p>符号引用验证。这个验证会发生在虚拟机将符号引用转化为直接引用的时候，也就是在解析过程中的发生，可以看作是对类自身以外的信息进行匹配性的校验，确保解析动作能够正常执行。</p>
<p><strong>验证的内容主要有：</strong></p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类；</li>
<li>在指定类中是否存在符号方法的字段描述及简单名称所描述的方法和字段；</li>
<li>符号引用中的类、字段和方法的访问性（private、protected、public、default）是否可被当前类访问。</li>
</ul>
</li>
</ul>
<h3 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h3><p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckippfkaej314y0h613y.jpg" alt="image-20200306211519183"></p>
<font color="red">这一块我有一些不太理解，为什么在初始化阶段，字节码就被编译成指令存放在构造器\<clinit>() 方法中了？？？？啥时候编译成指令的啊，这个构造方法又是什么时候产生的。。。。。</clinit></font>

<p>回答：编译成指令，是在源代码通过 javac 编译成 class 文件时生成的，在第六章有讲，在方法表中，有存放属性表，而属性表里有一个 Code 属性，里面就是存储的 Java 代码编译后的字节码指令。</p>
<p><strong>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区中进行分配。</strong>（备注：这时候进行内存分配的仅包括类变量（被static修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在Java堆中）。</p>
<p><strong>初始值通常是数据类型的零值：</strong></p>
<p>对于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>那么变量value在准备阶段过后的初始值为0而不是123，这时候尚未开始执行任何java方法，把value赋值为123的动作将在初始化阶段才会被执行。</p>
<p><strong>一些特殊情况：</strong></p>
<p>对于：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> value = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>编译时 Javac 将会为 value 生成 ConstantValue属性，在准备阶段 虚拟机 就会根据 ConstantValue 的设置将 value 赋值为123。</p>
<p><strong>基本数据类型的零值：</strong></p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckiy6h77ij311o0e8mzj.jpg" alt="image-20200306212331780"></p>
<h3 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h3><p><strong>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。</strong></p>
<p><strong>那么符号引用与直接引用有什么关联呢？</strong></p>
<h4 id="3-4-1-看两者的概念"><a href="#3-4-1-看两者的概念" class="headerlink" title="3.4.1 看两者的概念"></a>3.4.1 看两者的概念</h4><p><strong>符号引用(Symbolic References)：</strong> 符号引用以一组符号来描述所引用的目标，符号可以是符合约定的任何形式的字面量，符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到内存中。</p>
<p><strong>直接引用（Direct References）:</strong> 直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用与虚拟机实现的内存布局相关，<strong>引用的目标必定已经在内存中存在</strong>。</p>
<p>虚拟机规范没有规定解析阶段发生的具体时间，虚拟机实现可以根据需要来判断到底是在类被加载时解析「一般是静态方法和私有方法两大类，符合“编译期可知，运行期不可变”，因为这两类方法不可能通过继承或者其他方式进行重写。第八章有详细讲。」还是等到一个符号引用将要被使用前才去解析。</p>
<h4 id="3-4-2-对解析结果进行缓存"><a href="#3-4-2-对解析结果进行缓存" class="headerlink" title="3.4.2 对解析结果进行缓存"></a>3.4.2 对解析结果进行缓存</h4><p>同一符号引用进行多次解析请求是很常见的，除 invokedynamic 指令以外，虚拟机实现可以对第一次解析结果进行缓存，来避免解析动作重复进行。无论是否真正执行了多次解析动作，虚拟机需要保证的是在同一个实体中，如果一个引用符号之前已经被成功解析过，那么后续的引用解析请求就应当一直成功；同样的，如果 第一次解析失败，那么其他指令对这个符号的解析请求也应该收到相同的异常。</p>
<h4 id="3-4-3-解析动作的目标"><a href="#3-4-3-解析动作的目标" class="headerlink" title="3.4.3 解析动作的目标"></a>3.4.3 解析动作的目标</h4><p>解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。前面四种引用的解析过程，对于后面三种，与JDK1.7新增的动态语言支持息息相关，由于java语言是一门静态类型语言，因此没有介绍 invokedynamic 指令的语义之前，没有办法将他们和现在的java语言对应上。</p>
<h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h3><p>类初始化阶段是类加载的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的java程序代码（或者说是字节码）。</p>
<p>初始化阶段，<strong>主要还是去执行类构造器 \<clinit>() 方法的过程</clinit></strong>。<font color="red">「啥时候有这个构造方法的书中说后面会说。。。。好的吧。。。。继续往下看」</font>也就是进行第二次的赋值，其中 \<clinit>() ：</clinit></p>
<ul>
<li>\<clinit>() 是由编译器(javac???)自动收集类中的所有类变量的赋值动作和静态语句块(也就是所有 static 变量 和 静态语句块) 合并产生的，顺序按照先后顺序。同时注意哦，static 静态代码块，可以赋值后面定义的静态变量，不过貌似没毛用。。。。</clinit></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"SubClass init!"</span>);</span><br><span class="line">        A = <span class="number">2</span>;   <span class="comment">// 反正它也不会被 used，因为会被覆盖掉</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> A = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>\<clinit>() 这个方法很牛叉，为啥呢，因为它会默认先调用父类的 \<clinit>() ，压根就不需要去显示的调用，所以第一个被执行的 \<clinit>() 方法的类肯定是java.lang.Object；</clinit></clinit></clinit></p>
</li>
<li><p>既然父类要先执行，那肯定静态语句块肯定也是优先执行的，这个让我想到了之前的被动调用类的例子，如果子类调用父类的 static 变量，那么子类是不会被初始化的；</p>
</li>
<li><p>\<clinit>()  对于类或者接口不是必须的，如果没有 static 变量 和 静态语句块，那么就不会有这个方法，当然接口本身就不可能有 静态语句块，同时要注意的是，执行接口的 \<clinit>() 方法不需要去先执行 父接口的 \<clinit>() ，父接口只有被调用的时候才去执行，这点跟接口主动调用原则保持一致。</clinit></clinit></clinit></p>
</li>
<li><p>\<clinit>() 线性安全，是通过加锁保持同步的。</clinit></p>
</li>
</ul>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckjrgkib3j30u011gqje.jpg" alt="image-20200306215139668"></p>
<h2 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4. 类加载器"></a>4. 类加载器</h2><p>回顾一下，类加载的第一步 “加载” 总共进行了三个基本动作：</p>
<ol>
<li>通过类型的完全限定名，产生一个代表该类型的二进制数据流（根本没有指明从哪里获取、怎样获取，可以说一个非常开放的平台了）；</li>
<li>解析这个二进制数据流为方法区内的运行时数据结构；</li>
<li>在 Java 堆中创建一个表示该类型的java.lang.Class类的实例，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p>我们知道，第一个动作，很牛逼，只要得到类型的完全限定名，就能产生一个代表该类型的二进制数据流，那这个是如何做到的呢？就是通过类加载器，注意哦，这个是放到了 jvm 外部去实现的，也就是我们可以自己决定如何去获取需要的类，只要你把二进制数据流没毛病的转化到方法区的运行时数据结构即可。</p>
<h3 id="4-1-类与类加载器"><a href="#4-1-类与类加载器" class="headerlink" title="4.1 类与类加载器"></a>4.1 类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。如果两个类来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。其实很容易理解，类加载器不同，那产生的二进制流必然不同。</p>
<h3 id="4-2-类加载器介绍"><a href="#4-2-类加载器介绍" class="headerlink" title="4.2 类加载器介绍"></a>4.2 类加载器介绍</h3><p>从 Java 虚拟机的角度分为两种不同的类加载器：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>，使用C++语言实现，是虚拟机自身的一部分； </li>
<li><strong>其他类加载器</strong>。由Java语言实现，独立于虚拟机之外，并且全都继承自<strong>java.lang.ClassLoader类</strong>。（这里只限于HotSpot虚拟机）。</li>
</ul>
<p>从 Java 开发人员的角度看，大部分Java程序都会使用到以下3种系统提供的类加载器：</p>
<ul>
<li><p><strong>启动类加载器（Bootstrap ClassLoader）：</strong></p>
<p>这个类加载器负责将存放在&lt;JAVA_HOME&gt;\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。</p>
</li>
<li><p><strong>扩展类加载器（Extension ClassLoader）：</strong></p>
<p>这个加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载&lt;JAVA_HOME&gt;\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。</p>
</li>
<li><p><strong>应用程序类加载器（Application ClassLoader）：</strong></p>
<p>这个类加载器由sun.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</p>
</li>
</ul>
<p>我们的应用程序都是由这3种类加载器互相配合进行加载的，如果有必要，还可以加入自己定义的类加载器。</p>
<h3 id="4-3-双亲委派模型"><a href="#4-3-双亲委派模型" class="headerlink" title="4.3 双亲委派模型"></a>4.3 双亲委派模型</h3><p>要求除了顶层的启动类加载器以外，所有的类加载器都应该有父类加载器，这里的父子关系不是通过继承来的，而是通过<strong>组合关系</strong>。</p>
<blockquote>
<p>Tip: 组合和继承的区别与联系</p>
<p>继承与组合都是面向对象中代码复用的方式。</p>
<ul>
<li>继承在编码过程中就要指定具体的父类，其关系在编译期就确定，而组合的关系一般在运行时确定。</li>
<li>继承强调的是 is-a 的关系，而组合强调的是has-a 的关系。</li>
<li>其实很好理解啦，继承就是要在类声明时显式 extends，而组合不用，组合可以简单的理解为在一个对象（类）中用到了另外一个对象（类）。</li>
<li>一般优先考虑组合，因为java里不允许多重继承。</li>
</ul>
<p>哈哈哈，我又有问题了，为什么 java 不支持多重继承呢？</p>
<p>我觉得主要是有一种情况很容易造成二义性，就是 A 是最顶层的，然后 B 和 C 继承了 A ，同时复写了 A 的 一个方法，如果 D 此时多重继承 B 和 C，那调用同样的方法的时候就会产生二义性了…</p>
</blockquote>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gckksagpb7j30ne0moaf0.jpg" alt="image-20200306222704205"></p>
<p><strong>双亲委派模型的工作过程：</strong> 如果一个类加载器收到了类加载的请求，先把这个请求委派给父类加载器去完成（所以所有的加载请求最终都应该传送到顶层的启动类加载器中），只有当父加载器反馈自己无法完成加载请求(它的搜索范围没有找到所需要的类)时，子加载器才会尝试自己去加载。</p>
<p>使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是<strong>java类随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。</p>
<p>注意：双亲委派模型是 Java 设计者们推荐给开发者们的一种类加载器实现方式，并不是一个强制性 的约束模型。在 Java 的世界中大部分的类加载器都遵循这个模型，但也有例外。</p>
<h3 id="4-4-破坏双亲委派模型"><a href="#4-4-破坏双亲委派模型" class="headerlink" title="4.4 破坏双亲委派模型"></a>4.4 破坏双亲委派模型</h3><p>三次大破坏。</p>
<p><strong>第一次破坏</strong>是因为类加载器和抽象类java.lang.ClassLoader在JDK1.0就存在的，而双亲委派模型在JDK1.2之后才被引入，为了兼容已经存在的用户自定义类加载器，引入双亲委派模型时做了一定的妥协：在java.lang.ClassLoader中引入了一个findClass()方法，在此之前，用户去继承java.lang.Classloader的唯一目的就是重写loadClass()方法。JDK1.2之后不提倡用户去覆盖loadClass()方法，而是<strong><em>把自己的类加载逻辑写到findClass()方法中</em></strong>，如果loadClass()方法中如果父类加载失败，则会调用自己的findClass()方法来完成加载，这样就<strong>可以保证新写出来的类加载器是符合双亲委派模型规则的</strong>。</p>
<p><strong>第二次破坏</strong>是因为模型自身的缺陷，现实中存在这样的场景：基础的类加载器需要求调用用户的代码，而基础的类加载器可能不认识用户的代码。为此，Java设计团队引入的设计是 “线程上下文类加载器（Thread Context ClassLoader）”。这样可以通过父类加载器请求子类加载器去完成类加载动作。已经违背了双亲委派模型的一般性原则。</p>
<p><strong>第三次破坏</strong> 是由于用户对<strong>程序动态性的追求</strong>导致的。这里所说的动态性是指：“代码热替换”、“模块热部署”等等比较热门的词。说白了就是希望应用程序能够像我们的计算机外设一样，接上鼠标、U盘不用重启机器就能立即使用。OSGi是当前业界“事实上”的Java模块化标准，OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现。每一个程序模块（OSGi中称为Bundle）都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。<strong>在OSGi环境下，类加载器不再是双亲委派模型中的树状结构，而是进一步发展为更加复杂的网状结构。</strong></p>
<p>「好叭，这一块我不太懂…」</p>
<h1 id="第八章-虚拟机字节码执行引擎"><a href="#第八章-虚拟机字节码执行引擎" class="headerlink" title="第八章 虚拟机字节码执行引擎"></a>第八章 虚拟机字节码执行引擎</h1><p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcl4cx2bmgj31bk0q6aeh.jpg" alt="img"></p>
<h2 id="1-概述-1"><a href="#1-概述-1" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>执行引擎是虚拟机中最核心的组成部分之一，“虚拟机”可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p>
<p>在 Java 虚拟机规范中，置顶了虚拟机字节码执行引擎的概念模型，这个概念模型成为了各个虚拟机执行引擎的统一外观，但是内部实现各不相同，有的是通过解释器解释执行，有的则是通过即时编译器(JIT)执行，但从外观上看，都是<strong>输入字节码文件，输出执行结果。</strong></p>
<h2 id="2-运行时栈帧"><a href="#2-运行时栈帧" class="headerlink" title="2. 运行时栈帧"></a>2. 运行时栈帧</h2><p>栈帧（Stack Frame）是用于支持虚拟机进行 <strong>方法调用和方法执行</strong> 的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素，每一个栈帧都包含了 局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。栈帧的大小早就写入到了 class 文件中的 code 属性中了，并且对于执行引擎来说，只有栈顶的栈帧才是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法。</p>
<h3 id="2-1-局部变量表"><a href="#2-1-局部变量表" class="headerlink" title="2.1 局部变量表"></a>2.1 局部变量表</h3><p>局部变量表是一组变量值存储空间，<strong>用于存放方法参数和方法内定义的局部变量。</strong> 当然，局部变量表的大小早在 Code 属性的 max_locals 数据项中就定义了。</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcldmwegn7j30uc0u0anj.jpg" alt="image-20200307150512463"></p>
<p>局部变量表以 变量槽（Slot） 为最小单位，默认一个 Slot 为32位，如果是64位的数据结构会为其分配连续两个 Slot 空间。</p>
<p>对于局部变量表，有三点需要提醒：</p>
<ol>
<li>方法执行时，虚拟机使用局部变量表完成<strong>从操作栈栈顶的参数值到参数变量列表的传递过程</strong>，如果是实例方法则第一个参数默认是对象实例的引用，也就是this，剩下的参数从 1 开始；</li>
<li>Slot 是可以重用的；</li>
<li>局部变量并没有像类变量一样存在“准备阶段”(类加载的连接过程的第二步)，所以如果要使用局部变量肯定要先赋初值。</li>
</ol>
<h3 id="2-2-操作数栈"><a href="#2-2-操作数栈" class="headerlink" title="2.2 操作数栈"></a>2.2 操作数栈</h3><p>操作数栈，也被称为操作栈，同局部变量表一样，容量也是在 Code 属性的 max_stacks 数据项之中早就写入了，同样的，栈中的基本单位也是 Slot(32位)，32位数据类型占栈容量为 1，64 位的占 2 ，方法的执行过程，就是入栈出栈的过程，所以，Java 虚拟机的解释执行引擎称为 “基于栈的执行引擎”。</p>
<p>另外，在概念模型中，两个栈帧作为虚拟机栈的元素，相互之间是完全独立的，但是在大多数虚拟机中会做出优化—— 令两个栈帧出现一部分重叠，这样在进行方法调用的时候就可以共用一部分数据，无需进行额外的参数复制传递了。</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcle1chnjmj314y0u0wkx.jpg" alt="image-20200307151906523"></p>
<h3 id="2-3-动态连接"><a href="#2-3-动态连接" class="headerlink" title="2.3 动态连接"></a>2.3 动态连接</h3><p>动态连接就是用来存储部分未转化为直接引用的符号引用，将其转化为直接引用。在之前的类加载过程中的解析部分我们谈到过，Class 文件的常量池存储了大量的符号引用，因为 java 不像 C++ 一样在编译之前有连接的过程，所以 java 在中间穿插了连接过程，第一次将符号引用转化为直接引用是在<strong>类加载中的解析</strong>，这种转化称为静态解析，第二次则是在每一次的运行期间转化为直接引用，称为 动态连接。</p>
<p>至于哪些符号引用是静态解析完成，哪些是动态连接，会在接下来的方法调用一节中谈到。</p>
<h3 id="2-4-方法返回地址"><a href="#2-4-方法返回地址" class="headerlink" title="2.4 方法返回地址"></a>2.4 方法返回地址</h3><p>存储的就是 <strong>用来帮助恢复上层方法的执行状态</strong> 的一些信息，如果方法是正常退出的，那么一般会存储调用者（上层方法）的 PC 计数值，来作为返回地址。而方法异常退出的话，返回地址一般就是通过异常处理器表来确定了，这个时候，方法返回地址这一块一般不会保存任何信息。</p>
<p>这里提到了两种退出方式：</p>
<ol>
<li>正常完成出口（Normal Method Invocation Completion，话说翻译不应该是正常的完成方法调用？？？）。此时退出方法的操作应该是：恢复上层方法的局部变量表和操作数栈，如果有返回值就压入调用者的栈帧中的操作数栈中，然后调整PC计数值。</li>
<li>异常完成出口（Abrupt Method Invocation Completion，我觉得翻译成异常的方法调用会更好…）。此时退出方法的操作应该和上者一样，当然了，这里肯定是不会有返回值的。</li>
</ol>
<h3 id="2-5-附加信息"><a href="#2-5-附加信息" class="headerlink" title="2.5 附加信息"></a>2.5 附加信息</h3><p>可以增加例如调试相关的信息，一般在实际开发中，会把 动态连接、方法返回地址和附加信息归为一类，称之为栈帧信息。</p>
<h2 id="3-方法调用"><a href="#3-方法调用" class="headerlink" title="3. 方法调用"></a>3. 方法调用</h2><p>方法调用的唯一任务就是把该方法调用的方法确定，暂时不涉及到方法内部的具体运行过程，为什么这个要单独拎出来讲呢？因为在程序运行过程中，进行方法调用时最普遍、最频繁的操作，并且由于动态连接的原因，所以方法调用还是挺复杂的…</p>
<h3 id="3-1-解析"><a href="#3-1-解析" class="headerlink" title="3.1 解析"></a>3.1 解析</h3><p>之前在类加载过程中已经见过一次 解析 了，没错，这两个解析是一个意思。之前没具体讲的原因是，这里又要讲一遍…</p>
<p>在类加载的解析阶段，会将其中的一部分符号引用转换为直接引用，这部分要具备下面这个条件：<strong>方法在程序运行之前就有一个可确定的调用模板，并且这个方法的调用版本在运行期间是不可以改变的，也就是说必须在javac编译时就需要确定下来，符合“编译期可知，运行期不可变的要求”。</strong>这类方法调用就称之为解析。</p>
<p>符合这个要求的有：</p>
<ol>
<li>静态方法，与类型直接相关，不会被重写；</li>
<li>private修饰的方法，不会被外部访问而导致重写；</li>
<li>实例化构造器\<init>方法，也同样符合“编译期可知，运行期不可变”，不会被重写；</init></li>
<li>父类方法。这个地方是难点，可能理解上会有点歧义，这里讲的是指在重写的方法中调用 super.方法名()，在这里调用父类的这个方法，可以确保不会被重写，是固定的调用了这个方法。如下例所示：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JVM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"aaaaaa"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">B</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"bbbbbb"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JVM;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">SuperClass</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">A</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.A();  <span class="comment">// invokespecial</span></span><br><span class="line">        System.out.println(<span class="number">2222</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        test_heap_outOfMemory t = <span class="keyword">new</span> test_heap_outOfMemory();</span><br><span class="line">        t.C();</span><br><span class="line">        SubClass subClass = <span class="keyword">new</span> SubClass();</span><br><span class="line">        subClass.A();	<span class="comment">// invokevirtual,因为可能被重写</span></span><br><span class="line">       <span class="comment">// subClass.B() 也是 invokevirtual，因为也可能被重写</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class version 52.0 (52)</span></span><br><span class="line"><span class="comment">// access flags 0x21</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM</span>/<span class="title">SubClass</span> <span class="keyword">extends</span> <span class="title">JVM</span>/<span class="title">SuperClass</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// compiled from: SubClass.java</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="keyword">public</span> &lt;init&gt;()V</span><br><span class="line">   L0</span><br><span class="line">    LINENUMBER <span class="number">3</span> L0</span><br><span class="line">    ALOAD <span class="number">0</span></span><br><span class="line">    INVOKESPECIAL JVM/SuperClass.&lt;init&gt; ()V</span><br><span class="line">    RETURN</span><br><span class="line">   L1</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LJVM/SubClass; L0 L1 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">1</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x1</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 6 L0</span></span><br><span class="line"><span class="function">    ALOAD 0</span></span><br><span class="line"><span class="function">    INVOKESPECIAL JVM/SuperClass.<span class="title">A</span> <span class="params">()</span>V</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LINENUMBER 7 L1</span></span><br><span class="line"><span class="function">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;</span><br><span class="line">    SIPUSH <span class="number">2222</span></span><br><span class="line">    INVOKEVIRTUAL java/io/PrintStream.println (I)V</span><br><span class="line">   L2</span><br><span class="line">    LINENUMBER <span class="number">8</span> L2</span><br><span class="line">    RETURN</span><br><span class="line">   L3</span><br><span class="line">    LOCALVARIABLE <span class="keyword">this</span> LJVM/SubClass; L0 L3 <span class="number">0</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// access flags 0x9</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">main</span><span class="params">([Ljava/lang/String;)</span>V</span></span><br><span class="line"><span class="function">   L0</span></span><br><span class="line"><span class="function">    LINENUMBER 11 L0</span></span><br><span class="line"><span class="function">    NEW JVM/test_heap_outOfMemory</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL JVM/test_heap_outOfMemory.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 1</span></span><br><span class="line"><span class="function">   L1</span></span><br><span class="line"><span class="function">    LINENUMBER 12 L1</span></span><br><span class="line"><span class="function">    ALOAD 1</span></span><br><span class="line"><span class="function">    INVOKEVIRTUAL JVM/test_heap_outOfMemory.<span class="title">C</span> <span class="params">()</span>V</span></span><br><span class="line"><span class="function">   L2</span></span><br><span class="line"><span class="function">    LINENUMBER 13 L2</span></span><br><span class="line"><span class="function">    NEW JVM/SubClass</span></span><br><span class="line"><span class="function">    DUP</span></span><br><span class="line"><span class="function">    INVOKESPECIAL JVM/SubClass.&lt;init&gt; <span class="params">()</span>V</span></span><br><span class="line"><span class="function">    ASTORE 2</span></span><br><span class="line"><span class="function">   L3</span></span><br><span class="line"><span class="function">    LINENUMBER 14 L3</span></span><br><span class="line"><span class="function">    ALOAD 2</span></span><br><span class="line"><span class="function">    INVOKEVIRTUAL JVM/SubClass.<span class="title">A</span> <span class="params">()</span>V</span></span><br><span class="line"><span class="function">   L4</span></span><br><span class="line"><span class="function">    LINENUMBER 17 L4</span></span><br><span class="line"><span class="function">    RETURN</span></span><br><span class="line"><span class="function">   L5</span></span><br><span class="line"><span class="function">    LOCALVARIABLE args [Ljava/lang/String</span>; L0 L5 <span class="number">0</span></span><br><span class="line">    LOCALVARIABLE t LJVM/test_heap_outOfMemory; L1 L5 <span class="number">1</span></span><br><span class="line">    LOCALVARIABLE subClass LJVM/SubClass; L3 L5 <span class="number">2</span></span><br><span class="line">    MAXSTACK = <span class="number">2</span></span><br><span class="line">    MAXLOCALS = <span class="number">3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如上例所示，谈到的 invokespecial、invokestatic 就是解析阶段调用的指令，具体的调用字节码指令如下：</p>
<ol>
<li><p><strong>invokestatic：调用静态方法；</strong></p>
</li>
<li><p><strong>invokespecial：调用实例构造器方法 \<init>、私有方法、父类方法；</init></strong></p>
</li>
<li><p>invokevirtual：调用所有的虚方法；</p>
</li>
<li><p>invokeinterface：调用接口方法，会在运行时确认一个实现此接口的对象；</p>
</li>
<li><p>invokedynamic：JDK1.7新加入的一个虚拟机指令，相比于之前的四条指令，他们的分派逻辑都是固化在JVM内部，而 invokedynamic 则用于处理新的方法分派：它允许应用级别的代码来确定执行哪一个方法调用，只有在调用要执行的时候，才会进行这种判断,从而达到动态语言的支持。(Invoke dynamic method)</p>
</li>
</ol>
<p>只要被 invokestatic、invokespecial调用的方法都是可以在解析阶段确定唯一的调用版本的，所以他们在类加载的时候就会把符号引用转换为对该方法的直接引用，这四类方法（静态方法、实例构造器方法、私有方法、父类方法）统称为非虚方法「<strong>当然其实非虚方法，还有一类，那就是用 final 修饰的方法</strong>」，其他方法统称为虚方法（final 修饰的方法除外）。其实 final 修饰的方法，也是在编译期间就可以确定的，但是它比较特殊，并不是用的上述两个指令完成调用，而是使用了 invokevirtual…</p>
<p>至于为什么，我觉得这位朋友说的挺好的的：</p>
<blockquote>
<p>作者：RednaxelaFX<br>链接：<a href="https://www.zhihu.com/question/45131640/answer/98820081" target="_blank" rel="noopener">https://www.zhihu.com/question/45131640/answer/98820081</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
<p>Q：为什么java中调用final方法是用invokevirtual指令而不是invokespecial?</p>
<p>A：</p>
<p>不知道当时高司令和团队成员实际是出于什么原因这样设计的。这里我只能做些推断。</p>
<p>被final修饰的non-private方法，确实跟private方法一样可以静态判定调用目标。我们说这两种方法都可以被statically resolved。</p>
<p>它们最大的一个差别是：</p>
<ul>
<li>一个private方法是只可能在一个类里声明并定义的，它不可能覆写（override）任何基类的方法。</li>
<li>而一个final non-private方法则可以覆写基类的虚方法，并且可以被基类引用通过invokevirtual调用到。</li>
</ul>
<p>前者很明显，举例说明一下后者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">&gt;   <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Base"</span>); &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="class"><span class="keyword">class</span> <span class="title">Derived</span> <span class="keyword">extends</span> <span class="title">Base</span> </span>&#123;</span><br><span class="line">&gt;   <span class="meta">@Override</span></span><br><span class="line">&gt;   <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">"Derived"</span>); &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">&gt;   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">&gt;     Derived d = <span class="keyword">new</span> Derived();</span><br><span class="line">&gt;     d.foo();    <span class="comment">// (1) 题主的问题是为什么这个情况下仍然用invokevirtual</span></span><br><span class="line">&gt;     Base b = d; <span class="comment">// (2) Base类型引用指向Derived类型实例</span></span><br><span class="line">&gt;     b.foo();    <span class="comment">//     通过invokevirtual调用到final Derived.foo()</span></span><br><span class="line">&gt;   &#125;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<p><strong>所以，原始设计者或许是出于一致性的考虑，选择让这些final方法也用invokevirtual来调用，而不是用invokespecial。另外正如评论区所说，这一致性也带来了更好的二进制兼容性——如果上例中Test与Derived分离编译，在Test编译时Derived.foo()是final，而后来Derived去掉了foo()的final并且单独重新编译了的话，已编译的Test代码仍然可以正确执行——甚至如果Derived进一步有子类覆写了foo()也没问题。</strong></p>
<p>二进制兼容性（binary compatibility）和分离编译（separate compilation）可是Java的卖点，然而同时也是毒瘤…（叹气</p>
<p><strong>关于性能</strong></p>
<p>事实上此处在Class文件里使用invokevirtual来实现对final方法的调用并不会影响一个实现得好的JVM的性能。<br>HotSpot VM会对上述(1)的情况在解释器里可以把invokevirtual改写为一个行为跟invokespecial相似的内部字节码指令，叫做fast_invokevfinal，不需要查vtable就可以调用到目标方法（不过目前在x86上HotSpot并没有使用这个优化）。SPARC上的例子看这里：<a href="https://link.zhihu.com/?target=http%3A//hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/d109bda16490/src/cpu/sparc/vm/templateTable_sparc.cpp%23l3024" target="_blank" rel="noopener">jdk8u/jdk8u/hotspot: d109bda16490 src/cpu/sparc/vm/templateTable_sparc.cpp</a><br>而在JIT编译器里这种invokevirtual也会被看作跟invokespecial一样来处理。一个简单的例子可以看C1这里：<a href="https://link.zhihu.com/?target=http%3A//hg.openjdk.java.net/jdk8u/jdk8u/hotspot/file/d109bda16490/src/share/vm/c1/c1_GraphBuilder.cpp%23l1826" target="_blank" rel="noopener">jdk8u/jdk8u/hotspot: d109bda16490 src/share/vm/c1/c1_GraphBuilder.cpp</a></p>
</blockquote>
<p>静态解析的方法调用称为解析调用，还有一种调用方式，称为 分派调用（Dispatch）</p>
<h3 id="3-2-分派调用"><a href="#3-2-分派调用" class="headerlink" title="3.2 分派调用"></a>3.2 分派调用</h3><p>即将要讲的分派调用，其实<strong>囊括了解析调用的步骤</strong>，<strong>解析与分派并不是排他互斥的关系，而是不同层次上筛选和确定目标方法的过程，二者是联合起来一起使用的</strong>，这里的分派更多的是揭示多态性的特征。「好叭，这一块其实我是有点不赞同的，我觉得就是有点互斥的感觉啊，一个是用在非虚函数，一个用在了虚函数。」</p>
<h4 id="3-2-1-静态分派-—-重载"><a href="#3-2-1-静态分派-—-重载" class="headerlink" title="3.2.1 静态分派 — 重载"></a>3.2.1 静态分派 — 重载</h4><p>也就是我们常说的多态中的重载过程。<strong>虚拟机（准确的说是编译期）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。</strong>并且由于静态类型在编译期间就可知，所以在编译期间，javac 编译期就根据参数的静态类型决定了使用哪个重载版本。</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作，就称为静态分派，最典型的就是方法重载，因此确定静态分派的动作实际上并不是由jvm来完成的。另外，编译期虽然能够确定出方法的重载版本，但是在很多情况下这个重载版本并不是“唯一的”，往往只能去确定一个“更加合适的”版本，甚至有的时候会因为类型不明确，选择过多（实现的接口很多），而导致报错。</p>
<p>当然，这里得明确一下静态类型和实际类型的概念。</p>
<blockquote>
<p>Human human = new Man()</p>
<p>固定对象.方法(human)</p>
</blockquote>
<ol>
<li>静态类型：变量 human 的静态类型为 Human</li>
<li>动态类型：变量 human 的动态类型为 Man</li>
</ol>
<font color="red">简单记忆，重载就是同一个类下同名方法参数不同，所以决定权在参数，如果参数个数相同，那决定权就是参数的类型，而参数的类型在编译期间就已经确定了，是由其静态类型决定的。</font>

<h4 id="3-2-2-动态分派-—-重写"><a href="#3-2-2-动态分派-—-重写" class="headerlink" title="3.2.2 动态分派 — 重写"></a>3.2.2 动态分派 — 重写</h4><p>重写跟重载很不一样，重写是类对接口或父类方法的重写，这个时候对象都不一样了，所以会用到实际类型。</p>
<blockquote>
<p>People human = new Human();</p>
<p>human.方法()</p>
</blockquote>
<font color="red">简单记忆，重写就是一个类覆盖了接口或者父类的方法，此时的变量是一个对象，不是上文的参数，所以此时肯定就是由动态类型决定了。</font>



<h4 id="3-2-3-单分派和多分派"><a href="#3-2-3-单分派和多分派" class="headerlink" title="3.2.3 单分派和多分派"></a>3.2.3 单分派和多分派</h4><p>宗量：方法的接收者与方法的参数统称为方法的宗量。</p>
<p>静态分派是多分派类型，动态分派是单分派类型…「好绕啊…不太懂…」</p>
<p>总而言之，静态多分派、动态单分派。。。。</p>
<h4 id="3-2-4-动态单分派的实现优化"><a href="#3-2-4-动态单分派的实现优化" class="headerlink" title="3.2.4 动态单分派的实现优化"></a>3.2.4 动态单分派的实现优化</h4><p>由于动态单分派是非常频繁的动作，所以基于性能的考虑，以空间换时间，最常用的“稳定优化”手段就是在方法区中建立一个 <strong><em>虚方法表</em></strong>。如果子类重写了父类方法，则两者对象的方法的入口地址不一样，如果子类没有重写，则都指向父类的方法的入口地址。</p>
<p>除了建立虚方法表，还会使用 <strong>“内联缓存”</strong> 和 <strong>基于 “类型继承关系分析” 技术的守护内联</strong>两种非稳定的优化方式。</p>
<h2 id="4-基于栈的字节码解释执行引擎"><a href="#4-基于栈的字节码解释执行引擎" class="headerlink" title="4. 基于栈的字节码解释执行引擎"></a>4. 基于栈的字节码解释执行引擎</h2><p>上一节讲完了如何调用方法，这一节讲如何执行方法内的字节码指令。执行方法内的字节码指令有两种方法：通过解释器解释执行 和 通过 JIT 等即时编译器编译执行，下面讲一下第一种：基于栈的字节码解释执行。</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gclsekqvuzj319c0rqk8l.jpg" alt="image-20200307233611564"></p>
<p>Java 编译器输出的指令流，基本上就是一种基于栈的指令集架构，指令流里面的指令大部分都是零地址指令，因为都依赖操作数栈进行工作。而主流的基于寄存器的指令集一般都是二地址指令集。</p>
<p>基于栈的指令集最大优点就是可移植性，编译器实现更简单、代码更紧凑…但是缺点就是慢,而且要频繁的入栈出栈，意味着频繁访问内存，速度就下来了，虽然可以采用栈顶缓存，但是毕竟治根不治本…</p>
<h1 id="第九章-类加载及执行子系统的案例与实战"><a href="#第九章-类加载及执行子系统的案例与实战" class="headerlink" title="第九章 类加载及执行子系统的案例与实战"></a>第九章 类加载及执行子系统的案例与实战</h1><p>在 Class 文件格式和执行引擎操作这部分里，基本都是有虚拟机直接控制，用户程序无法对其进行改变。能通过程序进行操作的，主要是<strong>字节码生成</strong>与<strong>类加载器</strong>这两部分的功能。</p>
<ul>
<li>类加载器的增强</li>
</ul>
<p>主要是 Tomcat服务器的类加载器 和 OSGi 这个灵活的类加载器架构</p>
<ul>
<li>字节码生成技术与动态代理的实现</li>
</ul>
<p>包括 javac、AOP、动态代理、反射等都用到了字节码生成技术。</p>
<h1 id="第十章-早期（编译期）优化"><a href="#第十章-早期（编译期）优化" class="headerlink" title="第十章 早期（编译期）优化"></a>第十章 早期（编译期）优化</h1><h2 id="1-概述-2"><a href="#1-概述-2" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>编译期，在 java 里分为三类，</p>
<ul>
<li>一类是从 <em>.java 文件 转变为 </em>.class 文件的过程，这是前端编译的过程，我们之前提到的编译器都是指这个。使用到的前端编译器一般就是 javac。</li>
<li>还有指虚拟机的后端运行期编译，把字节码转变成机器码的过程。使用到的后端运行期编译器有 JIT编译器（Just In Time Compiler）。</li>
<li>还有一类很少见，称为静态提前编译器（AOT编译器，Ahead Of Time Compiler）直接把 *.java 文件编译成本地机器代码的过程。</li>
</ul>
<p>对于 Javac 编译器来说，对代码的运行效率没有优化措施，但是对程序员的编码风格和编码效率做了很多优化，对于 JIT 来说，对程序优化做了很多优化。</p>
<h2 id="2-Javac-编译器"><a href="#2-Javac-编译器" class="headerlink" title="2. Javac 编译器"></a>2. Javac 编译器</h2><h3 id="2-1-编译过程"><a href="#2-1-编译过程" class="headerlink" title="2.1 编译过程"></a>2.1 编译过程</h3><p>编译过程分为三个过程：</p>
<ol>
<li><strong>解析与填充符号表</strong>的过程；</li>
<li>插入式注解处理器的<strong>注解处理</strong>过程；</li>
<li><strong>语义分析与字节码生成</strong>过程。</li>
</ol>
<h3 id="2-2-解析与填充符号表"><a href="#2-2-解析与填充符号表" class="headerlink" title="2.2 解析与填充符号表"></a>2.2 解析与填充符号表</h3><h4 id="解析步骤"><a href="#解析步骤" class="headerlink" title="解析步骤"></a>解析步骤</h4><ul>
<li>由 parseFiles() 方法完成，包括了词法分析、语法分析；</li>
<li>词法分析就是将源代码的字符流转变为标记（Token）集合，词法分析过程由 com.sun.tools.javac.parser.Scanner 类实现；</li>
<li>语法分析就是根据 Token 序列来构造抽象语法树的过程，抽象语法树（AST，Abstract Syntax Tree）是一种用来描述程序代码语法结构的树形表示方法。</li>
</ul>
<h4 id="填充符号表"><a href="#填充符号表" class="headerlink" title="填充符号表"></a>填充符号表</h4><p>符号表（Symbol Table）是一组由符号地址和符号信息构成的表格，类似于键值对形式。</p>
<p>符号表中所登记的信息在编译的不同阶段都要用到。在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，当对符号表进行地址分配时，符号表是地址分配的依据。由 com.sun.tools.javac.comp.Enter 类实现。</p>
<h3 id="2-3-注解处理器"><a href="#2-3-注解处理器" class="headerlink" title="2.3 注解处理器"></a>2.3 注解处理器</h3><p>类似于编译器的插件。插入式注解处理器的初始过程是在 initPorcessAnnotations() 方法中完成的，而执行过程是在 processAnnotations() 方法中完成的。</p>
<h3 id="2-4-语义分析与字节码生成"><a href="#2-4-语义分析与字节码生成" class="headerlink" title="2.4 语义分析与字节码生成"></a>2.4 语义分析与字节码生成</h3><p>语法分析之后，编译器获得了程序代码的抽象语法树，语法树能表示一个结构正确的源程序的抽象，但是却无法保证源程序是符合逻辑的。而语义分析的主要任务就是对结构上正确的源程序进行上下文有关性质的审查。</p>
<ol>
<li><p>语义分析的具体步骤如下：</p>
<ul>
<li>标记检查：检查诸如变量使用前是否已经被声明、变量与赋值之间的数据类型能够匹配等等；</li>
<li>数据及控制流分析：四队上下文逻辑更进一步的验证，可以监察处诸如程序局部变量在使用前是否有赋值、方法的每条路径是否都有返回值、是否所有的受查异常都被正确处理了等问题。</li>
</ul>
</li>
<li><p>解语法糖：语法糖，也称糖衣语法，指的是在计算机语言中添加的某种语法，这种语法对语言的功能并没有影响，但是会更方便程序员使用。通常来说语法糖能够增加程序的可读性，减少程序出错的机会。由 desugar() 方法触发。</p>
</li>
<li>字节码生成，这是编译过程的最后一个阶段，把前面各个步骤生成的信息（语法树、符号表）转换成字节码写到磁盘去，还进行了少量的代码添加和转换工作，例如之前一直没有解决的 类构造器 \<clinit>  还要 实例构造器 \<init>方法「这里的实例构造器不是默认的构造器」就是在这个阶段被添加到语法树之中去的。</init></clinit></li>
</ol>
<h2 id="3-Java-语法糖的味道"><a href="#3-Java-语法糖的味道" class="headerlink" title="3. Java 语法糖的味道"></a>3. Java 语法糖的味道</h2><h3 id="3-1-泛型"><a href="#3-1-泛型" class="headerlink" title="3.1 泛型"></a>3.1 泛型</h3><p>本质是参数化类型，也就是说所操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口、方法的创建中，分为泛型类、泛型接口、泛型方法。</p>
<p>java 里面的泛型是伪泛型，并不是像 C++ 一样真正的泛型，Java 里面的泛型实现方式称为 类型擦除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;Integer&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Integer 的泛型"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(List&lt;String&gt; list)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"String 的泛型"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样的写法在 idea 中并不能通过，会提示两个方法一样，无法重载，原因就是在编译时就会将两者的泛型擦除。</p>
<h3 id="3-2-自动装箱、拆箱、遍历循环"><a href="#3-2-自动装箱、拆箱、遍历循环" class="headerlink" title="3.2 自动装箱、拆箱、遍历循环"></a>3.2 自动装箱、拆箱、遍历循环</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱、拆箱、遍历循环</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 自动装箱、拆箱、遍历循环的语法糖</span></span><br><span class="line">        List&lt;Integer&gt; list1 = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 或者写成 List&lt;Integer&gt; list = [1,2,3,4];</span></span><br><span class="line">        <span class="keyword">int</span> sum1 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : list1)&#123;</span><br><span class="line">            sum1 = sum1 + i;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 编译之后的原样</span></span><br><span class="line">        List list2 = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</span><br><span class="line">                Integer.valueOf(<span class="number">1</span>),</span><br><span class="line">                Integer.valueOf(<span class="number">2</span>),</span><br><span class="line">                Integer.valueOf(<span class="number">3</span>),</span><br><span class="line">                Integer.valueOf(<span class="number">4</span>),</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">int</span> sum2 = <span class="number">0</span>;</span><br><span class="line">        Iterator localIterator = list2.iterator();</span><br><span class="line">        <span class="keyword">while</span>(localIterator.hasNext())&#123;</span><br><span class="line">            sum2 = sum2 + ((Integer) localIterator.next()).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sum2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自动装箱的陷阱</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;</span><br><span class="line">        Integer b = <span class="number">2</span>;</span><br><span class="line">        Integer c = <span class="number">3</span>;</span><br><span class="line">        Integer d = <span class="number">3</span>;</span><br><span class="line">        Integer e = <span class="number">321</span>;</span><br><span class="line">        Integer f = <span class="number">321</span>;</span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == d); <span class="comment">// true</span></span><br><span class="line">        System.out.println(e == f); <span class="comment">// false</span></span><br><span class="line">        System.out.println(c == (a + b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(c.equals(a + b)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">//        System.out.println(g == d); // 报错，因为 == 不会自动拆箱，只有遇到了算术运算才会拆箱</span></span><br><span class="line">        System.out.println(g == (a + b)); <span class="comment">// true</span></span><br><span class="line">        System.out.println(g.equals(a + b)); <span class="comment">// false，虽然 equals()会自动拆箱，但是不会处理数据转型的问题</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Tip: Integer 的缓存问题，之前刷 LeetCode 就已经遇到过了。这里再提及一次！</p>
<p>具体的 Integer 和 int 的区别见 “零碎知识点” 这篇文章！</p>
</blockquote>
<h1 id="第十一章-晚期（运行期）优化"><a href="#第十一章-晚期（运行期）优化" class="headerlink" title="第十一章 晚期（运行期）优化"></a>第十一章 晚期（运行期）优化</h1><h2 id="1-概述-3"><a href="#1-概述-3" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>即时编译器（Just In Time Compiler），也称为 JIT 编译器，它的主要工作是把热点代码编译成与本地平台相关的机器码，并进行各种层次的优化，从而提高代码执行的效率。它并不是必需的。</p>
<p>那么什么是热点代码呢？我们知道虚拟机通过解释器（Interpreter）来执行字节码文件，当虚拟机发现某个方法或代码块的运行特别频繁时，就会把这些代码认定为“热点代码”（Hot Spot Code）。</p>
<p>即时编译器编译性能的好坏、代码优化程度的高低是衡量一款商用虚拟机优秀与否的关键指标之一，它也是虚拟机最核心且最能体现技术水平的部分。</p>
<h2 id="2-HotSpot虚拟机内的即时编译器"><a href="#2-HotSpot虚拟机内的即时编译器" class="headerlink" title="2. HotSpot虚拟机内的即时编译器"></a>2. HotSpot虚拟机内的即时编译器</h2><h3 id="2-1-解释器与编译器"><a href="#2-1-解释器与编译器" class="headerlink" title="2.1 解释器与编译器"></a>2.1 解释器与编译器</h3><p>HotSpot 虚拟机包含解释器和编译器。它们是怎么搭配工作的呢？当程序启动的时候，解释器首先发挥作用，它能直接运行字节码文件；随着时间的推移，越来越多的热点代码被编译器编译成机器码，从而获取更高的执行效率。同时，解释器还可以作为编译器激进优化时的一个“逃生门”，当编译器的激进优化手段不成立时，如加载了新类后类型继承结构出现变化等，可以通过<strong>逆优化（Deoptimization）</strong>退回到解释状态继续由解释器执行。解释器与编译器的交互如图所示：</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmkb1kva4j30t40dwq6o.jpg" alt="image-20200308154137313"></p>
<p>HotSpot中的编译器又分为两种，C1 编译器（Client Compiler）和 C2 编译器（Server Compiler），HotSpot 虚拟机会选择哪个编译器是由虚拟机运行于 Client 模式还是 Server 模式决定的。</p>
<p>默认情况下，虚拟机采用解释器和一种编译器搭配的方式工作，但是在分层编译策略下，C1 编译器和 C2 编译器将会同时工作，分层编译根据编译器编译、优化的规模和耗时，划分出不同的编译层次：</p>
<ul>
<li>第0层：程序解释执行，解释器不开启性能监控功能，触发 C1 编译。</li>
<li>第1层：C1 编译，将字节码编译成本地代码，进行简单、可靠的优化，如有必要解释器将开始性能监控。</li>
<li>第2层：C2 编译，将字节码编译成本地代码，启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</li>
</ul>
<p><strong>tips：</strong></p>
<ol>
<li>使用 “-client” 强制虚拟机运行于 Client 模式。</li>
<li>使用 “-server” 强制虚拟机运行于 Server 模式。</li>
<li>使用 “-Xint” 强制虚拟机只使用解释器执行程序，编译器不工作。</li>
<li>使用 “-Xcomp” 强制虚拟机只使用编译器执行程序，解释器作为编译器的“逃生门”。</li>
<li>使用 “-XX:+TieredCompilation” 开启分层编译。虚拟机 Server 模式下默认开启。</li>
</ol>
<h3 id="2-2-编译对象与触发条件"><a href="#2-2-编译对象与触发条件" class="headerlink" title="2.2 编译对象与触发条件"></a>2.2 编译对象与触发条件</h3><p>“热点代码” 分为两类：</p>
<ol>
<li>被多次调用的方法；「普通的编译请求」「方法调用计数器」</li>
<li>被多次执行的循环体。「OSR编译请求」「回边计数器」</li>
</ol>
<p>要测试其成为“热点代码”，有两种比较主流的热点探测方式：</p>
<ol>
<li>基于采样的热点探测，周期性探测各个线程栈顶，虽然简单高效，但是容易受到线程阻塞的影响而扰乱探测；</li>
<li>基于计数器的热点探测，为每个方法（甚至是代码块）建立计数器，统计执行次数，如果执行次数达到一定的阈值，就把这部分代码编译成机器码。</li>
</ol>
<p>HotSpot 采用的是基于计数器的热点探测，为每个方法准备了两个计数器：<font color="red">方法调用计数器（Invocation Counter）和 回边计数器（Back Edge Counter）</font>。</p>
<p>在默认设置下，方法计数器统计的并不是方法被调用的绝对次数，而是一定时间内的执行次数，超过了时间如果还没有达到阈值，就会将方法计数器的值减去一半，这个过程称为 方法计数器的 <strong>热度衰减（Counter Decay）</strong>，而这段时间就称为此方法统计的<strong>半衰周期（Counter Half Life Time）</strong>，进行热度衰减的动作实在虚拟机进行垃圾收集顺带进行的。而回边计数器适用于统计方法中循环体代码的执行次数，之所以叫“回边”，可以理解为一个循环体结束一次又回到开头（死空循环不算回边），显然建立回边计数器统计的目的是为了触发OSR（On Stack Replacement，栈上替换）编译。回边计数器没有计数热度衰减的过程，统计的就是方法体内循环体执行的绝对次数。</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmkqj6r62j30u010wtix.jpg" alt="image-20200308155619886"></p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmkqt9x0nj30u014n7ez.jpg" alt="image-20200308155641033"></p>
<h2 id="3-优化技术"><a href="#3-优化技术" class="headerlink" title="3. 优化技术"></a>3. 优化技术</h2><h3 id="3-1-方法内联"><a href="#3-1-方法内联" class="headerlink" title="3.1 方法内联"></a>3.1 方法内联</h3><p>方法内联的重要性要优于其他优化措施，它的主要目的有两个，一是去除方法调用的成本，二是为其他优化建立良好的基础。</p>
<p>方法内联的行为很简单，就是把目标方法的代码“复制”到发起调用的方法之中，避免发生真实的方法调用而已。在分派调用中讲过。</p>
<h3 id="3-2-公共子表达式消除"><a href="#3-2-公共子表达式消除" class="headerlink" title="3.2 公共子表达式消除"></a>3.2 公共子表达式消除</h3><p>如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成为了公共子表达式。对于这种表达式，没有必要花时间再对它进行计算，只需要直接用前面计算过的表达式结果代替 E 就可以了。我们来举个例子来模拟下它的优化过程：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> b = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> d = (c * b) * <span class="number">12</span> + a + (a + b * c);</span><br><span class="line">    <span class="comment">// 1. 提取公共子表达式</span></span><br><span class="line">    <span class="keyword">int</span> E = c * b;</span><br><span class="line">    d = E * <span class="number">12</span> + a + (a + E);</span><br><span class="line">    <span class="comment">// 2. 代数化简</span></span><br><span class="line">    d = E * <span class="number">13</span> + a * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-3-数组边界检查消除"><a href="#3-3-数组边界检查消除" class="headerlink" title="3.3 数组边界检查消除"></a>3.3 数组边界检查消除</h3><p>当我们尝试对数组越界访问的时候，Java 会向我们抛一个 java.lang.ArrayIndexOutOfBoundsException，这对软件开发者来说是一件很好的事情，即使没有专门编写防御代码，也可以避免大部分的溢出攻击，但是对虚拟机来说，意味着每一次的数组访问都带有一次隐含的条件判定操作，即数组边界检查，那么有没有办法消除这种检查呢？</p>
<p>虚拟机一般是在即时编译期间通过数据流分析来确定是否可以消除这种检查，比如 foo[3] 的访问，只有在编译的时候确定 3 不会超过 foo.length - 1 的值，就可以判断该次数组访问没有越界，就可以把数组边界检查消除。</p>
<h3 id="3-4-逃逸分析"><a href="#3-4-逃逸分析" class="headerlink" title="3.4 逃逸分析"></a>3.4 逃逸分析</h3><p>逃逸分析的基本行为就是分析对象动态作用域：当一个对象在方法被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他方法中，称为方法逃逸；甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>如果能证明一个对象不会逃逸到方法或者线程之外，则可以为这个变量进行一些高效的优化：</p>
<h4 id="1-栈上分配"><a href="#1-栈上分配" class="headerlink" title="1) 栈上分配"></a>1) 栈上分配</h4><p>如果确定一个对象不会逃逸出方法之外，假如能使用栈上分配这个对象，那大量的对象就会随着方法的结束而自动销毁了，垃圾收集系统的压力将会小很多。然而遗憾的是，目前的 HotSpot 虚拟机还没有实现这项优化。</p>
<h4 id="2）同步消除"><a href="#2）同步消除" class="headerlink" title="2）同步消除"></a>2）同步消除</h4><p>如果确定一个对象不会被其他线程访问到，那么这个变量就不存在线程间的争抢，对这个变量实施的同步措施也可以消除掉。</p>
<h4 id="3）标量替换"><a href="#3）标量替换" class="headerlink" title="3）标量替换"></a>3）标量替换</h4><p>标量：无法被进一步分解的数据，比如原始数据类型（int、long以及 reference 类型）<br>聚合量：可以被持续分解的数据，典型的就是 Java 中对象，它们还可以被分解成成员变量等。</p>
<p>标量替换指的是如果把一个 Java 对象拆散分解，根据程序访问的情况，将其使用到的成员变量恢复到原始类型来访问。</p>
<p>如果能确定一个对象不会被外部访问，并且这个对象可以被拆散的话，那程序真正执行的时候就可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来代替。</p>
<p><strong>tips：</strong></p>
<ol>
<li>-XX:+DoEscapeAnalysis 手动开启/关闭逃逸分析，默认开启，C2 编译器有效</li>
<li>-XX:+PrintEscapeAnalysis 查看逃逸分析的结果（debug 虚拟机支持）</li>
<li>-XX:+EliminateAllocations 手动开启/关闭标量替换，默认开启</li>
<li>-XX:+PrintEliminateAllocations 查看标量替换情况（debug 虚拟机支持）</li>
<li>-XX:+EliminateLocks 手动开启/关闭同步消除，默认开启</li>
</ol>
<h1 id="第十二章-Java内存模型与线程"><a href="#第十二章-Java内存模型与线程" class="headerlink" title="第十二章 Java内存模型与线程"></a>第十二章 Java内存模型与线程</h1><h2 id="1-硬件的效率与一致性"><a href="#1-硬件的效率与一致性" class="headerlink" title="1. 硬件的效率与一致性"></a>1. 硬件的效率与一致性</h2><p>虚拟机与物理计算机的并发有一些相似之处。</p>
<h3 id="1-1-缓存一致性协议"><a href="#1-1-缓存一致性协议" class="headerlink" title="1.1 缓存一致性协议"></a>1.1 缓存一致性协议</h3><p>为了解决多个处理器的运算任务可能涉及到同一块主内存，而他们的缓存数据又不一致的问题，引入了缓存一致性协议，volatile 就是用到了 MESI 这个缓存一致性协议。</p>
<h3 id="1-2-指令重排序优化"><a href="#1-2-指令重排序优化" class="headerlink" title="1.2 指令重排序优化"></a>1.2 指令重排序优化</h3><p>为了保证处理器利用率最大化，处理器会对指令重排序，而 jvm 中的 JIT 编译器 也同样如此，有类似的指令重排序优化，在 volatile 中为了保证 happens-before 是插入 内存屏障 防止 指令重排序的。</p>
<h2 id="2-Java-内存模型"><a href="#2-Java-内存模型" class="headerlink" title="2. Java 内存模型"></a>2. Java 内存模型</h2><p><strong>java 虚拟机规范中试图定义一种 Java 内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的并发效果。</strong></p>
<h3 id="2-1-主内存和工作内存"><a href="#2-1-主内存和工作内存" class="headerlink" title="2.1 主内存和工作内存"></a>2.1 主内存和工作内存</h3><p>Java 内存模型规定所有的共享变量都应该存储在主内存中，每条线程有自己的工作内存，工作内存中保存了线程独有的变量，线程之间是隔离的，值传递必须通过主内存操作。</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmldpbr9gj311a0h6454.jpg" alt="image-20200308161846493"></p>
<h3 id="2-2-内存间的交互操作"><a href="#2-2-内存间的交互操作" class="headerlink" title="2.2 内存间的交互操作"></a>2.2 内存间的交互操作</h3><p>关于主内存和工作内存如何交互，JMM 定义了8种原子操作：</p>
<ol>
<li>lock：作用于主内存的变量，将变量标识为线程独占的状态。类似独占锁。</li>
<li>unlock：作用于主内存的变量，将变量的锁释放。</li>
<li>read：作用于主内存变量，将变量从主内存读到工作内存中。</li>
<li>load：作用于工作内存变量，read操作完后需要load来复制一份变量副本放到工作内存中。</li>
<li>use：作用于工作内存变量，把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量值的字节码指令时就会执行这个操作。</li>
<li>assign：作用于工作内存变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令就执行这个操作。</li>
<li>store：作用于工作内存的变量，把一个工作内存中的变量传送到主内存中，以便随后的 write 使用。</li>
<li>write：作用于主内存的变量，把 store 操作得到的变量写入到主内存中的变量。</li>
</ol>
<h3 id="2-3-对于-volatile-型变量的特殊规则"><a href="#2-3-对于-volatile-型变量的特殊规则" class="headerlink" title="2.3 对于 volatile 型变量的特殊规则"></a>2.3 对于 volatile 型变量的特殊规则</h3><p>Volatile 只具有可见性和有序性，并不能保证原子性。</p>
<p>在以下两条规则的运算场景下，volatile 才具有原子性：</p>
<ol>
<li>运算结果不依赖于变量的当前值，或者能够确保只有单一的线程修改变量的值；</li>
<li>变量不需要与其他的状态变量共同参与不变约束。</li>
</ol>
<p><strong>可见性，是指一条线程修改了当前变量的值，其他线程能立即感知到这个新值。而普通变量必须通过主内存变量传递来完成。</strong></p>
<p><strong>有序性，是指禁止了指令重排序优化，普通变量仅仅保证在该方法的执行过程中所有依赖赋值的结果都能够得到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。volatile通过插入内存屏障，保证了有序性，但是这就带来了volatile的写操作会比较慢一些。</strong></p>
<p>有个典型的例子就是单例模式下的双重检验锁：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span> </span>&#123;&#125;   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>称其为双重检查锁，是因为会有两次检查 instance == null，一次是在同步块外，一次是在同步块内。为什么在同步块内还要再检验一次？因为可能会有多个线程一起进入同步块外的 if，如果在同步块内不进行二次检验的话就会生成多个实例了</p>
<p>而 instance = new Singleton() 这句，并非是一个原子操作，事实上在 JVM 中这句话做了下面 3 件事：</p>
<ol>
<li>给 instance 分配内存</li>
<li>调用 Singleton 的构造函数来初始化成员变量</li>
<li>将 instance 对象指向分配的内存空间（执行完这步 instance 就为非 null 了）</li>
</ol>
<p>但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错</p>
<p>所以需要将 instance 变量声明成 volatile。</p>
<h3 id="2-4-对于-long-和-double-型变量的特殊规则"><a href="#2-4-对于-long-和-double-型变量的特殊规则" class="headerlink" title="2.4 对于 long 和 double 型变量的特殊规则"></a>2.4 对于 long 和 double 型变量的特殊规则</h3><p>JMM 要求lock、unlock、read、load、use、assign、store、write 这 8 个操作具有原子性，但是对于 64 位的数据类型（long 和 double），有一条宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read、write 这四个操作的原子性，这点就是所谓的 long 和 double 的非原子性协定，所以可能多个线程共享一个未声明为 volatile 的 long 或者 double 变量时，读取到的值会很奇怪，<strong>不过现在基本所有商用的虚拟机都实现了 64 位数据的读写操作作为原子操作来对待。</strong></p>
<h3 id="2-5-原子性、可见性、有序性"><a href="#2-5-原子性、可见性、有序性" class="headerlink" title="2.5 原子性、可见性、有序性"></a>2.5 原子性、可见性、有序性</h3><p>JMM 的三个特征：原子性、可见性、有序性。</p>
<p>原子性：有 JMM 直接保证的原子性变量操作包括 read、load、use、assign、store、write，long 和 double 的非原子性协定例外…如果想要更大范围的原子性保证，有 lock 和 lock 保证，底层提供了 monitorenter、monitorexit 两个字节码指令保证具有原子性。</p>
<p>可见性：是指一条线程修改了当前变量的值，其他线程能立即感知到这个新值。而普通变量必须通过主内存变量传递来完成。除了 volatile，还可以实现可见性的关键字有 synchronized 和 final。</p>
<ul>
<li>volatile 实现可见性的原因就是遵循了 MESI 缓存一致性协议，可以保证变量修改完后立即同步到主内存，而其他的线程中的工作内存的变量值作废，需要从主内存再重新读取。</li>
<li>Synchronized 实现可见性的原因是 “对一个变量执行 unlock 操作之前，会确保先把该变量同步回主内存中（执行 store 和 write 指令）”。</li>
<li>final 实现可见性的原因是被 final 修饰好的字段在构造器中一旦被初始化完成，其他线程就能看见 final 字段的值，并且无法修改，所以就能保证可见性了。</li>
</ul>
<p>有序性：如果在本线程观察，所有的操作都是有序的；如果在一个线程中观察另外一个线程，所有的操作都是无序的。前半句是指“线程内表现为串行的语义”，后半句是指“指令重排序”和“工作内存与主内存同步延迟”现象，Java 提供了 volatile 和 synchronized 两个关键字保证线程的有序性。volatile 关键字本身就包含了禁止指令重排序的语义，而 synchronized 则是由“一个变量在同一时刻只允许一条线程对其进行加锁操作”这条规则获得的。</p>
<h3 id="2-6-先行发生（happens-before）原则"><a href="#2-6-先行发生（happens-before）原则" class="headerlink" title="2.6 先行发生（happens-before）原则"></a>2.6 先行发生（happens-before）原则</h3><p>happens-before 原则非常重要，它是判断是否存在竞争，线程是否安全的主要依据。指令重排序的前提是要遵守 happens-before 原则。</p>
<p>先行发生是 JMM 中定义的两项操作之间的偏序关系，如果说 A 先行发生于 B，其实就是说在操作 B 之前，操作 A 产生的影响能够被操作 B 观察到。「Tip：时间上的先后顺序和先行发生原则没有太大的关系，所以在衡量安全问题的时候需要以 happens-before 原则为准」</p>
<p>天然的 happens-before原则有：</p>
<ol>
<li>程序次序规则，一个线程内的代码自上而下运行；</li>
<li>管程锁定规则，unlock必须在lock之后，当然肯定操作的是同一个同步对象；</li>
<li>volatile变量规则，对一个 volatile 变量的写操作总是先行发生于后面对这个变量的读操作；</li>
<li>线程启动规则，任何线程的运作都必须在 start 之后；</li>
<li>线程终止规则，任何线程的结束都必须在该线程任何操作之后；</li>
<li>线程中断规则，interrupt() 调用之后才会有中断时间的发生；</li>
<li>对象终结规则，构造函数先于 finalize() 发生；</li>
<li>传递性， A 先于 B，B 先于 C，则 A 先于 C。</li>
</ol>
<h2 id="3-Java-与线程"><a href="#3-Java-与线程" class="headerlink" title="3. Java 与线程"></a>3. Java 与线程</h2><h3 id="3-1-线程的实现"><a href="#3-1-线程的实现" class="headerlink" title="3.1 线程的实现"></a>3.1 线程的实现</h3><p>实现线程主要有三种方式：</p>
<ol>
<li>使用内核线程实现；</li>
<li>使用用户线程实现；</li>
<li>使用用户线程加上轻量级进程混合实现。</li>
</ol>
<h4 id="3-1-1-使用内核线程实现"><a href="#3-1-1-使用内核线程实现" class="headerlink" title="3.1.1 使用内核线程实现"></a>3.1.1 使用内核线程实现</h4><p>内核线程（Kernel Thread，KLT）就是直接由操作系统内核支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器来对线程进行调度。而程序一般不会使用内核线程，会通过一个中间件—- 轻量级进程，来和内核线程1：1映射。</p>
<h4 id="3-1-2-使用用户线程实现"><a href="#3-1-2-使用用户线程实现" class="headerlink" title="3.1.2 使用用户线程实现"></a>3.1.2 使用用户线程实现</h4><p>用户线程就是系统内核感受不到的线程，所以用户的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。但是这个实现起来很困难，基本都放弃使用了。进程和内核线程 1：N。</p>
<h4 id="3-1-3-混合使用"><a href="#3-1-3-混合使用" class="headerlink" title="3.1.3 混合使用"></a>3.1.3 混合使用</h4><p>多对多的线程模型，轻量级进程和用户线程 M ：N。</p>
<h4 id="3-1-4-Java-线程的实现"><a href="#3-1-4-Java-线程的实现" class="headerlink" title="3.1.4 Java 线程的实现"></a>3.1.4 Java 线程的实现</h4><p>我们使用的 jdk 是采用的内核线程实现的，轻量级进程和内核线程1：1。</p>
<h3 id="3-2-Java-线程调度"><a href="#3-2-Java-线程调度" class="headerlink" title="3.2 Java 线程调度"></a>3.2 Java 线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要的调度方式有两种，分别是 协同式（Cooperative Threads-Scheduling）线程调度 和 抢占式（Preemptive Threads-Scheduling）线程调度。</p>
<p>Java 使用的当然是抢占式线程调度，因为协同式线程调度虽然实现简单但是线程执行时间不可控，如果线程编写有问题不通知系统进行系统切换那么程序就会一直堵塞。虽然说 Java 线程调度是系统自动完成的，但是我们可以设置线程优先级，优先级越高越容易被系统选择，不过其实线程优先级也不靠谱，因为 java 的线程是被映射到系统的原生线程上实现，所以最终的调度还是 os 说了算。</p>
<h3 id="3-3-状态转换"><a href="#3-3-状态转换" class="headerlink" title="3.3 状态转换"></a>3.3 状态转换</h3><p>Java 的线程有 5 种状态：</p>
<ol>
<li>新建（New）:创建后尚未启动的线程处于这种状态 ；</li>
<li>运行（Runnable）：包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待 cpu 分配时间片；</li>
<li>等待（Waiting）：处于这种状态的进程不会被分配 cpu 执行时间，它们要让线程显示的唤醒。以下方法会让线程进入到这个状态：<ul>
<li>Object.wait()  「可设置时间」</li>
<li>Thread.join()   「可设置时间」</li>
<li>LockSupport.park()、LockSupport.parkNanos()、LockSupport.parkUntil()</li>
</ul>
</li>
<li>阻塞（Blocked）：与等待状态的区别是，“阻塞状态”在等待获取到一个排它锁，这个时间将在另外一个线程放弃这个锁的时候方式，而“等待状态”则是在等待一段时间，或者唤醒动作的发生。在 synchronized 的时候，线程进入同步区域，就会进入阻塞状态；</li>
<li>结束（Terminated）：已终止线程的线程状态，线程已经结束执行。</li>
</ol>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcms4wlbchj31980qan4d.jpg" alt="image-20200308201230299"></p>
<h1 id="第十三章-线程安全与锁优化"><a href="#第十三章-线程安全与锁优化" class="headerlink" title="第十三章 线程安全与锁优化"></a>第十三章 线程安全与锁优化</h1><h2 id="1-线程安全"><a href="#1-线程安全" class="headerlink" title="1. 线程安全"></a>1. 线程安全</h2><p>线程安全的定义：</p>
<p><strong>当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，（单次）调用这个对象的行为就能够获取到正确的结果，那么这个对象就是线程安全的。</strong></p>
<p>按照线程安全的“安全程度”，由强至弱来排序，可以将 Java 语言中各种操作共享的数据分为以下五类：不可变、绝对线程安全、相对线程安全、线程兼容和线程独立。</p>
<h3 id="1-1-不可变"><a href="#1-1-不可变" class="headerlink" title="1.1 不可变"></a>1.1 不可变</h3><p>即可看不可改的数据，final 修饰。</p>
<h3 id="1-2-绝对线程安全"><a href="#1-2-绝对线程安全" class="headerlink" title="1.2 绝对线程安全"></a>1.2 绝对线程安全</h3><p>集合中的 Vector、ConcurrentHashMap并非绝对的线程安全，因为如果不使用迭代器去删除元素的话，遍历的时候依然会出现问题。</p>
<h3 id="1-3-相对的线程安全"><a href="#1-3-相对的线程安全" class="headerlink" title="1.3 相对的线程安全"></a>1.3 相对的线程安全</h3><p>单次调用不需要额外的加同步措施，这就是相对的线程安全，类似于 HasTable、Vector、Collections 的 synchronizedCollection()等等。</p>
<h3 id="1-4-线程兼容"><a href="#1-4-线程兼容" class="headerlink" title="1.4 线程兼容"></a>1.4 线程兼容</h3><p>线程兼容是指对象本身不是线程安全的，但是可以通过调用端正确的使用同步手段来保证对象在并发环境中安全的使用，如 ArrayList、HashMap。</p>
<h3 id="1-5-线程对立"><a href="#1-5-线程对立" class="headerlink" title="1.5 线程对立"></a>1.5 线程对立</h3><p>线程对立是不管调用端是否采取了同步措施，都无法在多线程环境下并发使用的代码。这种代码就不要写了…比如 System.setIn()、System.setOut()。</p>
<h2 id="2-实现线程安全的方法"><a href="#2-实现线程安全的方法" class="headerlink" title="2. 实现线程安全的方法"></a>2. 实现线程安全的方法</h2><h3 id="2-1-互斥同步"><a href="#2-1-互斥同步" class="headerlink" title="2.1 互斥同步"></a>2.1 互斥同步</h3><p>最基本的手段有 synchronized、ReentrantLock。这里也提到了 ReentrantLock几个特性：</p>
<ol>
<li>有等待可中断，当持有锁长期不释放时，等待的线程可以选择放弃等待，改为处理其他事情；</li>
<li>有公平锁和非公平锁的选择；</li>
<li>可以绑定多个Condition，也就是可以有多个条件队列。</li>
</ol>
<h3 id="2-2-非阻塞同步"><a href="#2-2-非阻塞同步" class="headerlink" title="2.2 非阻塞同步"></a>2.2 非阻塞同步</h3><p>基于冲突检测的乐观并发策略，通俗的来说就是先进行操作，如果没问题就成功了，如果有其他线程争用数据，产生了冲突，就再进行其他措施，这种乐观的并发策略不需要将线程挂起，因此这种同步操作称为非阻塞同步。</p>
<h3 id="2-3-无同步方案"><a href="#2-3-无同步方案" class="headerlink" title="2.3 无同步方案"></a>2.3 无同步方案</h3><p>ThreadLocal   —- 见我的 多线程（四）—- ThreadLocal 一文</p>
<h2 id="3-锁优化"><a href="#3-锁优化" class="headerlink" title="3. 锁优化"></a>3. 锁优化</h2><ul>
<li>自旋锁和自适应自旋锁；</li>
<li>锁消除。可以不用用到锁的地方，可以不加锁；</li>
<li><p>锁粗化。如果有一系列操作反复的加锁和解锁，就会锁同步范围扩大；</p>
</li>
<li><p>轻量级锁。本意是在没有多线程竞争的前提下，比如两个线程交替执行，不会发生竞争，此时就可以使用轻量级锁。</p>
</li>
<li><p>偏向锁。可以提高带有同步但无竞争的程序性能，适合单线程。如果变量总是被多个线程访问，那么偏向模式是没有意义的并且会浪费开销和时间。</p>
</li>
</ul>
<p>要理解轻量级锁和偏向锁，就需要谈到虚拟机中对象的内存布局。虚拟机中的对象头由两部分组成，第一部分是<strong>用来存储对象自身的运行时数据</strong>，例如哈希码（HashCode）、GC 分代年龄（GC Age）等等，一般是64位，官方称之为 Mark Word，它是实现轻量级锁和偏向锁的关键，对象头除了 Mark Word，还有一部分是用来存储指向方法区对象类型数据的指针，如果是数组对象的话，还有额外的一部分用来存储数组长度。</p>
<p><img src="https://image.baidu.com/search/down?url=https://tva1.sinaimg.cn/large/00831rSTgy1gcmx1m1x0uj31780gk40b.jpg" alt="image-20200308230216870"></p>
<p>如图所示，是 32 位的虚拟机的 Mark Word。</p>
<p><strong>现在讲一下 synchronized 的锁升级过程：</strong></p>
<ol>
<li><strong>最开始的对象是无锁模式，Mark Word 的前 25 位记录对象的HashCode，锁标志位是01，是否偏向锁那一位是0。</strong></li>
<li><strong>当对象被当做同步锁并有一个线程A抢到了锁时，锁标志位还是01，但是否偏向锁那一位改成1，前23bit记录抢到锁的线程id，剩下的 2 位 是 epoch，代表偏向的时间戳，表示进入偏向锁状态。</strong></li>
<li><strong>当线程A再次试图来获得锁时，JVM发现同步锁对象的标志位是01，是否偏向锁是1，也就是偏向状态，Mark Word中记录的线程id就是线程A自己的id，表示线程A已经获得了这个偏向锁，可以执行同步锁的代码。</strong></li>
<li><strong>当线程B试图获得这个锁时，JVM发现同步锁处于偏向状态，但是Mark Word中的线程id记录的不是B，那么线程B会先用CAS操作试图获得锁，这里的获得锁操作是有可能成功的，因为线程A一般不会自动释放偏向锁。如果抢锁成功，就把Mark Word里的线程id改为线程B的id，代表线程B获得了这个偏向锁，可以执行同步锁代码。如果抢锁失败，则继续执行步骤5。</strong></li>
<li><strong>偏向锁状态抢锁失败，代表当前锁有一定的竞争，偏向锁将升级为轻量级锁。JVM会在当前线程的线程栈中开辟一块单独的空间，称之为 Lock Record，里面保存指向对象锁Mark Word的副本，同时在对象锁Mark Word中保存指向这片空间的指针。上述两个保存操作都是CAS操作，如果保存成功，代表线程抢到了同步锁，就把Mark Word中的锁标志位改成00，可以执行同步锁代码。如果保存失败，表示抢锁失败，竞争太激烈，继续执行步骤6。</strong></li>
<li><strong>轻量级锁抢锁失败，JVM会使用自旋锁，自旋锁不是一个锁状态，只是代表不断的重试，尝试抢锁。从JDK1.7开始，自旋锁默认启用，自旋次数由JVM决定。如果抢锁成功则执行同步锁代码，解轻量级锁锁也是用 CAS，将栈帧上的Lock Record替换回去，替换成刚就同步完成了。如果失败则继续执行步骤7。</strong></li>
<li><strong>自旋锁重试之后如果抢锁依然失败，同步锁会升级至重量级锁，锁标志位改为10。在这个状态下，未抢到锁的线程都会被阻塞。</strong></li>
</ol>
<blockquote>
<p><a href="https://blog.csdn.net/lkforce/article/details/81128115" target="_blank" rel="noopener">https://blog.csdn.net/lkforce/article/details/81128115</a></p>
</blockquote>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>至此，周志华先生的这本《深入理解 Java 虚拟机》第三版 就已经全部复习完一遍了，收获很多，大概满打满算花了 3 天「2020.03.05 ~ 2020.03.08」的时间啃完，接下来还得再好好看看，有些地方有点囫囵吞枣，比如说第六章的 Class 文件结构，并没有自己去利用 idea 中的 Jclasslib 认真去分析，还有很多地方虽然都是自己敲字敲出来的，但是敲出来了就给忘了…时间还是太仓促了…总而言之，继续加油吧！</p>

      
    </div>

    

    
    
    

    

    
      
    
    
      <div>
        <div id="reward-container">
  <div>Thank you for your accept. mua！</div>
  <button id="reward-button" disable="enable" onclick="var qr = document.getElementById(&quot;qr&quot;); qr.style.display = (qr.style.display === 'none') ? 'block' : 'none';">
    打赏
  </button>
  <div id="qr" style="display: none;">

    
      
      
        
      
      <div style="display: inline-block">
        <img src="https://i.loli.net/2020/04/21/W3tDf1V2sT5LoOi.png" alt="Jerome 微信支付">
        <p>微信支付</p>
      </div>
    
      
      
        
      
      <div style="display: inline-block">
        <img src="https://i.loli.net/2020/04/21/Od5DSGJ316toUkw.jpg" alt="Jerome 支付宝">
        <p>支付宝</p>
      </div>
    

  </div>
</div>

      </div>
    

    
      <div>
        




  



<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Jerome</li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    
    <a href="http://jeromememory.github.io/2019/12/04/深入理解java虚拟机笔记.html" title="jvm笔记">http://jeromememory.github.io/2019/12/04/深入理解java虚拟机笔记.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！</li>
</ul>

      </div>
    
    <div>
      
        <div>
    
        <div style="text-align:center;color: #ccc;font-size:16px;">-------------本文结束<i class="fa fa-heart"></i>感谢您的阅读-------------</div>
    
</div>
      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/jvm笔记/" rel="tag"><i class="fa fa-tag"></i> jvm笔记</a>
          
            <a href="/tags/oom/" rel="tag"><i class="fa fa-tag"></i> oom</a>
          
            <a href="/tags/垃圾回收/" rel="tag"><i class="fa fa-tag"></i> 垃圾回收</a>
          
            <a href="/tags/Class-文件组成/" rel="tag"><i class="fa fa-tag"></i> Class 文件组成</a>
          
            <a href="/tags/类加载/" rel="tag"><i class="fa fa-tag"></i> 类加载</a>
          
            <a href="/tags/字节码执行引擎/" rel="tag"><i class="fa fa-tag"></i> 字节码执行引擎</a>
          
            <a href="/tags/Java-内存模型/" rel="tag"><i class="fa fa-tag"></i> Java 内存模型</a>
          
            <a href="/tags/线程安全/" rel="tag"><i class="fa fa-tag"></i> 线程安全</a>
          
            <a href="/tags/锁/" rel="tag"><i class="fa fa-tag"></i> 锁</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/10/27/十大排序.html" rel="next" title="十大内部排序">
                <i class="fa fa-chevron-left"></i> 十大内部排序
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/12/09/动态规划笔记.html" rel="prev" title="动态规划笔记">
                动态规划笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  
    <div class="comments" id="comments">
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NjAyMS8yMjUzMg=="></div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="https://i.loli.net/2019/09/25/Dqk7oaQtwAHINWT.png" alt="Jerome">
            
              <p class="site-author-name" itemprop="name">Jerome</p>
              <div class="site-description motion-element" itemprop="description">生活总是充满了惊喜</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">61</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">21</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">134</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/jeromememory" title="GitHub &rarr; https://github.com/jeromememory" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="tencent://message/?uin=1337911608&Site=&menu=yes" title="QQ &rarr; tencent://message/?uin=1337911608&Site=&menu=yes" rel="noopener" target="_blank"><i class="fa fa-fw fa-qq"></i>QQ</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://stackoverflow.com/users/11879978/hysterical" title="StackOverflow &rarr; https://stackoverflow.com/users/11879978/hysterical" rel="noopener" target="_blank"><i class="fa fa-fw fa-stack-overflow"></i>StackOverflow</a>
                </span>
              
            </div>
          

          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-book"></i>
                推荐阅读
              </div>
              <ul class="links-of-blogroll-list">
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jeromememory.github.io/2020/03/15/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%20NIO.html" title="https://jeromememory.github.io/2020/03/15/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%20NIO.html">浅入浅出NIO</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jeromememory.github.io/2019/12/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0.html" title="https://jeromememory.github.io/2019/12/04/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0.html">jvm总结</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jeromememory.github.io/2019/10/12/leetcode%E7%83%AD%E9%A2%98100.html" title="https://jeromememory.github.io/2019/10/12/leetcode%E7%83%AD%E9%A2%98100.html">LeetCode总结</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jeromememory.github.io/2020/03/17/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C.html" title="https://jeromememory.github.io/2020/03/17/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E9%AA%8C.html">面经</a>
                  </li>
                
                  <li class="links-of-blogroll-item">
                    <a href="https://jeromememory.github.io/2020/01/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89----%20%E9%94%81%20&%20%E5%85%B3%E9%94%AE%E5%AD%97%20.html" title="https://jeromememory.github.io/2020/01/29/%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89----%20%E9%94%81%20&%20%E5%85%B3%E9%94%AE%E5%AD%97%20.html">多线程</a>
                  </li>
                
              </ul>
            </div>
          

          
            
          
          <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="110" src="//music.163.com/outchain/player?type=2&id=479598964&auto=0&height=90"></iframe>
        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第二章-Java内存区域与内存溢出异常"><span class="nav-number">1.</span> <span class="nav-text">第二章 Java内存区域与内存溢出异常</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-运行时数据区域"><span class="nav-number">1.1.</span> <span class="nav-text">1. 运行时数据区域</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-OutOfMemoryError异常"><span class="nav-number">1.2.</span> <span class="nav-text">2. OutOfMemoryError异常</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-补充：虚拟机部分参数"><span class="nav-number">1.3.</span> <span class="nav-text">3. 补充：虚拟机部分参数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第三章-垃圾收集器与内存分配策略"><span class="nav-number">2.</span> <span class="nav-text">第三章 垃圾收集器与内存分配策略</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第六章-类文件结构"><span class="nav-number">3.</span> <span class="nav-text">第六章 类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#编译过程"><span class="nav-number">3.1.</span> <span class="nav-text">编译过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Class-文件组成"><span class="nav-number">3.2.</span> <span class="nav-text">Class  文件组成</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#具体组成部分"><span class="nav-number">3.2.1.</span> <span class="nav-text">具体组成部分</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-魔数"><span class="nav-number">3.2.1.1.</span> <span class="nav-text">1. 魔数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Class文件的版本"><span class="nav-number">3.2.1.2.</span> <span class="nav-text">2. Class文件的版本</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-常量池"><span class="nav-number">3.2.1.3.</span> <span class="nav-text">3. 常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-访问标志"><span class="nav-number">3.2.1.4.</span> <span class="nav-text">4. 访问标志</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-类索引、-父类索引与接口索引集合"><span class="nav-number">3.2.1.5.</span> <span class="nav-text">5. 类索引、 父类索引与接口索引集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-字段表集合"><span class="nav-number">3.2.1.6.</span> <span class="nav-text">6. 字段表集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-方法表集合"><span class="nav-number">3.2.1.7.</span> <span class="nav-text">7. 方法表集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-属性表集合"><span class="nav-number">3.2.1.8.</span> <span class="nav-text">8. 属性表集合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Demo"><span class="nav-number">3.3.</span> <span class="nav-text">Demo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#源代码"><span class="nav-number">3.3.1.</span> <span class="nav-text">源代码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Byte-Code-viewer"><span class="nav-number">3.3.2.</span> <span class="nav-text">Byte Code viewer</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#jsclasslib"><span class="nav-number">3.3.3.</span> <span class="nav-text">jsclasslib</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-虚拟机类加载机制"><span class="nav-number">4.</span> <span class="nav-text">第七章 虚拟机类加载机制</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-概述"><span class="nav-number">4.1.</span> <span class="nav-text">1. 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-虚拟机类加载机制的概念"><span class="nav-number">4.1.1.</span> <span class="nav-text">1.1 虚拟机类加载机制的概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-Java语言的动态加载和动态连接"><span class="nav-number">4.1.2.</span> <span class="nav-text">1.2  Java语言的动态加载和动态连接</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-类加载时机"><span class="nav-number">4.2.</span> <span class="nav-text">2. 类加载时机</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-类加载过程"><span class="nav-number">4.3.</span> <span class="nav-text">3. 类加载过程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-加载"><span class="nav-number">4.3.1.</span> <span class="nav-text">3.1 加载</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-验证"><span class="nav-number">4.3.2.</span> <span class="nav-text">3.2 验证</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-准备"><span class="nav-number">4.3.3.</span> <span class="nav-text">3.3 准备</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-解析"><span class="nav-number">4.3.4.</span> <span class="nav-text">3.4 解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-1-看两者的概念"><span class="nav-number">4.3.4.1.</span> <span class="nav-text">3.4.1 看两者的概念</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-2-对解析结果进行缓存"><span class="nav-number">4.3.4.2.</span> <span class="nav-text">3.4.2 对解析结果进行缓存</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-3-解析动作的目标"><span class="nav-number">4.3.4.3.</span> <span class="nav-text">3.4.3 解析动作的目标</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-初始化"><span class="nav-number">4.3.5.</span> <span class="nav-text">3.5 初始化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-类加载器"><span class="nav-number">4.4.</span> <span class="nav-text">4. 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-类与类加载器"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.1 类与类加载器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-类加载器介绍"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.2 类加载器介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-双亲委派模型"><span class="nav-number">4.4.3.</span> <span class="nav-text">4.3 双亲委派模型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-破坏双亲委派模型"><span class="nav-number">4.4.4.</span> <span class="nav-text">4.4 破坏双亲委派模型</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第八章-虚拟机字节码执行引擎"><span class="nav-number">5.</span> <span class="nav-text">第八章 虚拟机字节码执行引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-概述-1"><span class="nav-number">5.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-运行时栈帧"><span class="nav-number">5.2.</span> <span class="nav-text">2. 运行时栈帧</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-局部变量表"><span class="nav-number">5.2.1.</span> <span class="nav-text">2.1 局部变量表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-操作数栈"><span class="nav-number">5.2.2.</span> <span class="nav-text">2.2 操作数栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-动态连接"><span class="nav-number">5.2.3.</span> <span class="nav-text">2.3 动态连接</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-方法返回地址"><span class="nav-number">5.2.4.</span> <span class="nav-text">2.4 方法返回地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-附加信息"><span class="nav-number">5.2.5.</span> <span class="nav-text">2.5 附加信息</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-方法调用"><span class="nav-number">5.3.</span> <span class="nav-text">3. 方法调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-解析"><span class="nav-number">5.3.1.</span> <span class="nav-text">3.1 解析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-分派调用"><span class="nav-number">5.3.2.</span> <span class="nav-text">3.2 分派调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-1-静态分派-—-重载"><span class="nav-number">5.3.2.1.</span> <span class="nav-text">3.2.1 静态分派 — 重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-2-动态分派-—-重写"><span class="nav-number">5.3.2.2.</span> <span class="nav-text">3.2.2 动态分派 — 重写</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-3-单分派和多分派"><span class="nav-number">5.3.2.3.</span> <span class="nav-text">3.2.3 单分派和多分派</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-4-动态单分派的实现优化"><span class="nav-number">5.3.2.4.</span> <span class="nav-text">3.2.4 动态单分派的实现优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-基于栈的字节码解释执行引擎"><span class="nav-number">5.4.</span> <span class="nav-text">4. 基于栈的字节码解释执行引擎</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第九章-类加载及执行子系统的案例与实战"><span class="nav-number">6.</span> <span class="nav-text">第九章 类加载及执行子系统的案例与实战</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十章-早期（编译期）优化"><span class="nav-number">7.</span> <span class="nav-text">第十章 早期（编译期）优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-概述-2"><span class="nav-number">7.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Javac-编译器"><span class="nav-number">7.2.</span> <span class="nav-text">2. Javac 编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-编译过程"><span class="nav-number">7.2.1.</span> <span class="nav-text">2.1 编译过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-解析与填充符号表"><span class="nav-number">7.2.2.</span> <span class="nav-text">2.2 解析与填充符号表</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#解析步骤"><span class="nav-number">7.2.2.1.</span> <span class="nav-text">解析步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#填充符号表"><span class="nav-number">7.2.2.2.</span> <span class="nav-text">填充符号表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-注解处理器"><span class="nav-number">7.2.3.</span> <span class="nav-text">2.3 注解处理器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-语义分析与字节码生成"><span class="nav-number">7.2.4.</span> <span class="nav-text">2.4 语义分析与字节码生成</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Java-语法糖的味道"><span class="nav-number">7.3.</span> <span class="nav-text">3. Java 语法糖的味道</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-泛型"><span class="nav-number">7.3.1.</span> <span class="nav-text">3.1 泛型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-自动装箱、拆箱、遍历循环"><span class="nav-number">7.3.2.</span> <span class="nav-text">3.2 自动装箱、拆箱、遍历循环</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十一章-晚期（运行期）优化"><span class="nav-number">8.</span> <span class="nav-text">第十一章 晚期（运行期）优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-概述-3"><span class="nav-number">8.1.</span> <span class="nav-text">1. 概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-HotSpot虚拟机内的即时编译器"><span class="nav-number">8.2.</span> <span class="nav-text">2. HotSpot虚拟机内的即时编译器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-解释器与编译器"><span class="nav-number">8.2.1.</span> <span class="nav-text">2.1 解释器与编译器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-编译对象与触发条件"><span class="nav-number">8.2.2.</span> <span class="nav-text">2.2 编译对象与触发条件</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-优化技术"><span class="nav-number">8.3.</span> <span class="nav-text">3. 优化技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-方法内联"><span class="nav-number">8.3.1.</span> <span class="nav-text">3.1 方法内联</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-公共子表达式消除"><span class="nav-number">8.3.2.</span> <span class="nav-text">3.2 公共子表达式消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-数组边界检查消除"><span class="nav-number">8.3.3.</span> <span class="nav-text">3.3 数组边界检查消除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-逃逸分析"><span class="nav-number">8.3.4.</span> <span class="nav-text">3.4 逃逸分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-栈上分配"><span class="nav-number">8.3.4.1.</span> <span class="nav-text">1) 栈上分配</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2）同步消除"><span class="nav-number">8.3.4.2.</span> <span class="nav-text">2）同步消除</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3）标量替换"><span class="nav-number">8.3.4.3.</span> <span class="nav-text">3）标量替换</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十二章-Java内存模型与线程"><span class="nav-number">9.</span> <span class="nav-text">第十二章 Java内存模型与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-硬件的效率与一致性"><span class="nav-number">9.1.</span> <span class="nav-text">1. 硬件的效率与一致性</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-缓存一致性协议"><span class="nav-number">9.1.1.</span> <span class="nav-text">1.1 缓存一致性协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-指令重排序优化"><span class="nav-number">9.1.2.</span> <span class="nav-text">1.2 指令重排序优化</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Java-内存模型"><span class="nav-number">9.2.</span> <span class="nav-text">2. Java 内存模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-主内存和工作内存"><span class="nav-number">9.2.1.</span> <span class="nav-text">2.1 主内存和工作内存</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-内存间的交互操作"><span class="nav-number">9.2.2.</span> <span class="nav-text">2.2 内存间的交互操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-对于-volatile-型变量的特殊规则"><span class="nav-number">9.2.3.</span> <span class="nav-text">2.3 对于 volatile 型变量的特殊规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-对于-long-和-double-型变量的特殊规则"><span class="nav-number">9.2.4.</span> <span class="nav-text">2.4 对于 long 和 double 型变量的特殊规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-原子性、可见性、有序性"><span class="nav-number">9.2.5.</span> <span class="nav-text">2.5 原子性、可见性、有序性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-先行发生（happens-before）原则"><span class="nav-number">9.2.6.</span> <span class="nav-text">2.6 先行发生（happens-before）原则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-Java-与线程"><span class="nav-number">9.3.</span> <span class="nav-text">3. Java 与线程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-线程的实现"><span class="nav-number">9.3.1.</span> <span class="nav-text">3.1 线程的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-1-使用内核线程实现"><span class="nav-number">9.3.1.1.</span> <span class="nav-text">3.1.1 使用内核线程实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-2-使用用户线程实现"><span class="nav-number">9.3.1.2.</span> <span class="nav-text">3.1.2 使用用户线程实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-3-混合使用"><span class="nav-number">9.3.1.3.</span> <span class="nav-text">3.1.3 混合使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-4-Java-线程的实现"><span class="nav-number">9.3.1.4.</span> <span class="nav-text">3.1.4 Java 线程的实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Java-线程调度"><span class="nav-number">9.3.2.</span> <span class="nav-text">3.2 Java 线程调度</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-状态转换"><span class="nav-number">9.3.3.</span> <span class="nav-text">3.3 状态转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第十三章-线程安全与锁优化"><span class="nav-number">10.</span> <span class="nav-text">第十三章 线程安全与锁优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-线程安全"><span class="nav-number">10.1.</span> <span class="nav-text">1. 线程安全</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-不可变"><span class="nav-number">10.1.1.</span> <span class="nav-text">1.1 不可变</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-绝对线程安全"><span class="nav-number">10.1.2.</span> <span class="nav-text">1.2 绝对线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-相对的线程安全"><span class="nav-number">10.1.3.</span> <span class="nav-text">1.3 相对的线程安全</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-线程兼容"><span class="nav-number">10.1.4.</span> <span class="nav-text">1.4 线程兼容</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-线程对立"><span class="nav-number">10.1.5.</span> <span class="nav-text">1.5 线程对立</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-实现线程安全的方法"><span class="nav-number">10.2.</span> <span class="nav-text">2. 实现线程安全的方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-互斥同步"><span class="nav-number">10.2.1.</span> <span class="nav-text">2.1 互斥同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-非阻塞同步"><span class="nav-number">10.2.2.</span> <span class="nav-text">2.2 非阻塞同步</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-无同步方案"><span class="nav-number">10.2.3.</span> <span class="nav-text">2.3 无同步方案</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-锁优化"><span class="nav-number">10.3.</span> <span class="nav-text">3. 锁优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#总结"><span class="nav-number">11.</span> <span class="nav-text">总结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" style=" text-align:center;">&copy; 2019 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jerome</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"> 站点字数合计:</i>
    </span>
    
    <span title="站点总字数">1.2m</span>
  
  
</div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>







<div class="run_time" style=" text-align:center;">
  <span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
  <script>
    var now = new Date(); 
    function createtime() { 
        var grt= new Date("08/06/2019 19:00:00");//此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime()+250); 
        days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); 
        hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); 
        if(String(hnum).length ==1 ){hnum = "0" + hnum;} minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); 
        mnum = Math.floor(minutes); if(String(mnum).length ==1 ){mnum = "0" + mnum;} 
        seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); 
        snum = Math.round(seconds); if(String(snum).length ==1 ){snum = "0" + snum;} 
        document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; 
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; 
    } 
    setInterval("createtime()",250);
  </script>
</div>
        
<div class="busuanzi-count" style=" text-align:center;">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="post-meta-item-icon">
      <i class="fa fa-user"></i>
    </span>
    <span class="site-uv" title="总访客量">
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span> 人
    </span>
  

  
    <span class="post-meta-divider">|</span>
  

  
    <span class="post-meta-item-icon">
      <i class="fa fa-eye"></i>
    </span>
    <span class="site-pv" title="总访问量">
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span> 次
    </span>
  
</div>










        
      </div>
    </footer>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>





  



  






  















  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script src="/lib/fancybox/source/jquery.fancybox.pack.js"></script>


  


  <script src="/js/utils.js?v=7.1.1"></script>

  <script src="/js/motion.js?v=7.1.1"></script>



  
  


  <script src="/js/schemes/muse.js?v=7.1.1"></script>




  
  <script src="/js/scrollspy.js?v=7.1.1"></script>
<script src="/js/post-details.js?v=7.1.1"></script>



  


  <script src="/js/next-boot.js?v=7.1.1"></script>


  

  

  
  
  

  

  
  
  


  


  
    <script>
  window.livereOptions = {
    refer: '2019/12/04/深入理解java虚拟机笔记.html'
  };
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];
    if (typeof LivereTower === 'function') { return; }
    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;
    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>

  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  
  
  
  <script src="/lib/bookmark/bookmark.min.js?v=1.0"></script>
  <script>
  
    bookmark.scrollToMark('auto', "#更多");
  
  </script>


  

  

  


  
<script type="text/javascript">
    //微信二维码点击背景关闭
    $('body').delegate('.-mob-share-weixin-qrcode-bg','click', function(){
         $(".-mob-share-weixin-qrcode-close").trigger("click");
    }); 
</script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":1,"width":250,"height":300,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>

<!-- 代码块复制功能 -->
<script type="text/javascript" src="/js/src/clipboard.min.js"></script>  
<script type="text/javascript" src="/js/src/clipboard-use.js"></script>