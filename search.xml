<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2020%2F01%2F04%2F%E9%80%92%E5%BD%92%E8%AF%A6%E8%A7%A3.html</url>
    <content type="text"><![CDATA[3道题彻底搞定：套路解决递归问题(转)前言转的哈~我自己学习看的！！ 原文链接 ——-&gt; 解决递归 相信不少同学和我一样，在刚学完数据结构后开始刷算法题时，遇到递归的问题总是很头疼，而一看解答，却发现大佬们几行递归代码就优雅的解决了问题。从我自己的学习经历来看，刚开始理解递归思路都很困难，更别说自己写了。 我一直觉得刷算法题和应试一样，既然是应试就一定有套路存在。在刷题中，我总结出了一套解决递归问题的模版思路与解法，用这个思路可以秒解很多递归问题。 递归解题三部曲何为递归？程序反复调用自身即是递归。 我自己在刚开始解决递归问题的时候，总是会去纠结这一层函数做了什么，它调用自身后的下一层函数又做了什么…然后就会觉得实现一个递归解法十分复杂，根本就无从下手。 相信很多初学者和我一样，这是一个思维误区，一定要走出来。既然递归是一个反复调用自身的过程，这就说明它每一级的功能都是一样的，因此我们只需要关注一级递归的解决过程即可。 我们需要关心的主要是以下三点： 整个递归的终止条件。 一级递归需要做什么？ 应该返回给上一级的返回值是什么？ 因此，也就有了我们解递归题的三部曲： 找整个递归的终止条件：递归应该在什么时候结束？ 找返回值：应该给上一级返回什么信息？ 本级递归应该做什么：在这一级递归中，应该完成什么任务？ 一定要理解这3步，这就是以后递归秒杀算法题的依据和思路。 但这么说好像很空，我们来以题目作为例子，看看怎么套这个模版，相信3道题下来，你就能慢慢理解这个模版。之后再解这种套路递归题都能直接秒了。 例1：求二叉树的最大深度先看一道简单的Leetcode题目： Leetcode 104. 二叉树的最大深度 题目很简单，求二叉树的最大深度，那么直接套递归解题三部曲模版： 找终止条件。 什么情况下递归结束？当然是树为空的时候，此时树的深度为0，递归就结束了。 找返回值。 应该返回什么？题目求的是树的最大深度，我们需要从每一级得到的信息自然是当前这一级对应的树的最大深度，因此我们的返回值应该是当前树的最大深度，这一步可以结合第三步来看。 本级递归应该做什么。 首先，还是强调要走出之前的思维误区，递归后我们眼里的树一定是这个样子的，看下图。此时就三个节点：root、root.left、root.right，其中根据第二步，root.left和root.right分别记录的是root的左右子树的最大深度。那么本级递归应该做什么就很明确了，自然就是在root的左右子树中选择较大的一个，再加上1就是以root为根的子树的最大深度了，然后再返回这个深度即可。 具体Java代码如下： 12345678910111213class Solution &#123; public int maxDepth(TreeNode root) &#123; //终止条件：当树为空时结束递归，并返回当前深度0 if(root == null)&#123; return 0; &#125; //root的左、右子树的最大深度 int leftDepth = maxDepth(root.left); int rightDepth = maxDepth(root.right); //返回的是左右子树的最大深度+1 return Math.max(leftDepth, rightDepth) + 1; &#125;&#125; 当足够熟练后，也可以和Leetcode评论区一样，很骚的几行代码搞定问题，让之后的新手看的一脸懵逼(这道题也是我第一次一行代码搞定一道Leetcode题)： 12345class Solution &#123; public int maxDepth(TreeNode root) &#123; return root == null ? 0 : Math.max(maxDepth(root.left), maxDepth(root.right)) + 1; &#125;&#125; 例2：两两交换链表中的节点看了一道递归套路解决二叉树的问题后，有点套路搞定递归的感觉了吗？我们再来看一道Leetcode中等难度的链表的问题，掌握套路后这种中等难度的问题真的就是秒：Leetcode 24. 两两交换链表中的节点 直接上三部曲模版： 找终止条件。 什么情况下递归终止？没得交换的时候，递归就终止了呗。因此当链表只剩一个节点或者没有节点的时候，自然递归就终止了。 找返回值。 我们希望向上一级递归返回什么信息？由于我们的目的是两两交换链表中相邻的节点，因此自然希望交换给上一级递归的是已经完成交换处理，即已经处理好的链表。 本级递归应该做什么。 结合第二步，看下图！由于只考虑本级递归，所以这个链表在我们眼里其实也就三个节点：head、head.next、已处理完的链表部分。而本级递归的任务也就是交换这3个节点中的前两个节点，就很easy了。 附上Java代码： 123456789101112131415class Solution &#123; public ListNode swapPairs(ListNode head) &#123; //终止条件：链表只剩一个节点或者没节点了，没得交换了。返回的是已经处理好的链表 if(head == null || head.next == null)&#123; return head; &#125; //一共三个节点:head, next, swapPairs(next.next) //下面的任务便是交换这3个节点中的前两个节点 ListNode next = head.next; head.next = swapPairs(next.next); next.next = head; //根据第二步：返回给上一级的是当前已经完成交换后，即处理好了的链表部分 return next; &#125;&#125; 例3：平衡二叉树相信经过以上2道题，你已经大概理解了这个模版的解题流程了。 那么请你先不看以下部分，尝试解决一下这道easy难度的Leetcode题（个人觉得此题比上面的medium难度要难）：Leetcode 110. 平衡二叉树 我觉得这个题真的是集合了模版的精髓所在，下面套三部曲模版： 找终止条件。 什么情况下递归应该终止？自然是子树为空的时候，空树自然是平衡二叉树了。 应该返回什么信息： 为什么我说这个题是集合了模版精髓？正是因为此题的返回值。要知道我们搞这么多花里胡哨的，都是为了能写出正确的递归函数，因此在解这个题的时候，我们就需要思考，我们到底希望返回什么值？ 何为平衡二叉树？平衡二叉树即左右两棵子树高度差不大于1的二叉树。而对于一颗树，它是一个平衡二叉树需要满足三个条件：它的左子树是平衡二叉树，它的右子树是平衡二叉树，它的左右子树的高度差不大于1。换句话说：如果它的左子树或右子树不是平衡二叉树，或者它的左右子树高度差大于1，那么它就不是平衡二叉树。 而在我们眼里，这颗二叉树就3个节点：root、left、right。那么我们应该返回什么呢？如果返回一个当前树是否是平衡二叉树的boolean类型的值，那么我只知道left和right这两棵树是否是平衡二叉树，无法得出left和right的高度差是否不大于1，自然也就无法得出root这棵树是否是平衡二叉树了。而如果我返回的是一个平衡二叉树的高度的int类型的值，那么我就只知道两棵树的高度，但无法知道这两棵树是不是平衡二叉树，自然也就没法判断root这棵树是不是平衡二叉树了。 因此，这里我们返回的信息应该是既包含子树的深度的int类型的值，又包含子树是否是平衡二叉树的boolean类型的值。可以单独定义一个ReturnNode类，如下： 123456789class ReturnNode&#123; boolean isB; int depth; //构造方法 public ReturnNode(boolean isB, int depth)&#123; this.isB = isB; this.depth = depth; &#125;&#125; 本级递归应该做什么。 知道了第二步的返回值后，这一步就很简单了。目前树有三个节点：root，left，right。我们首先判断left子树和right子树是否是平衡二叉树，如果不是则直接返回false。再判断两树高度差是否不大于1，如果大于1也直接返回false。否则说明以root为节点的子树是平衡二叉树，那么就返回true和它的高度。 具体的Java代码如下： 123456789101112131415161718192021222324252627282930313233343536class Solution &#123; //这个ReturnNode是参考我描述的递归套路的第二步：思考返回值是什么 //一棵树是BST等价于它的左、右俩子树都是BST且俩子树高度差不超过1 //因此我认为返回值应该包含当前树是否是BST和当前树的高度这两个信息 private class ReturnNode&#123; boolean isB; int depth; public ReturnNode(int depth, boolean isB)&#123; this.isB = isB; this.depth = depth; &#125; &#125; //主函数 public boolean isBalanced(TreeNode root) &#123; return isBST(root).isB; &#125; //参考递归套路的第三部：描述单次执行过程是什么样的 //这里的单次执行过程具体如下： //是否终止?-&gt;没终止的话，判断是否满足不平衡的三个条件-&gt;返回值 public ReturnNode isBST(TreeNode root)&#123; if(root == null)&#123; return new ReturnNode(0, true); &#125; //不平衡的情况有3种：左树不平衡、右树不平衡、左树和右树差的绝对值大于1 ReturnNode left = isBST(root.left); ReturnNode right = isBST(root.right); if(left.isB == false || right.isB == false)&#123; return new ReturnNode(0, false); &#125; if(Math.abs(left.depth - right.depth) &gt; 1)&#123; return new ReturnNode(0, false); &#125; //不满足上面3种情况，说明平衡了，树的深度为左右俩子树最大深度+1 return new ReturnNode(Math.max(left.depth, right.depth) + 1, true); &#125;&#125; 一些可以用这个套路解决的题暂时就写这么多啦，作为一个高考语文及格分，大学又学了工科的人，表述能力实在差因此啰啰嗦嗦写了一大堆，希望大家能理解这个很好用的套路。 下面我再列举几道我在刷题过程中遇到的也是用这个套路秒的题，真的太多了，大部分链表和树的递归题都能这么秒，因为树和链表天生就是适合递归的结构。 我会随时补充，正好大家可以看了上面三个题后可以拿这些题来练练手，看看自己是否能独立快速准确的写出递归解法了。 Leetcode 101. 对称二叉树 Leetcode 111. 二叉树的最小深度 Leetcode 226. 翻转二叉树：这个题的备注是最骚的。Mac OS下载神器homebrew的大佬作者去面试谷歌，没做出来这道算法题，然后被谷歌面试官怼了：”我们90％的工程师使用您编写的软件(Homebrew)，但是您却无法在面试时在白板上写出翻转二叉树这道题，这太糟糕了。” Leetcode 617. 合并二叉树 Leetcode 654. 最大二叉树 Leetcode 83. 删除排序链表中的重复元素 Leetcode 206. 翻转链表]]></content>
  </entry>
  <entry>
    <title><![CDATA[历年面经总结]]></title>
    <url>%2F2019%2F12%2F27%2F%E5%8E%86%E5%B9%B4%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[快手篇数据结构 说说B+树和B树的区别，优缺点等？ 经有一个查询好友的接口，设计一个微信朋友圈，可以实现发表朋友圈，添加评论，查看评论等功能。主要是设计数据结构 操作系统计算机网络 TCP三次握手四次挥手，四次挥手过程中服务端的哪几种状态，哪几种包 算法 算法题：无序数列中求第k大的数(维护最小堆，然后依次遍历，与堆顶比较 写一个选择排序或者插入排序 写一个生产者消费者 一个二维矩阵进行逆置操作，也就是行变列列变行。扩展一下，二维数组存在500g的文件中，怎么做才能完成上面算法的操作，我就说先按行拆分，最后再拼接。 java基础 HashMap的底层数据结构 HashMap哈希函数的认识，JDK1.8采用的hash函数 多线程 多线程JUC包下的一些常见的类，比如CountDownLatch、Semaphore等 锁的概念，锁相关的关键字，volatile，synchronized。还比较了ReentrantLock与synchronized。 线程池有哪些参数？分别有什么用？如果任务数超过的核心线程数，会发生什么？阻塞队列大小是多少？ 怎么实现一个线程安全的计数器？ 接着聊ConcurrentHashMap，底层实现 Java多线程了解么，什么时候一个int，类型的操作是不安全的，自加呢，赋值呢。如果使用volatile修饰的话有什么作用。 有一个场景，多线程并发，为每个线程安排一个随机的睡眠时间，设想一种数据结构去唤醒睡眠时间结束的线程，应该用哪种结构，答应该用优先级队列，也就是小顶堆，顶部是剩余睡眠时间最短的那个线程。 JVM 你了解哪些收集器？CMS和G1。详细谈谈G1的优点？什么时候进行Full GC呢？ 消息中间件spring全家桶 Spring中涉及的一些设计模式 聊聊Spring，主要IOC等等 数据库 MySQL创建索引的原则，好处 数据库索引，索引底层的实现，B+树的结构以及与普通查找树的优点 MySQL和redis的区别是什么 为什么MySQL和Redis都要使用独立进程来部署，开放端口来提供服务，为什么不写在内核中。 其他 设计模式：讲了单例，工厂方法，抽象工厂，策略模式，观察者模式，代理模式，还顺便讲了下spring动态代理的实现原理 红黑树的具体结构及实现，红黑树与查找树的区别体现 项目中用到dubbo？那你说说什么是rpc框架？和http调用的区别是什么？ Redis有哪些数据结构？持久化方案和区别？ Redis哨兵、集群的设计原理和区别？ Redis缓存和数据库会存在一致性问题吗？怎么解决 Kafka怎么保证数据可靠性？讲了生产者端发送消息到broker持久化，分区和副本机制，消费者消费消息的at-least-once和at-most-once？怎么实现Exactly-Once？ 字节篇数据结构操作系统 用户态如何切换到内核态 进程间通信的方式，哪种最快 信号量怎么实现对共享资源的访问 select和epoll 计算机网络 TCP的流量控制和拥塞控制 不同子网可以通过ARP获取mac地址吗 浏览器中输入网址到获得页面的全过程 输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS 三次握手 握手时产生的序列号干什么用的 讲一下接收窗口 TCP和UDP的本质区别 什么时候选择TCP/UDP HTTPS的连接过程 7层模型和4层模型，每一层有哪些常见协议？ 路由器/交换机是哪一层 网络层用来干嘛？传输层用来干嘛？ HTTP可以使用UDP吗 HTTPS怎么确认收到的包就是服务器发来的 确定发送窗口的大小，如何最大利用带宽，假设延迟100ms，发送端10Mb/s，接收端100Mb/s 网络五层模型，每一层分别有哪些协议 ICMP，TCP，IP，HTTP分别是哪一层，为什么网络模型要分层，每一层之间怎么传递 http头里的gzip 反向***说一下 三次握手，为什么要三次，每一次分别确认了什么 TCP协议的三次握手和四次挥手过程？ 算法 求x的y次方，想出比直接for循环更好的方案 求绝对众数 算法题：红蓝两种球，总共N个， N&gt;2, 排列组合，连续3个颜色一样是非法的，求合法的排列数量 描述一下堆排的过程？建堆的时间复杂度？最大堆中求前k个最大值的时间复杂度？ 算法题：海岛面积计算题，给一个矩阵，0表示海水，相连的1表示海岛，上下左右表示相连。000111101110001（1）求最大海岛面积。（2）求最大海岛面积和对应海岛的所有坐标。（3）求所有海岛的所有坐标，按海岛分。每小题讲思路，最后写第二题。 java基础 Bean的默认作用范围是什么？其他的作用范围？ 平常用线程主要是怎么写的，会用一些线程框架吗？（没有用框架）Java线程池的概念？线程池有哪些？线程池工厂有哪些线程池类型，及其线程池参数是什么？ ConcurrentHashMap讲一讲？ Java bin包下面的工具用过哪些？ 同步IO和异步IO的区别？ 线程如何实现同步？ ConcurrentHashMap 在Java7和Java8中的区别？为什么Java8并发效率更好？什么情况下用HashMap，什么情况用ConcurrentHashMap？ 加锁有什么机制？ ThreadLocal？应用场景？ 多线程JVM Java GC机制？GC Roots有哪些？ 消息中间件spring全家桶 微服务注册发现，为什么用微服务，grpc，protobuf，dubbo讲一下 IoC是什么概念？ Web容器用的什么？你项目里涉及了SSM框架，一个请求到Tomcat容器了，怎么到SSM代码中去？ 数据库 事务的四大特性 四种隔离级别 什么是幻读 InnoDB 怎么防止幻读 B+树原理，为什么使用B+而不是二叉平衡树 1000万个object的文件，有ABC三个date member，怎么根据ABC的条件查询比较快 联合索引 索引是什么概念有什么作用？MySQL里主要有哪些索引结构？哈希索引和B+树索引比较？ MySQL了解到什么程度？binLog知道吗？ 其他 redis分布式锁两种实现 怎么理解微服务 什么是Python生成器，迭代器； 什么是装饰器； 浏览器缓存、CPU的缓存和Redis的缓存的关系，为什么要有缓存 元组和list的区别； Python中的dict底层怎么实现的 list的底层怎么实现的； 双等于和is有什么区别 JSON和protobuf区别 BloomFilter干嘛的，解决了什么问题 REST api和RPC 为什么protobuf效率更高，JSON缺点 1000万条相同class格式object组成的json，怎么压缩 123456789设计题：一个数据库存了以下数据：用户id，登录时间，登出时间；如何找到一天当中的用户峰值（用一个hash map存所有秒数的在线人数）为什么要分用户态和内核态Git 切换分支，提交，具体如何合并分支Python多线程用了几个CPU算法：二叉树，输出所有和为n的路径（可以从中间结点到中间结点） 阿里数据结构操作系统计算机网络算法 红黑树、二叉树的算法 java基础 Servlet规范了解吗？Servlet的整个业务流程？session和cookie的区别？session怎么变成cookie，怎么变回session？谁来实现整个流程？ 刚才提到的分布式实现多个应用的Session共享问题？ 多线程JVM消息中间件spring全家桶 项目提到的SSM框架里面了解哪些？Spring IoC中Bean的生命周期？谁来管理Bean的生命周期？BeanFactory和ApplicationContext的关系？@Autowired和@Resource的区别？ Spring的自动扫描怎么实现的？谁实现的？ MyBatis介绍一下？你说到这是一个持久层框架，那你了解JPA规范吗？ 数据库其他 UML了解吗？（不会）设计模式？ Zookeeper了解吗？ 单例模式、工厂模式、***模式……单例模式有什么需要注意的吗？（多线程并发问题：synchronized+volatile）你写单例的时候如果这个单例对象有字段值，你会去改变这些字段值吗？为什么呢？ 鹅厂数据结构操作系统计算机网络 http三次握手四次挥手 HTTP常见错误码？TCP三次握手？ 算法 海量数据寻找TopK 海量数据排序 16G的文件储存的是一个数组，要求只用1G内存把他们排好序。 排序算法了解哪些？Java里内置的是用什么排序方法？快排是稳定的吗？快排排对象的时候有什么问题？（提示我，三个字段，第一个字段和第二个字段做hash，第三个不做，还是不太懂） 十亿个IP，获得访问次数最多的十个。 五个单词，在一个长文本中查找是否存在。 快速排序算法 java基础 Java中各种锁聊一下，CAS机制。 stl说一下，map原理，时间复杂度 HashMap有了解吗？HashMap的时间复杂度？HashMap中Hash冲突是怎么解决的？链表的上一级结构是什么？Java8中的HashMap有什么变化？红黑树需要比较大小才能进行插入，是依据什么进行比较的？其他Hash冲突解决方式？ 实现线程安全的方式？ThreadLocal原理？线程池了解吗说说看？自己用线程池怎么定参数？ 多线程 volatile有用过么，底层实现，这个问题是讲到了CPU填充缓存行指令。 Java线程池 JVM GC回收器JVM调优参数配置 JJava堆中怎么分区？怎么判断对象是否需要回收？Java内存占用过大怎么查看？Java内存溢出有碰到过吗？Java内存溢出怎么定位？ 消息中间件spring全家桶数据库 数据库的事务隔离级别，mvcc机制聊一下。 数据库索引，B+树结构和特点。怎么进行优化 mysql间隙锁为了解决什么问题，什么条件下会触发。 MySQL数据库引擎？应用场景？查询优化？NoSQL有用或了解吗？ 其他 红黑树，AVL树，查询时间复杂度，什么情况下用红黑树而不用map 进程和线程的区别？平常的开发环境是Windows还是Linux？Linux命令知道哪些？要在多个文本文件中找一个关键词用什么命令？（grep）网络相关的命令是什么？ 度娘数据结构操作系统计算机网络算法java基础多线程JVM消息中间件spring全家桶 springboot和spring比有什么优点 springboot自动配置原理 数据库 高并发数据库大表优化，分库分表，水平怎么拆，垂直怎么拆 知道哪些索引，索引数据结构 联合索引规则 数据库怎么优化，查询性能瓶颈怎么查（explain） 其他美团数据结构操作系统计算机网络算法java基础多线程JVM消息中间件spring全家桶数据库其他拼夕夕数据结构 二叉树的后序遍历，非递归算法。 操作系统计算机网络 TCP三次握手的过程，如果没有第三次握手有什么问题。 算法java基础 如何访问一个文件的字节流呢 多线程 做的主要是Java对吧，讲一下多线程把，用到哪些写一下，写了thread和runnable，然后写了线程池，她问我线程池由哪些组件组成，有哪些线程池，分别怎么使用，以及拒绝策略有哪些。 什么时候多线程会发生死锁，写一个例子吧，然后我写了一个两个线程，两个锁，分别持有一个，请求另一个的死锁实例 集合类熟悉吧，写一个题目，一个字符串集合，找出pdd并且删除，我直接写了一个list然后for循环判断相等时删除，她说明显问题，我才发现list直接删位置会出错，于是我说改用数组，她说不太符合要求，所以应该使用iterator删除会好一点，修改会反映到集合类，并且不会出错。 然后说一下Redis吧，是单线程还是多线程，Redis的分布式怎么做，说了集群。 RPC了解么，我说了主要是协议栈+数据格式+序列化方式，然后需要有服务注册中心管理生产者和消费者，他问我注册中心宕机怎么办，我说可以做高可用，他说要问的不是这个，是想问我注册中心宕机时消费者是否能访问生产者。 线程数很多会怎么样，我说会占内存，还有就是切换线程比较频繁，他问切换线程会发生什么，应该就是CPU切换上下文，具体就是寄存器和内存地址的刷新。 JVM消息中间件spring全家桶数据库 MySQL的主从复制怎么做的，答日志，具体原理是什么，有什么优缺点。 其他 Redis了解哪些内容，是单线程么，为什么是单线程呢，数据一定是存在物理内存中么，我不懂这话啥意思，就问了一下是不是指可能也在虚拟内存中。他说那讲一下虚拟内存的机制把，我就讲了分页，页表，换页这些东西。 分布式了解哪些东西，消息队列了解么，用在什么场景，说了削峰，限流和异步。说了kafka，问我怎么保证数据不丢失，以及确保消息不会被重复消费。还问了消息送达确认是怎么做的。 cap了解么，分别指什么，base呢，强一致性和弱一致性有什么方法来做，2pc了解么，说一下大概过程。 这样一个题目，一个节点要和客户连接建立心跳检测，大概有百万数量的连接，并且会定期发送心跳包，要写一个update方法和check方法，update方法更新心跳状态，check删除超时节点，怎么做，刚开始做了个hash发现check要轮询太慢了，然后用计时器和开线程检测也不行，最后说了个LRU，他说OK的。 华为数据结构操作系统计算机网络算法java基础多线程JVM消息中间件spring全家桶 请求到SSH框架的流程图画一下？远程调用Shell脚本用到哪些命令？ 数据库 数据量多大？项目PG（PostgreSQL）版本？非结构化数据指的是什么？有没有考虑过nosql？分库分表怎么分？查询的表会合并在一起吗？ 项目性能有没有考虑过？（我是做服务端的，主要考虑请求并发量）数据库性能呢？（了解一点，MySQL主从结构） 其他 Nginx原理了解吗？（只用到负载均衡，介绍了一下负载均衡策略 网易数据结构操作系统计算机网络算法 判断树对称 数组顺时针旋转90度 用wait和notify模拟生产者消费者模式 java基础 public protected private区别？final和finally区别？final可以用在方法参数上吗？RuntimeException和非RuntimeException？各举几个例子？比方说文件读写的时候会有什么异常？怎么实现序列化？除了Java原生序列化方法，序列化还有什么格式？ ArrayList和LinkedList区别？ ArrayList和LinkedList是线程安全的吗？为什么说他们不是线程安全的，举实际场景？ 有什么线程安全的List？（CopyOnWriteArrayList）讲一下怎么实现线程安全的？（读时复制，写时共享，加锁机制） 线程A和线程B同时针对一个共享变量进行操作，如何实现线程安全？ 平常怎么创建线程？线程池里闲置线程怎么保活？（不清楚，说了自己的想法）那怎么唤醒？如果用wait()和notify()，对谁加锁？ synchronized 和 ReentranLock的区别？平常有用哪些集合类？Concurrent包有用吗？ 多线程JVM JVM内存模型？如果给一个类，里面只有一个main方法，方法里面只有一句System.out.println(“helloworld”)，问运行这个类会在Java内存模型里发生什么？ “helloworld”存储在哪里？ JVM内存模型？每个区是做什么的？垃圾回收机制？ 消息中间件spring全家桶 Spring中Bean生命周期？提到的Aware相关接口指的是什么？平常会自己会用Aware相关接口吗？Bean生命周期这么长是为什么？ 数据库 给一个数据库表，ID、score两个字段分别代表学生ID和成绩，写SQL语句求ID=？的学生排第几名？ 假设是InnoDB，给上述SQL语句加索引怎么加？为什么这样建立？聚集索引和非聚集索引有什么区别？ MySQL数据库，给一个用户表格，ID、用户名、性别、用户信息…，假设经常对性别字段进行查询，问怎么建立索引？为什么？假设用户名需要是唯一的，问怎么建索引？ 添加索引的SQL语句？给一个abc三个字段的索引，where a=0 order by c能用到索引吗？where a=0 and b大于0 order by c能用到索引吗？Hash索引和B树索引的区别？Hash索引有区间查询吗？有没有用nosql？ 其他 介绍一下觉得做得最好的项目？画一下项目的框架结构图？Nginx用来做什么？采用了什么负载均衡策略？万一某一个服务器挂掉怎么办？（一致性hash）如果添加一个节点呢？ 平常用到哪些设计模式？介绍一下模式？模式和装饰器模式区别？ NIO和BIO区别？NIO怎么写？阻塞和非阻塞，同步和异步区别？ CVTE数据结构操作系统计算机网络算法java基础 Java为什么说是面向对象的？ ava的三大特性？如果说有两个方法，同名同参数但不同返回值，问是重载吗？ 平常用到哪些集合类？ArrayList和LinkedList区别？HashMap内部数据结构？ConcurrentHashMap分段锁？ 多线程 Volatile关键词？是线程安全的吗？ 如何实现synchronized一样的效果？ JVM消息中间件spring全家桶 Spring Cloud用到什么东西？如何实现负载均衡？服务挂了注册中心怎么判断 Spring的优点？Spring AOP实现原理？AOP应用场景？拦截器用来做什么业务？ 数据库 MySQL数据库引擎和应用场景 MySQL行锁是否会有死锁的情况？ MySQL事务隔离级别 MySQL平常有索引优化吗？怎么去知道一个SQL语句需不需要优化？一个表，建立了索引（B，A），问where A=1 and B=2索引是否能够生效？ 乐观锁和悲观锁了解吗？JDK中涉及到乐观锁和悲观锁的内容 其他 Nginx负载均衡策略？ ip_hash的优缺点？ Nginx和其他负载均衡框架对比过吗？ Tomcat集群Session共享问题？ MySQL采用了什么存储引擎，为什么？ 分布式锁？]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滑动窗口技巧汇总]]></title>
    <url>%2F2019%2F12%2F24%2F%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[本文详解「滑动窗口」这种高级双指针技巧的算法框架，带你秒杀几道高难度的子字符串匹配问题。 LeetCode 上至少有 9 道题目可以用此方法高效解决。但是有几道是 VIP 题目，有几道题目虽不难但太复杂，所以本文只选择点赞最高，较为经典的，最能够讲明白的三道题来讲解。第一题为了让读者掌握算法模板，篇幅相对长，后两题就基本秒杀了。 本文代码为 C++ 实现，不会用到什么编程方面的奇技淫巧，但是还是简单介绍一下一些用到的数据结构，以免有的读者因为语言的细节问题阻碍对算法思想的理解： unordered_map 就是哈希表（字典），它的一个方法 count(key) 相当于 containsKey(key) 可以判断键 key 是否存在。 可以使用方括号访问键对应的值 map[key]。需要注意的是，如果该 key 不存在，C++ 会自动创建这个 key，并把 map[key] 赋值为 0。 所以代码中多次出现的 map[key]++ 相当于 Java 的 map.put(key, map.getOrDefault(key, 0) + 1)。 本文大部分代码都是图片形式，可以点开放大，更重要的是可以左右滑动方便对比代码。下面进入正题。 一、最小覆盖子串 题目链接 题目不难理解，就是说要在 S(source) 中找到包含 T(target) 中全部字母的一个子串，顺序无所谓，但这个子串一定是所有可能子串中最短的。 如果我们使用暴力解法，代码大概是这样的： 1234for (int i = 0; i &lt; s.size(); i++) for (int j = i + 1; j &lt; s.size(); j++) if s[i:j] 包含 t 的所有字母: 更新答案 思路很直接吧，但是显然，这个算法的复杂度肯定大于 O(N^2) 了，不好。 滑动窗口算法的思路是这样： 1、我们在字符串 S 中使用双指针中的左右指针技巧，初始化 left = right = 0，把索引闭区间 [left, right] 称为一个「窗口」。 2、我们先不断地增加 right 指针扩大窗口 [left, right]，直到窗口中的字符串符合要求（包含了 T 中的所有字符）。 3、此时，我们停止增加 right，转而不断增加 left 指针缩小窗口 [left, right]，直到窗口中的字符串不再符合要求（不包含 T 中的所有字符了）。同时，每次增加 left，我们都要更新一轮结果。 4、重复第 2 和第 3 步，直到 right 到达字符串 S 的尽头。 这个思路其实也不难，第 2 步相当于在寻找一个「可行解」，然后第 3 步在优化这个「可行解」，最终找到最优解。左右指针轮流前进，窗口大小增增减减，窗口不断向右滑动。 下面画图理解一下，needs 和 window 相当于计数器，分别记录 T 中字符出现次数和窗口中的相应字符的出现次数。 初始状态： 0 增加 right，直到窗口 [left, right] 包含了 T 中所有字符： 0 现在开始增加 left，缩小窗口 [left, right]。 0 直到窗口中的字符串不再符合要求，left 不再继续移动。 0 之后重复上述过程，先移动 right，再移动 left…… 直到 right 指针到达字符串 S 的末端，算法结束。 如果你能够理解上述过程，恭喜，你已经完全掌握了滑动窗口算法思想。至于如何具体到问题，如何得出此题的答案，都是编程问题，等会提供一套模板，理解一下就会了。 上述过程可以简单地写出如下伪码框架： 123456789101112131415161718string s, t;// 在 s 中寻找 t 的「最小覆盖子串」int left = 0, right = 0;string res = s;while(right &lt; s.size()) &#123; window.add(s[right]); right++; // 如果符合要求，移动 left 缩小窗口 while (window 符合要求) &#123; // 如果这个窗口的子串更短，则更新 res res = minLen(res, window); window.remove(s[left]); left++; &#125;&#125;return res; 如果上述代码你也能够理解，那么你离解题更近了一步。现在就剩下一个比较棘手的问题：如何判断 window 即子串 s[left…right] 是否符合要求，是否包含 t 的所有字符呢？ 可以用两个哈希表当作计数器解决。用一个哈希表 needs 记录字符串 t 中包含的字符及出现次数，用另一个哈希表 window 记录当前「窗口」中包含的字符及出现的次数，如果 window 包含所有 needs 中的键，且这些键对应的值都大于等于 needs 中的值，那么就可以知道当前「窗口」符合要求了，可以开始移动 left 指针了。 现在将上面的框架继续细化： 123456789101112131415161718192021222324252627282930313233343536373839404142string s, t;// 在 s 中寻找 t 的「最小覆盖子串」int left = 0, right = 0;string res = s;// 相当于两个计数器unordered_map&lt;char, int&gt; window;unordered_map&lt;char, int&gt; needs;for (char c : t) needs[c]++;// 记录 window 中已经有多少字符符合要求了int match = 0; while (right &lt; s.size()) &#123; char c1 = s[right]; if (needs.count(c1)) &#123; window[c1]++; // 加入 window if (window[c1] == needs[c1]) // 字符 c1 的出现次数符合要求了 match++; &#125; right++; // window 中的字符串已符合 needs 的要求了 while (match == needs.size()) &#123; // 更新结果 res res = minLen(res, window); char c2 = s[left]; if (needs.count(c2)) &#123; window[c2]--; // 移出 window if (window[c2] &lt; needs[c2]) // 字符 c2 出现次数不再符合要求 match--; &#125; left++; &#125;&#125;return res; 上述代码已经具备完整的逻辑了，只有一处伪码，即更新 res 的地方，不过这个问题太好解决了，直接看解法吧！ 123456789101112131415161718192021222324252627282930313233343536373839404142string minWindow(string s, string t) &#123; // 记录最短子串的开始位置和长度 int start = 0, minLen = INT_MAX; int left = 0, right = 0; unordered_map&lt;char, int&gt; window; unordered_map&lt;char, int&gt; needs; for (char c : t) needs[c]++; int match = 0; while (right &lt; s.size()) &#123; char c1 = s[right]; if (needs.count(c1)) &#123; window[c1]++; if (window[c1] == needs[c1]) match++; &#125; right++; while (match == needs.size()) &#123; if (right - left &lt; minLen) &#123; // 更新最小子串的位置和长度 start = left; minLen = right - left; &#125; char c2 = s[left]; if (needs.count(c2)) &#123; window[c2]--; if (window[c2] &lt; needs[c2]) match--; &#125; left++; &#125; &#125; return minLen == INT_MAX ? "" : s.substr(start, minLen);&#125; 如果直接甩给你这么一大段代码，我想你的心态是爆炸的，但是通过之前的步步跟进，你是否能够理解这个算法的内在逻辑呢？你是否能清晰看出该算法的结构呢？ 这个算法的时间复杂度是 O(M + N)，M 和 N 分别是字符串 S 和 T 的长度。因为我们先用 for 循环遍历了字符串 T 来初始化 needs，时间 O(N)，之后的两个 while 循环最多执行 2M 次，时间 O(M)。 读者也许认为嵌套的 while 循环复杂度应该是平方级，但是你这样想，while 执行的次数就是双指针 left 和 right 走的总路程，最多是 2M 嘛。 二、找到字符串中所有字母异位词 题目链接 这道题的难度是 Easy，但是评论区点赞最多的一条是这样： 1How can this problem be marked as easy??? 实际上，这个 Easy 是属于了解双指针技巧的人的，只要把上一道题的代码改中更新 res 部分的代码稍加修改就成了这道题的解： 12345678910111213141516171819202122232425262728293031323334353637vector&lt;int&gt; findAnagrams(string s, string t) &#123; // 用数组记录答案 vector&lt;int&gt; res; int left = 0, right = 0; unordered_map&lt;char, int&gt; needs; unordered_map&lt;char, int&gt; window; for (char c : t) needs[c]++; int match = 0; while (right &lt; s.size()) &#123; char c1 = s[right]; if (needs.count(c1)) &#123; window[c1]++; if (window[c1] == needs[c1]) match++; &#125; right++; while (match == needs.size()) &#123; // 如果 window 的大小合适 // 就把起始索引 left 加入结果 if (right - left == t.size()) &#123; res.push_back(left); &#125; char c2 = s[left]; if (needs.count(c2)) &#123; window[c2]--; if (window[c2] &lt; needs[c2]) match--; &#125; left++; &#125; &#125; return res;&#125; 因为这道题和上一道的场景类似，也需要 window 中包含串 t 的所有字符，但上一道题要找长度最短的子串，这道题要找长度相同的子串，也就是「字母异位词」嘛。 三、无重复字符的最长子串 题目链接 遇到子串问题，首先想到的就是滑动窗口技巧。 类似之前的思路，使用 window 作为计数器记录窗口中的字符出现次数，然后先向右移动 right，当 window 中出现重复字符时，开始移动 left 缩小窗口，如此往复： 123456789101112131415161718192021int lengthOfLongestSubstring(string s) &#123; int left = 0, right = 0; unordered_map&lt;char, int&gt; window; int res = 0; // 记录最长长度 while (right &lt; s.size()) &#123; char c1 = s[right]; window[c1]++; right++; // 如果 window 中出现重复字符 // 开始移动 left 缩小窗口 while (window[c1] &gt; 1) &#123; char c2 = s[left]; window[c2]--; left++; &#125; res = max(res, right - left); &#125; return res;&#125; 需要注意的是，因为我们要求的是最长子串，所以需要在每次移动 right 增大窗口时更新 res，而不是像之前的题目在移动 left 缩小窗口时更新 res。 最后总结通过上面三道题，我们可以总结出滑动窗口算法的抽象思想： 12345678910111213int left = 0, right = 0;while (right &lt; s.size()) &#123; window.add(s[right]); right++; while (valid) &#123; window.remove(s[left]); left++; &#125;&#125; 其中 window 的数据类型可以视具体情况而定，比如上述题目都使用哈希表充当计数器，当然你也可以用一个数组实现同样效果，因为我们只处理英文字母。 稍微麻烦的地方就是这个 valid 条件，为了实现这个条件的实时更新，我们可能会写很多代码。比如前两道题，看起来解法篇幅那么长，实际上思想还是很简单，只是大多数代码都在处理这个问题而已。]]></content>
      <tags>
        <tag>java</tag>
        <tag>双指针</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[双指针技巧汇总]]></title>
    <url>%2F2019%2F12%2F24%2F%E5%8F%8C%E6%8C%87%E9%92%88%E6%8A%80%E5%B7%A7%E6%B1%87%E6%80%BB.html</url>
    <content type="text"><![CDATA[我把双指针技巧再分为两类，一类是「快慢指针」，一类是「左右指针」。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。 一、快慢指针的常见算法快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。 1、判定链表中是否含有环 这应该属于链表最基本的操作了，如果读者已经知道这个技巧，可以跳过。 单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。 如果链表中不含环，那么这个指针最终会遇到空指针 null 表示链表到头了，这还好说，可以判断该链表不含环。 12345boolean hasCycle(ListNode head) &#123; while (head != null) head = head.next; return false;&#125; 但是如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。 经典解法就是用两个指针，一个跑得快，一个跑得慢。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。 123456789101112boolean hasCycle(ListNode head) &#123; ListNode fast, slow; fast = slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) return true; &#125; return false;&#125; 2、已知链表中含有环，返回这个环的起始位置 1 这个问题一点都不困难，有点类似脑筋急转弯，先直接看代码： 12345678910111213141516ListNode detectCycle(ListNode head) &#123; ListNode fast, slow; fast = slow = head; while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next; if (fast == slow) break; &#125; // 上面的代码类似 hasCycle 函数 slow = head; while (slow != fast) &#123; fast = fast.next; slow = slow.next; &#125; return slow;&#125; 可以看到，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。这是为什么呢？ 第一次相遇时，假设慢指针 slow 走了 k 步，那么快指针 fast 一定走了 2k 步，也就是说比 slow 多走了 k 步（也就是环的长度）。 2 设相遇点距环的起点的距离为 m，那么环的起点距头结点 head 的距离为 k - m，也就是说如果从 head 前进 k - m 步就能到达环起点。 巧的是，如果从相遇点继续前进 k - m 步，也恰好到达环起点。 3 所以，只要我们把快慢指针中的任一个重新指向 head，然后两个指针同速前进，k - m 步后就会相遇，相遇之处就是环的起点了。 3、寻找链表的中点 类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。 123456while (fast != null &amp;&amp; fast.next != null) &#123; fast = fast.next.next; slow = slow.next;&#125;// slow 就在中间位置return slow; 当链表的长度是奇数时，slow 恰巧停在中点位置；如果长度是偶数，slow 最终的位置是中间偏右： center 寻找链表中点的一个重要作用是对链表进行归并排序。 回想数组的归并排序：求中点索引递归地把数组二分，最后合并两个有序数组。对于链表，合并两个有序链表是很简单的，难点就在于二分。 但是现在你学会了找到链表的中点，就能实现链表的二分了。关于归并排序的具体内容本文就不具体展开了。 4、寻找链表的倒数第 k 个元素 我们的思路还是使用快慢指针，让快指针先走 k 步，然后快慢指针开始同速前进。这样当快指针走到链表末尾 null 时，慢指针所在的位置就是倒数第 k 个链表节点（为了简化，假设 k 不会超过链表长度）： 1234567891011ListNode slow, fast;slow = fast = head;while (k-- &gt; 0) fast = fast.next;while (fast != null) &#123; slow = slow.next; fast = fast.next;&#125;return slow; 二、左右指针的常用算法左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。 1、二分查找 前文「二分查找」有详细讲解，这里只写最简单的二分算法，旨在突出它的双指针特性： 1234567891011121314int binarySearch(int[] nums, int target) &#123; int left = 0; int right = nums.length - 1; while(left &lt;= right) &#123; int mid = (right + left) / 2; if(nums[mid] == target) return mid; else if (nums[mid] &lt; target) left = mid + 1; else if (nums[mid] &gt; target) right = mid - 1; &#125; return -1;&#125; 2、两数之和 直接看一道 LeetCode 题目吧： title 只要数组有序，就应该想到双指针技巧。这道题的解法有点类似二分查找，通过调节 left 和 right 可以调整 sum 的大小： 123456789101112131415int[] twoSum(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; while (left &lt; right) &#123; int sum = nums[left] + nums[right]; if (sum == target) &#123; // 题目要求的索引是从 1 开始的 return new int[]&#123;left + 1, right + 1&#125;; &#125; else if (sum &lt; target) &#123; left++; // 让 sum 大一点 &#125; else if (sum &gt; target) &#123; right--; // 让 sum 小一点 &#125; &#125; return new int[]&#123;-1, -1&#125;;&#125; 3、反转数组 1234567891011void reverse(int[] nums) &#123; int left = 0; int right = nums.length - 1; while (left &lt; right) &#123; // swap(nums[left], nums[right]) int temp = nums[left]; nums[left] = nums[right]; nums[right] = temp; left++; right--; &#125;&#125; 4、滑动窗口算法 这也许是双指针技巧的最高境界了，如果掌握了此算法，可以解决一大类子字符串匹配的问题，不过「滑动窗口」稍微比上述的这些算法复杂些。 幸运的是，这类算法是有框架模板的，下篇文章就准备讲解「滑动窗口」算法模板，帮大家秒杀几道 LeetCode 子串匹配的问题。]]></content>
      <tags>
        <tag>java</tag>
        <tag>双指针</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[labuladong公众号笔记]]></title>
    <url>%2F2019%2F12%2F22%2Flabuladong%E5%85%AC%E4%BC%97%E5%8F%B7%E7%AC%94%E8%AE%B0(dp%26%26%E4%BA%8C%E5%88%86).html</url>
    <content type="text"><![CDATA[动态规划：不同的定义产生不同的解法文章链接键盘组合问题 收获对状态机的定义不同，得到的状态转移方程就完全不同 经典面试题：最长回文子串（LeetCode第5题）文章链接经典面试题：最长回文子串 收获回文子串有两个做法，一个是从中间展开的算法，一个是两侧向中间靠齐的dp 单调栈文章链接单调栈 Monotonic Stack 的使用 收获 单调栈算法过程 处理Next Greater Number，从后向前遍历 先判断 栈是否为空 和 栈顶的值是不是比即将入栈的值小 如果栈空，则说明找不到比该数大的数，将其Next Greater Number置为-1 栈不为空，直到找到比该数大的数，将其置为栈顶，比其小的也就没有存在的意义了 然后将该数的Next Greater Number定为栈顶元素，并将该数加入栈中 处理循环数组 将该数组的双倍长度构造出来，这样的话就就不仅能比较右边的数，还能比较左边的数了 二分查找算法详解文章链接二分查找算法详解 二分查找的框架 最基本的框架1（形式是[a,b)） 123456789101112131415int binarySearch(int nums[],int target)&#123; int left = 0; int right = nums.length; while(left &lt; right)&#123; //防止计算mid时溢出 int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target) left = mid + 1; else if(nums[mid] &gt; target) right = mid; &#125; return -1;&#125; 最基本的框架2 (形式是[a,b]) 123456789101112131415int binarySearch(int nums[],int target)&#123; int left = 0; int right = nums.length - 1; while(left &lt;= right)&#123; //防止计算mid时溢出 int mid = left + (right - left) / 2; if(nums[mid] == target) return mid; else if(nums[mid] &lt; target) left = mid + 1; else if(nums[mid] &gt; target) right = mid - 1; &#125; return -1;&#125; 寻找左侧边界的二分搜索 12345678910111213141516171819202122232425/** * 返回的是比target小的数量，同时也是最左target的下标 * @param nums * @param target * @return */int binarySearchLeft(int nums[],int target)&#123; int left = 0; int right = nums.length; while(left &lt; right)&#123; //防止计算mid时溢出 int mid = left + (right - left) / 2; if(nums[mid] == target) right = mid; else if(nums[mid] &lt; target) left = mid + 1; else if(nums[mid] &gt; target) right = mid; &#125; //要时刻注意处理边界，如果整个数组都没有这个target，则left会到nums.length // target 比所有数都大 if (left == nums.length) return -1; // 类似之前算法的处理方式 return nums[left] == target ? left : -1;&#125; 寻找右侧边界的二分搜索 1234567891011121314151617181920212223242526/** * 返回的是最右target的下标 * @param nums * @param target * @return */int binarySearchRight(int nums[],int target)&#123; int left = 0; int right = nums.length; while(left &lt; right)&#123; //防止计算mid时溢出 int mid = left + (right - left) / 2; if(nums[mid] == target) left = mid + 1; else if(nums[mid] &lt; target) left = mid + 1; else if(nums[mid] &gt; target) right = mid; &#125; //要时刻注意处理边界，如果整个数组都没有这个target，则left会到nums.length // target 比所有数都大 // return left - 1; if (left == 0) return -1; // 类似之前算法的处理方式 return nums[left-1] == target ? (left-1) : -1;&#125; 收获 左侧边界的二分搜索，left即代表比target小的数的数量 右侧边界的二分搜索，left即代表比target大的第一个数的下标，比如是5，则代表索引为4是target的最右侧数 最长递归子序列(LeetCode第300题)文章链接动态规划之最长递归子序列 两个方法： dp 扑克牌算法，运用二分查找 dp注意事项最重要的是先确定状态转移方程，并且明确dp数组的含义，这里要求的是最长递归子序列，所建立的dp数组是一个一维数组(为何选取的是一维数组呢？)，并且dp[i]的含义是指以索引i结尾的最长递归子序列。 采用归纳法可知，若dp[0…i-1]可知，则 1234for(int j = 0; j &lt; i;j++)&#123; if(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i],dp[j]+1);&#125; 即dp[i]是之前的dp[0…i-1]，判断其是否小于nums[i]，若小于则nums[i]可以接到其后面，最后选取一个最长的递归子序列即可。 还有要考虑的就是basecase，由于是最短递归子序列至少为1，所以basecase为1，所以dp数组全部初始化为1即可。 代码123456789101112131415public int lengthOfLtsByDp(int nums[])&#123; int[] dp = new int[nums.length]; Arrays.fill(dp,1); for(int i = 0;i &lt; nums.length;i++)&#123; for(int j = 0; j &lt; i;j++)&#123; if(nums[j] &lt; nums[i]) dp[i] = Math.max(dp[i],dp[j]+1); &#125; &#125; int res = 0; for(int i = 0; i &lt; dp.length; i++)&#123; res = Math.max(res,dp[i]); &#125; return res;&#125; 扑克牌算法最长递归子序列其实类似于我们平时玩的蜘蛛纸牌，eg：2，3，1，9，7，4，6，3 ，同一堆的牌只能是小的放在大的上面，如上，就分成2，1 3 9，7，6，3 4 一共4堆，则最长递归子序列数为 4 。 至于如何处理扑克牌放置问题，则可以采用二分查找，因为堆顶都是有序的。 12345678910111213141516171819202122232425public int lengthOfLtsByBinarySearch(int[] nums)&#123; //堆的个数 int piles = 0; //记录每个堆的最上面的牌，保证有序，所以必须利用最左侧边界的二分法 int[] top = new int[nums.length]; for(int i = 0;i &lt; nums.length;i++)&#123; int poker = nums[i]; int left = 0; int right = piles; while(left &lt; right)&#123; int mid = left + (right - left) / 2; if(poker &lt; top[mid]) right = mid; else if(poker &gt; top[mid]) left = mid + 1; else right = mid; &#125; //left的取值有[0,nums.length],当left为nums.length时，这里是piles，说明牌堆上的第一张牌全部比它小，则说明此时需要新建一个牌堆 if (left == piles) piles++; top[left] = poker; &#125; return piles;&#125; ​ 子序列解题模板文章链接子序列解题模板 收获两种思路 dp数组为一维数组。常见题型有 最长递增子序列。在子数组array[0..i]中，以array[i]结尾的目标子序列（最长递增子序列）的长度是dp[i]。 模板： 12345678int n = array.length;int[] dp = new int[n];for (int i = 1; i &lt; n; i++) &#123; for (int j = 0; j &lt; i; j++) &#123; dp[i] = 最值(dp[i], dp[j] + ...) &#125;&#125; dp数组为二维数组。二维数组又分为是对两字符串而言和一个字符串而言。 模板： 1234567891011int n = arr.length;int[][] dp = new dp[n][n];for (int i = 0; i &lt; n; i++) &#123; for (int j = 1; j &lt; n; j++) &#123; if (arr[i] == arr[j]) dp[i][j] = dp[i][j] + ... else dp[i][j] = 最值(...) &#125;&#125; 对一个字符串使用的dp为二维数组。常见题型有之前做过的 最长回文子串，使用双指针，从两边向中间靠拢，二维分别指的是左侧指针和右侧指针的索引值。可以推广到最长回文子序列。 对两个字符串使用的dp为二维数组。例如 编辑距离 和 最长公共子序列 回文子序列的求解(LeetCode第516题)回文子序列的求解，是在回文子串的基础上进行的，dp[i][j] 的长度取决于s[i]和s[j]以及dp[i+1][j-1] 当s[i] == s[j]时，dp[i][j] = dp[i+1][j-1] + 2 当s[i] != s[j]时， dp[i][j] = Math.max(dp[i][j-1]，dp[i+1][j]) 当转移方程写好后，最大的难点就是如何遍历dp，建议采用表的形式，从方程中可以看到，我们必须得到左边、下边、左下，三个dp表达式才能得到下一个dp表达式，故可以采用斜着遍历的方式和逆循环从下往上遍历即可。 123456789101112131415161718192021222324/** * 斜着遍历的dp * @param nums * @return */ private static int dp(int[] nums)&#123; int[][] dp = new int[nums.length][nums.length];// Arrays.fill(dp, 0); int j = 0; for(int i = 0;i &lt; nums.length;i++)&#123; dp[i][i] = 1; &#125; //斜着循环遍历 for(int n = 1;n &lt; nums.length;n++)&#123; for(int i = 0; i &lt; nums.length - n;i++)&#123; j = i + n; if(nums[i] == nums[j]) dp[i][j] = dp[i+1][j-1] + 2; else dp[i][j] = Math.max(dp[i][j-1],dp[i+1][j]); &#125; &#125; return dp[0][nums.length-1]; &#125; 12345678910111213141516171819202122232425 /** * 逆循环遍历的dp * @param nums * @return */ private static int dpByInverse(int[] nums)&#123; int[][] dp = new int[nums.length][nums.length];// Arrays.fill(dp, 0);// int j = 0; int n = nums.length; for(int i = 0;i &lt; nums.length;i++)&#123; dp[i][i] = 1; &#125; // 反着遍历保证正确的状态转移 for (int i = n - 1; i &gt;= 0; i--) &#123; for (int j = i + 1; j &lt; n; j++) &#123; // 状态转移方程 if (nums[i] == nums[j]) dp[i][j] = dp[i + 1][j - 1] + 2; else dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]); &#125; &#125; return dp[0][nums.length-1]; &#125; 编辑距离（LeetCode第72题）先总结一哈：从后往前，然后写递归函数，然后画DP Table，写非递归，注意Base case！ 文章链接编辑距离 题目给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。 你可以对一个单词进行如下三种操作： 插入一个字符删除一个字符替换一个字符示例 1: 123456输入: word1 = "horse", word2 = "ros"输出: 3解释: horse -&gt; rorse (将 'h' 替换为 'r')rorse -&gt; rose (删除 'r')rose -&gt; ros (删除 'e') 示例 2: 12345678输入: word1 = "intention", word2 = "execution"输出: 5解释: intention -&gt; inention (删除 't')inention -&gt; enention (将 'i' 替换为 'e')enention -&gt; exention (将 'n' 替换为 'x')exention -&gt; exection (将 'n' 替换为 'c')exection -&gt; execution (插入 'u') 思路个人觉得公众号说的有的啰嗦哈~ 我就稍微总结一下我的想法： 拿到题目，又是两个字符串之间的问题，毫无疑问第一想法想到使用双指针的dp，因为一般遇到两个字符串的问题都是采用dp二维数组解决(双指针)； dp解决问题，首先就要搞清楚dp数组代表什么，其次就是状态转移有哪几种情况！ 一般dp二维数组 dp[i][j] ,代表以s1[i-1]、s2[j-1]结尾的转换的最少操作数，为啥是i-1,j-1！因为dp是从dp[1][1]开始的，代表字符串的第一个字符！！ 搞明白了dp数组是啥含义，现在就要搞清楚有哪几种状态转移，从公众号中可以看到，dp[i][j]想要往前移动，则可以进行删除、修改、插入操作，如果双指针指向的字符相同，则无需进行任何操作，直接向前移动就行，也就是此时 dp[i][j] = dp[i-1][j-1] ; 剩下的插入、删除、修改如何做呢…取三者最小值就好了嘛！！！ 其实这个画个DP表就非常的清晰了，画DP表也能提醒我们注意Base Case,因为没有Base Case ，我们是肯定写不出来DP表中的值的； 有个注意的点，就是备忘录做法是从0开始的，所以当i或者j = -1时，此时的i、j代表的是数组的下标，是从0开始的，比如说此时j = 5的，说明还有6个字符需要删除，所以要记得+1 ，而dp是从dp[1][1]开始的(比如两个字符串’’abc””acd”，dp[1][1]指的是都指向a)！！！！这个很容易错！ 三种做法 常规暴力递归(超时) 123456789101112131415161718192021class Solution &#123; public int minDistance(String word1, String word2) &#123; int len = dp_violence(word1,word2,word1.length()-1,word2.length()-1); return len; &#125; private int dp_violence(String s1,String s2,int i, int j) &#123; if(i == -1) return j + 1; if(j == -1) return i + 1; if(s1.charAt(i) == s2.charAt(j))&#123; return dp_violence(s1,s2,i-1,j-1); &#125; else&#123; int min = Math.min(dp_violence(s1,s2,i-1,j-1)+1, dp_violence(s1,s2,i-1,j)+1); min = Math.min( dp_violence(s1,s2,i,j-1)+1,min); return min; &#125; &#125;&#125; 带备忘录的递归(这个貌似比dp更优秀) 1234567891011121314151617181920212223242526272829class Solution &#123; public int minDistance(String word1, String word2) &#123; int[][] beiwanglu = new int[word1.length()][word2.length()]; int len = dp_beiwanglu(beiwanglu,word1,word2,word1.length()-1,word2.length()-1); return len; &#125; private int dp_beiwanglu(int[][] beiwanglu,String s1, String s2, int i, int j) &#123; if(i == -1) return j + 1; if(j == -1) return i + 1; if(beiwanglu[i][j] != 0)&#123; return beiwanglu[i][j]; &#125; if(s1.charAt(i) == s2.charAt(j))&#123; beiwanglu[i][j] = dp_beiwanglu(beiwanglu,s1,s2,i-1,j-1); return dp_beiwanglu(beiwanglu,s1,s2,i-1,j-1); &#125; else&#123; int min = Math.min(dp_beiwanglu(beiwanglu,s1,s2,i-1,j-1)+1, dp_beiwanglu(beiwanglu,s1,s2,i-1,j)+1); min = Math.min( dp_beiwanglu(beiwanglu,s1,s2,i,j-1)+1,min); beiwanglu[i][j] = min; return min; &#125; &#125;&#125; dp 1234567891011121314151617181920212223class Solution &#123; public int minDistance(String s1, String s2) &#123; int[][] dp = new int[s1.length()+1][s2.length()+1]; for(int i = 0;i&lt;= s1.length();i++)&#123; dp[i][0] = i; &#125; for(int j = 0;j&lt;=s2.length();j++)&#123; dp[0][j] = j; &#125; for(int i = 1;i&lt;= s1.length();i++)&#123; for(int j = 1;j &lt;= s2.length();j++)&#123; if(s1.charAt(i-1) == s2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1]; &#125; else&#123; dp[i][j] = Math.min(dp[i-1][j-1] + 1,dp[i-1][j] + 1); dp[i][j] = Math.min(dp[i][j],dp[i][j-1] + 1); &#125; &#125; &#125; return dp[s1.length()][s2.length()]; &#125;&#125; 最长公共子序列问题（LeetCode第1143题）典型的dp二维数组解决，太简单了… 第一个要注意的就是该dp可以优化，当双指针指向的字符不等时，dp[i-1][j-1]可以不用考虑！！！！因为max(dp[i][j-1],dp[i-1][j],dp[i-1][j-1])是一定轮不到最后这个的； 第二个要注意的点就是记得Base Case,记得要画DP表！ 同样要注意这里的第一个字符串对应的就是dp[1][1]！！！！！ 代码1234567891011121314151617class Solution &#123; public int longestCommonSubsequence(String text1, String text2) &#123; int[][] dp = new int[text1.length() + 1][text2.length() + 1]; for(int i = 1;i &lt;= text1.length();i++)&#123; for(int j = 1;j &lt;=text2.length();j++)&#123; if(text1.charAt(i-1) == text2.charAt(j-1))&#123; dp[i][j] = dp[i-1][j-1] + 1; &#125; else&#123; dp[i][j] = Math.max(dp[i-1][j],dp[i][j-1]); &#125; &#125; &#125; return dp[text1.length()][text2.length()]; &#125;&#125; 滑动窗口算法(示例:LeetCode第1143：最小覆盖子串问题) Tip：最重要的是过最后一个用例的艰辛，因为需要考虑到Integer是一个对象，超过-127~128之后会new一个新的对象，导致就算是值相等，其也会显示不相等！！！！！！！ 文章链接滑动窗口算法 代码文章中使用C++实现的，我是在LeetCode用的Java实现的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566class Solution &#123; public String minWindow(String s, String t) &#123; // 利用双指针的思想，先记录下t会出现的单词以及次数 // 然后右指针开始遍历，每当一个单词及其次数到位后，当前单词就匹配完成，直到所有单词都匹配完成 // 然后记录下当前的子串的开始和结尾，即左右指针的位置 // 然后开始试图移动左指针，当然前提是t中所有字符然后全部匹配完成，否则就跳出循环，继续走右边指针 // 直到右边指针走到底，如果走到底长度依旧没有，则说明找不到最小子串，返回"" 否则返回适当的子串 int left = 0,right = 0; //计算匹配的单词数量 int match = 0; //统计目标字符串的不同字符的个数 int nums = 0; int min_length = Integer.MAX_VALUE; int start = 0; char[] t_char = t.toCharArray(); char[] s_char = s.toCharArray(); HashMap&lt;Character, Integer&gt; windows = new HashMap&lt;Character, Integer&gt;(); HashMap&lt;Character,Integer&gt; tt = new HashMap&lt;Character, Integer&gt;(); // 用两个map来存储两个字符串，存储方式为key为单词，value为单词出现的数量 // for (char t1: t_char)&#123; if(tt.containsKey(t1)) &#123; int value = tt.get(t1).intValue(); tt.put(t1, ++value); &#125; else&#123; nums++; tt.put(t1,1); &#125; &#125; while(right &lt; s.length())&#123; if(windows.containsKey(s_char[right]))&#123; int windows_value = windows.get(s_char[right]).intValue(); windows.put(s_char[right],++windows_value); &#125; else&#123; windows.put(s_char[right],1); &#125; //如果全部符合要求 if(tt.containsKey(s_char[right]) &amp;&amp; windows.get(s_char[right]).intValue() == tt.get(s_char[right]).intValue())&#123; match++; &#125; right++; while(match == nums)&#123; //说明已经找到一个符合条件的了，记录下该字符串的起始和结束位置 int Len = right - left; if(Len &lt; min_length) &#123; min_length = Math.min(min_length,Len); start = left; &#125; int left_value = windows.get(s_char[left]).intValue(); left_value--; windows.put(s_char[left],left_value); if(tt.containsKey(s_char[left]) &amp;&amp; windows.get(s_char[left]).intValue() &lt; tt.get(s_char[left]).intValue())&#123; match--; &#125; left++; &#125; &#125; return min_length == Integer.MAX_VALUE ? "" : s.substring(start,min_length +start); &#125;&#125; 最大子序列和(LeetCode第53题)先总结一下，可以运用 dp 和 滑动窗口 两种方法！！！ 题目给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。 示例: 123输入: [-2,1,-3,4,-1,2,1,-5,4],输出: 6解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路 dp 要的是子串，必然可以用dp，而且是单子串且非回文，则必然使用一维dp数组 只要定义好了dp数组，这道题就没有任何难度，dp[i]定义为以i为索引的字符结尾的最大和 则dp[i] = Math.max(dp[i-1],nums[i])，然后取dp[i]中最大的即可！ 这题只有一个小难点，那就是找Base Case,好像并不存在Base Case,但是我们可以创造Base Case,可以令dp[0] = nums[0]，这样就有Base Case了，同时注意哈，这里不需要将dp数组的大小变为nums.length+1,因为这个题目不存在Base Case,所以dp只会产生n个数，不需要n+1个存储空间，像上文的dp二维数组，就存在BaseCase，当有一个为0时，有相应的取值！总而言之，一定要特别注意dp的数组大小以及BaseCase。 滑动窗口 比较简单的思路。就是sum如果大于0了，就移动右指针就行，如果是小于0了，就比较sum和num[i]，取最大值(相当于移动左指针)，直到循环结束。 代码 dp 12345678910111213class Solution &#123; public int maxSubArray(int[] nums) &#123; //res[i] = Math.max(res[i-1] + nums[i],nums[i]) int[] res = new int[nums.length]; res[0] = nums[0]; int max = res[0]; for(int i = 1;i &lt; nums.length;i++)&#123; res[i] = Math.max(res[i-1] + nums[i],nums[i]); max = Math.max(res[i],max); &#125; return max; &#125;&#125; 滑动窗口 1234567891011121314class Solution &#123; public int maxSubArray(int[] nums) &#123; int res = nums[0]; int sum = 0; for(int num:nums)&#123; if(sum &gt; 0) sum += num; else sum = num; res = Math.max(sum,res); &#125; return res; &#125;&#125; 打家劫舍 I、II、III (LeetCode第198、213、337)文章链接打家劫舍系列 I 的代码 自己写的(感觉写的有点啰嗦~) 123456789101112131415161718192021222324252627class Solution &#123; public int rob(int[] nums) &#123; int[] dp = new int[nums.length]; int res = 0; if(nums.length == 0 )&#123; return 0; &#125; if(nums.length == 1)&#123; dp[0] = nums[0]; res = dp[0]; return res; &#125; if(nums.length == 2)&#123; dp[1] = Math.max(nums[1],nums[0]); res = dp[1]; return res; &#125; dp[0] = nums[0]; dp[1] = Math.max(nums[1],nums[0]); for(int i = 2;i &lt; nums.length;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; res = Math.max(dp[nums.length-1],res) return res; &#125;&#125; 高分题解 123456789101112class Solution &#123; public int rob(int[] nums) &#123; int n = nums.length; if (n &lt;= 1) return n == 0 ? 0 : nums[0]; int[] memo = new int[n]; memo[0] = nums[0]; memo[1] = Math.max(nums[0], nums[1]); for (int i = 2; i &lt; n; i++) memo[i] = Math.max(memo[i - 1], nums[i] + memo[i - 2]); return memo[n - 1]; &#125;&#125; II 的代码分两次dp就好了，一次[0,nums.length-2]，一次[1,nums.length-1]，取最大值就好~ 12345678910111213141516171819202122232425262728293031class Solution &#123; public int rob(int[] nums) &#123; int[] dp = new int[nums.length]; int res = 0; if(nums.length == 0 )&#123; return 0; &#125; if(nums.length == 1)&#123; dp[0] = nums[0]; res = dp[0]; return res; &#125; if(nums.length == 2)&#123; dp[1] = Math.max(nums[1],nums[0]); res = dp[1]; return res; &#125; dp[0] = nums[0]; dp[1] = Math.max(nums[1],nums[0]); for(int i = 2;i &lt; nums.length-1;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; dp[1] = nums[1]; dp[2] = Math.max(nums[1],nums[2]); for(int i = 3;i &lt; nums.length;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; res = Math.max(dp[nums.length-1],dp[nums.length-2]); return res; &#125;&#125; III 的代码这是一个树形的dp问题，解决方法是采用一个一维数组，之前的I II只用到了dp[nums.length-1]，这里用到了两个,而且这里的dp竟然用了递归哟… Tip:特殊做法记忆记忆记忆！！！ 123456789101112131415161718192021222324252627282930/** * Definition for a binary tree node. * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public int rob(TreeNode root) &#123; int[] res = robIn(root); return Math.max(res[0],res[1]); &#125; private static int[] robIn(TreeNode root)&#123; //用一个数组记录偷根节点和不偷根节点两种情况，这里很特殊用了dp同时还搭配了递归 int[] res = new int[2]; if(root == null)&#123; return res; &#125; int[] left = robIn(root.left); int[] right = robIn(root.right); //偷根节点 res[0] = root.val + left[1] + right[1]; //不偷根节点 res[1] = Math.max(left[0],left[1]) + Math.max(right[0],right[1]); return res; &#125;&#125;]]></content>
      <categories>
        <category>程序员</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>LeetCode</tag>
        <tag>dp</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[想学的东西]]></title>
    <url>%2F2019%2F12%2F20%2F%E6%83%B3%E5%AD%A6%E7%9A%84%E4%B8%9C%E8%A5%BF.html</url>
    <content type="text"><![CDATA[dp 二叉树问题练习 链表问题集中练习 微服务 设计模式 java基础 面经spring常问的问题 并发、JVM]]></content>
  </entry>
  <entry>
    <title><![CDATA[SpringCloud 微服务笔记]]></title>
    <url>%2F2019%2F12%2F13%2FSpringCloud%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[微服务架构概述单体架构一个归档包(war格式)包含所有功能的应用程序，通常称为单体应用。 存在的问题： 复杂性高 技术债务(不坏不修) 部署频率低 可靠性差 扩展能力受限，不同模块可能需要的配置不一样，有的需要CPU好一点的，有的需要存储大一点的，不能根据业务模块的需要进行伸缩 阻碍技术创新，单体应用往往使用统一的技术平台或者方案解决所有的问题 微服务微服务架构风格：将一个单一应用程序开发为一组小型服务的方法，每个服务运行在自己的进程中，服务间通信采用轻量级通信机制，可通过全自动部署机制独立部署。这些服务共用一个最小型的集中式的管理，不同服务可以采用不同的语言开发，可以使用不同的数据存储技术。 特性 每个微服务可以独立运行在自己的进程中 每个服务为独立的业务开发 微服务通过类似于RESTful API等一些轻量级的通信机制进行通信 全自动的部署机制 优点 易于开发和维护 启动速度快 局部修改易部署 技术栈并不受限 按需伸缩 缺点 运维要求高，因为会有几十甚至上百个服务协作运行 分布式固有的复杂性 接口调整成本高 重复劳动 微服务设计原则 单一职责原则(SOLID原则之一) 服务自治原则。即每个微服务应具备独立的业务能力、依赖与运行环境。 轻量级通信机制。常用的有REST、AMQP、STOMP、MQTT等。 微服务粒度。这个比较难以控制，一般通过领域驱动设计(Domain Driven Design，DDD)中的限定上下文可作为划分微服务边界、确定微服务粒度。 微服务架构技术选型主流的解决方案是 SpringCloud、Dubbo 具体的框架对比：Dubbo VS SpringCloud 微服务开发框架——Spring CloudSpring Cloud 简介 并不是云计算解决方案，是在Spring Boot基础上用于快速构建分布式系统的通用模式的工具集 使用Spring Cloud开发的程序非常适合在Docker或者PaaS上部署,所以又叫云原生应用，云原生可理解为面向云环境的软件架构 云原生架构的方法论和最佳实践：12-factor Apps Tips： 云服务分为三类，分别是 IaaS(基础设施服务)、PaaS(平台服务)、SaaS(软件服务) 传送门：IaaS，PaaS，SaaS 的区别 Spring Cloud 和 Spring Boot 的联系首先，知乎上对这个有比较好的回答：Spring Cloud &amp; Spring Boot 总结一下说的比较好的： spring Cloud是一个基于Spring Boot实现的云应用开发工具，它为基于JVM的云应用开发中的配置管理、服务发现、断路器、智能路由、微代理、控制总线、全局锁、决策竞选、分布式会话和集群状态管理等操作提供了一种简单的开发方式。 spring boot 的优点是可以快速启动，快速构建应用程序，而不需要太多的配置文件。 spring cloud 是分布式开发的解决方案，基于spring boot,在spring boot做较少的配置，便可成为 spring cloud 中的一个微服务。 最基础的都是spring，然后在这个基础上spring boot做了一些自动配置和实现，然后又在spring boot的基础上加入了分布式负载均衡等功能，这才有了spring cloud。 Spring cloud是微服务开发套件。springboot=spring+springmvc，springcloud=springboot+ribbon+注册中心+熔断器+…等一系列组件。 Spring Cloud 特点 约定优于配置 隐藏了组件复杂性，并且提供声明式的配置方式 轻量级的组件，如Eureka、Zuul等 解耦，灵活 Spring Cloud 版本以SRX形式命名版本号，版本号前面会有一个 release train。 从以往的版本有Dalston、Edgware、Finchley、Greenwich，正在孵化的有SpringCloud Alibaba。 Spring Cloud 实战微服务(Finchley版本)概述Spring Cloud支持的插件众多，先来看一下Spring Cloud中文网提供的比较优秀的插件： Spring Cloud集成的相关优质项目推荐 Eureka：注册中心，云端服务发现，实现云端中间层服务发现和故障转移 Ribbon：负载均衡，可以有多种负载均衡的策略供选择，可配合Eureka和Hystrix使用 Hystrix：熔断器，容错管理工具，旨在通过熔断机制控制服务和第三方库的节点,从而对延迟和故障提供更强大的容错能力 Turbine：Turbine是聚合服务器发送事件流数据的一个工具，用来监控集群下hystrix的metrics情况（可视化） Feign：声明式、模块化的HTTP客户端，集成了负载均衡 Zuul：云平台上提供动态路由，监控，弹性，安全等边缘服务的框架。Zuul 相当于是设备和 Netflix 流应用的 Web 网站后端所有请求的前门 Config：配置管理工具包，让你可以把配置放到远程服务器，集中化管理集群配置，目前支持本地存储、Git以及Subversion Bus：事件、消息总线，用于在集群（例如，配置变化事件）中传播状态变化，可与Spring Cloud Config联合实现热部署 Sleuth：日志收集工具包，封装了Dapper和log-based追踪以及Zipkin和HTrace操作，为SpringCloud应用实现了一种分布式追踪解决方案 Stream：数据流操作开发包，封装了与Redis,Rabbit、Kafka等发送接收消息 Security：基于spring security的安全工具包，为你的应用程序添加安全控制 实例使用服务提供者与服务消费者来描述微服务之间的调用关系。下表解释了服务提供者与服务消费者。 ​ 表-服务提供者与服务消费者 名词 定义 服务提供者 服务的被调用方（即：为其他服务提供服务的服务） 服务消费者 服务的调用方（即：依赖其他服务的服务） 以电影售票系统为例。如图，用户向电影微服务发起了一个购票的请求。在进行购票的业务操作前，电影微服务需要调用用户微服务的接口，查询当前用户的余额是多少、是不是符合购票标准等。在这种场景下，用户微服务就是一个服务提供者，电影微服务则是一个服务消费者。 围绕该场景，先来编写一个用户微服务，然后编写一个电影微服务。 Eureka注册中心，云端服务发现，实现云端中间层服务发现和故障转移 不妨先思考一下，怎样才能让服务消费者总能找到服务提供者呢？或者说，怎样才能让服务消费者感知到服务提供者地址的变化呢？ TIPS 目前市面上把服务消费者找到服务提供者的这种机制称为服务发现，又或者服务注册。下面来探索服务发现究竟是怎么回事。 服务发现原理初探其实，服务发现机制非常简单，不妨用大家熟悉的MySQL来类比——只需一张表（图中的registry表）即可实现服务发现！ 如图，如果我们能在： 应用启动时，自动往registry表中插入一条数据，数据包括服务名称、IP、端口等信息。 应用停止时，自动把自己在registry表中的数据的status设为DOWN 。 这样，服务消费者不就永远都能找到服务提供者了嘛！当服务消费者想调用服务提供者接口时，只需向数据库发送SQL语句 SELECT * FROM registry where service_name = &#39;user&#39; and status = &#39;UP&#39; 即可找到服务提供者的所有实例！IP、端口啥的都有了，自己拼接一下，再去调用就行了！ TIPS 看，服务发现机制是不是很简单？程序猿给图中的”MySQL“的组件起了一个牛叉的名字叫：”注册中心“，也有的书将其称为”服务发现组件“。 但，这毕竟只是一个最简陋的服务发现原理。完整的服务发现要考虑的问题有很多，例如： 当服务抑或所在主机突然崩溃或者进入某种不正常的情况无法提供服务（例如应用的数据库挂了）时，对应的数据理应标记DOWN，或者索性删除； 如果每次调用之前，都得向服务发现组件发送类似SELECT * FROM registry where service_name = &#39;user&#39; and status = &#39;UP&#39; 的语句，那么服务发现组件的压力得有多大？更重要的，这与当下流行的去中心化设计的思想相悖； 服务发现组件即使挂掉，也不应该影响微服务之间的调用。 那么，一个完善的服务发现组件应该具备哪些能力呢？ 服务发现原理深入不妨来看一下使用服务发现组件后的架构图，如图所示。 服务提供者、服务消费者、服务发现组件这三者之间的关系大致如下： 各个微服务在启动时，将自己的网络地址等信息注册到服务发现组件中，服务发现组件会存储这些信息； 服务消费者可从服务发现组件查询服务提供者的网络地址，并使用该地址调用服务提供者的接口； 各个微服务与服务发现组件使用一定机制（例如心跳）通信。服务发现组件如长时间无法与某微服务实例通信，就会自动注销（即：删除）该实例； 当微服务网络地址发生变更（例如实例增减或者IP端口发生变化等）时，会重新注册到服务发现组件； 客户端缓存：各个微服务将需要调用服务的地址缓存在本地，并使用一定机制更新（例如定时任务更新、事件推送更新等）。这样既能降低服务发现组件的压力，同时，即使服务发现组件出问题，也不会影响到服务之间的调用。 综上，服务发现组件应具备以下功能。 服务注册表：服务注册表是服务发现组件的核心（其实就是类似于上面的registry表），它用来记录各个微服务的信息，例如微服务的名称、IP、端口等。服务注册表提供查询API和管理API，查询API用于查询可用的微服务实例，管理API用于服务的注册和注销； 服务注册与服务发现：服务注册是指微服务在启动时，将自己的信息注册到服务发现组件上的过程。服务发现是指查询可用微服务列表及其网络地址的机制； 服务检查：服务发现组件使用一定机制定时检测已注册的服务，如发现某实例长时间无法访问，就会从服务注册表中移除该实例。 用途将微服务的提供者和消费者都注册到Eureka服务器上，由Eureka服务器进行管理 源码分析Eureka原理分析 集成方式编写Eureka Server 加依赖 123456&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 加注解 1234567@SpringBootApplication@EnableEurekaServerpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 写配置 12345678910server: port: 8761eureka: client: # 是否要注册到其他Eureka Server实例 register-with-eureka: false # 是否要从其他Eureka Server实例获取数据 fetch-registry: false service-url: defaultZone: http://localhost:8761/eureka/ TIPS 这里，大家可先不去探究registerWithEureka 以及fetchRegistry 究竟是什么鬼，笔者将在下一节为大家揭晓。 将应用注册到Eureka Server上 加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 加注解 123456@SpringBootApplicationpublic class ProviderUserApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(ProviderUserApplication.class, args); &#125;&#125; 注意：早期的版本（Dalston及更早版本）还需在启动类上添加注解@EnableDiscoveryClient 或@EnableEurekaClient ，从Edgware开始，该注解可省略。 添加配置： 123456789101112spring: application: # 指定注册到eureka server上的服务名称，对于电影微服务，本系列将名称设为microservice-consumer-movie name: microservice-provider-usereureka: client: service-url: # 指定eureka server通信地址，注意/eureka/小尾巴不能少 defaultZone: http://localhost:8761/eureka/ instance: # 是否注册IP到eureka server，如不指定或设为false，那就会注册主机名到eureka server prefer-ip-address: true 测试 依次启动Eureka Server以及用户微服务、电影微服务； 访问http://localhost:8761 可观察到类似如下界面： 将用户微服务停止，可看到Eureka Server首页变成类似如下界面： Ribbon用途一般来说，提到负载均衡，大家一般很容易想到浏览器 -&gt; NGINX -&gt; 反向代理多个Tomcat这样的架构图——业界管这种负载均衡模式叫“服务器端负载均衡”，因为此种模式下，负载均衡算法是NGINX提供的，而NGINX部署在服务器端。 Nginx扫盲 本节所讲的Ribbon则是一个客户端侧负载均衡组件——通俗地说，就是集成在客户端（服务消费者一侧），并提供负载均衡算法的一个组件。 Ribbon默认为我们提供了很多的负载均衡算法，例如轮询、随机、响应时间加权等——当然，为Ribbon自定义负载均衡算法也非常容易，只需实现IRule 接口即可。 内置负载均衡的规则负载均衡规则是Ribbon的核心，下面来看一下Ribbon内置的负载均衡规则。 AvailabilityFilteringRule：过滤掉一直连接失败的被标记为circuit tripped的后端Server，并过滤掉那些高并发的后端Server或者使用一个AvailabilityPredicate来包含过滤server的逻辑，其实就就是检查status里记录的各个Server的运行状态； BestAvailableRule：选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过。 RandomRule：随机选择一个Server； ResponseTimeWeightedRule：作用同WeightedResponseTimeRule，二者作用一样； RetryRule：对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择Server不成功，则一直尝试使用subRule的方式选择一个可用的server； RoundRobinRule：轮询选择， 轮询index，选择index对应位置的Server； WeightedResponseTimeRule：根据响应时间加权，响应时间越长，权重越小，被选中的可能性越低； ZoneAvoidanceRule：复合判断Server所在区域的性能和Server的可用性选择Server； 如需自定义负载均衡规则，只需实现IRule 接口或继承AbstractLoadBalancerRule 、PredicateBasedRule即可 ，可参考RandomRule 、RoundRobinRule 、ZoneAvoidanceRule 等内置Rule编写自己的负载均衡规则。 引入Ribbon在Spring Cloud中，当Ribbon与Eureka配合使用时，Ribbon可自动从Eureka Server获取服务提供者地址列表，并基于负载均衡算法，选择其中一个服务提供者实例。下图展示了Ribbon与Eureka配合使用时的大致架构。 集成方式代码示例 复制项目microservice-consumer-movie ，将ArtifactId修改为microservice-consumer-movie-ribbon 。 加依赖：由于spring-cloud-starter-netflix-eureka-client 已经包含spring-cloud-starter-netfilx-ribbon ，故而无需额外添加依赖。 写代码： 12345@Bean@LoadBalancedpublic RestTemplate restTemplate() &#123; return new RestTemplate();&#125; 如代码所示，只需在RestTemplate 上添加LoadBalanced 注解，即可让RestTemplate整合Ribbon！ 调用： 1234567891011@GetMapping("/users/&#123;id&#125;")public User findById(@PathVariable Long id) &#123; // 这里用到了RestTemplate的占位符能力 User user = this.restTemplate.getForObject( "http://microservice-provider-user/users/&#123;id&#125;", User.class, id ); // ...电影微服务的业务... return user;&#125; 由代码可知，我们将请求的目标服务改成了http://microservice-provider-user/users/{id} ，也就是http://{目标服务名称}/{目标服务端点} 的形式，Ribbon会自动在实际调用时，将目标服务名替换为该服务的IP和端口。 测试 依次启动microservice-discovery-eureka 、microservice-provider-user 两个实例、microservice-consumer-movie-ribbon 访问http://localhost:8010/movies/users/1 多次，会发现两个user服务实例都会打印日志。 Feign简介Feign是Netflix开发的声明式、模板化的HTTP客户端，集成了 RestTemplate + Eureka + Ribbon + Hystrix 集成方式下面来将前面的例子用Feign改写，让其达到与Ribbon + RestTemplate相同的效果。 复制项目microservice-consumer-movie，将ArtifactId修改为microservice-consumer-movie-feign ； 加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt; 加注解：启动类上添加@EnableFeignClients ； 编写Feign Client： 12345@FeignClient(name = "microservice-provider-user")public interface UserFeignClient &#123; @GetMapping("/users/&#123;id&#125;") User findById(@PathVariable("id") Long id);&#125; 这样一个Feign Client就写完啦！其中，@FeignClient 注解中的microservice-provider-user是想要请求服务的名称，这是用来创建Ribbon Client的（Feign整合了Ribbon）。在本例中，由于使用了Eureka，所以Ribbon会把microservice-provider-user 解析成Eureka Server中的服务。 除此之外，还可使用url属性指定请求的URL（URL可以是完整的URL或主机名），例如@FeignClient(name = &quot;abcde&quot;, url = &quot;http://localhost:8000/&quot;) 。此时，name可以是任意值，但不可省略，否则应用将无法启动！ Controller： 1234567891011@RequestMapping("/movies")@RestControllerpublic class MovieController &#123; @Autowired private UserFeignClient userFeignClient; @GetMapping("/users/&#123;id&#125;") public User findById(@PathVariable Long id) &#123; return this.userFeignClient.findById(id); &#125;&#125; 只需使用@Autowire注解，即可注入上面编写的Feign Client。 RestTemplate与Feign对比相信通过本文的例子，聪明的你对如何使用Feign已经了然于心了。文章的最后，对比一下RestTemplate + Ribbon与Feign。 角度 RestTemplate + Ribbon Feign（自带Ribbon） 可读性、可维护性 欠佳（无法从URL直观了解这个远程调用是干什么的） 极佳（能在接口上写注释，方法名称也是可读的，能一眼看出这个远程调用是干什么的） 开发体验 欠佳（需要拼凑URL） 极佳（无需拼凑url，自动集合Eureka和Ribbon） 风格一致性 欠佳（本地API调用和RestTemplate调用的代码风格截然不同） 极佳（完全一致，不点开Feign的接口，根本不会察觉这是一个远程调用而非本地API调用） 性能 较好 中等（性能是RestTemplate的50%左右；如果为Feign配置连接池，性能可提升15%左右） 灵活性 极佳 中等（内置功能能满足大多数项目的需求） Hystrix容错技术的引入至此，我们已实现服务发现、负载均衡，同时，使用Feign也实现了良好的远程调用——我们的代码是可读、可维护的。理论上，我们现在已经能构建一个不错的分布式应用了，但微服务之间是通过网络通信的，网络可能出问题；微服务本身也不可能100%可用。 如何提升应用的可用性呢？这是我们必须考虑的问题—— 举个例子：某大型系统中，服务A调用服务B，某个时刻，微服务B突然崩溃了。微服务A中，依然有大量请求在请求B，如果没有任何措施，微服务A很可能很快就会被拖死——因为在Java中，一次请求往往对应着一个线程，如果不做任何措施，那意味着微服务A请求B的线程要等Feign Client/RestTemplate超时才会释放（这个时间一般非常长，长达几十秒），于是就会有大量的线程被阻塞，而线程又对应着计算资源（CPU/内存），于是乎，大量的资源被浪费，并且越积越多，最终服务器终于没有资源给微服务A浪费了，微服务A也挂了。 因此，在大型应用中，微服务之间的容错必不可少，下面来讨论如何实现微服务的容错。 容错三板斧 超时机制：一旦超时，就释放资源。由于释放资源速度较快，应用就不会那么容易被拖死。 舱壁模式：不把鸡蛋放在一个篮子里。你有你的线程池，我有我的线程池，你的线程池满了和我没关系，你挂了也和我没关系。 断路器：实时监测应用，如果发现在一定时间内失败次数/失败率达到一定阈值，就“跳闸”，断路器打开——此时，请求直接返回，而不去调用原本调用的逻辑。 跳闸一段时间后（例如15秒），断路器会进入半开状态，这是一个瞬间态，此时允许一次请求调用该调的逻辑，如果成功，则断路器关闭，应用正常调用；如果调用依然不成功，断路器继续回到打开状态，过段时间再进入半开状态尝试——通过”跳闸“，应用可以保护自己，而且避免浪费资源；而通过半开的设计，可实现应用的“自我修复“。 断路器状态转换 引入HystrixHystrix是由Netflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性。Hystrix主要通过以下几点实现延迟和容错。 包裹请求 使用HystrixCommand（或HystrixObservableCommand）包裹对依赖的调用逻辑，每个命令在独立线程中执行。这使用到了设计模式中的“ 命令模式 ”。 跳闸机制（断路器的应用） 当某服务的错误率超过一定阈值时，Hystrix可以自动或者手动跳闸，停止请求该服务一段时间。 资源隔离（舱壁模式的应用） Hystrix为每个依赖都维护了一个小型的线程池（或者信号量）。如果该线程池已满，发往该依赖的请求就被立即拒绝，而不是排队等候，从而加速失败判定。 监控（超时模式的应用） Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时、以及被拒绝的请求等。 回退机制 当请求失败、超时、被拒绝，或当断路器打开时，执行回退逻辑。回退逻辑可由开发人员自行提供，例如返回一个缺省值。 自我修复 断路器打开一段时间后，会自动进入“半开”状态。断路器打开、关闭、半开的逻辑转换，前面我们已经详细探讨过了，不再赘述。 通用方式使用Hystrix服务降级 加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 加注解：在启动类上添加@EnableCircuitBreaker 注解。 使用： 12345678910111213141516@HystrixCommand(fallbackMethod = "findByIdFallback")@GetMapping("/users/&#123;id&#125;")public User findById(@PathVariable Long id) &#123; // 这里用到了RestTemplate的占位符能力 User user = this.restTemplate.getForObject( "http://microservice-provider-user/users/&#123;id&#125;", User.class, id ); // ...电影微服务的业务... return user;&#125;public User findByIdFallback(Long id) &#123; return new User(id, "默认用户", "默认用户", 0, new BigDecimal(1));&#125; 由代码可知，只需使用@HystrixCommand 注解，就可保护该API。这里的”保护“，其实带有三层含义——”超时机制“、”仓壁模式“、”断路器“！ TIPS 本例使用了fallbackMethod 属性，指定了一个降级方法，如不指定，Hystrix会有一个默认的降级方案，那就是抛异常，哈哈哈。 如何知道断路器打开还是关闭呢？只需访问应用的/actuator/health 端点，即可查看！断路器的状态——当然，你必须添加如下配置： 1234management: endpoint: health: show-details: always 测试 启动microservice-discovery-eureka 启动microservice-provider-user 启动microservice-consumer-movie-ribbon-hystrix-common 访问http://localhost:8010/movies/users/1 ，能正常返回结果 关闭microservice-provider-user ，再次访问http://localhost:8010/movies/users/1 ，可返回类似如下结果，说明当服务提供者时，服务消费者进入了回退方法。 1&#123;"id":1,"username":"默认用户","name":"默认用户","age":0,"balance":1&#125; 访问http://localhost:8010/actuator/health ，可获得类似如下结果： 1234567891011&#123; "status": "UP", "details": &#123; "diskSpace": ..., "refreshScope": ..., "discoveryComposite": ..., "hystrix": &#123; "status": "UP" &#125; &#125;&#125; 由结果不难发现，此时断路器并未打开！这是为什么呢？ 原因是：此时只请求了一次，没有达到Hystrix的阈值——Hystrix设计来保护高并发应用的，它要求10秒（可用hystrix.command.default.metrics.rollingStats.timeInMilliseconds 自定义）以内API错误次数超过20次（用circuitBreaker.requestVolumeThreshold 自定义），此时才可能触发断路器。 持续不断地访问http://localhost:8010/movies/users/1 多次（至少20次） 再次访问http://localhost:8010/actuator/health ，可获得类似如下结果： 1234567891011121314&#123; "status": "UP", "details": &#123; "diskSpace": ..., "refreshScope": ..., "discoveryComposite": ..., "hystrix": &#123; "status": "CIRCUIT_OPEN", "details": &#123; "openCircuitBreakers": ["MovieController::findById"] &#125; &#125; &#125;&#125; 由结果可知，此时断路器已经打开，并且列出了是哪个API的断路器被打开了。 获得造成fallback的原因在实际项目中，很可能需要获得造成fallback的原因，此时可将代码修改为如下： 1234567891011121314151617@HystrixCommand(fallbackMethod = "findByIdFallback")@GetMapping("/users/&#123;id&#125;")public User findById(@PathVariable Long id) &#123; // 这里用到了RestTemplate的占位符能力 User user = this.restTemplate.getForObject( "http://microservice-provider-user/users/&#123;id&#125;", User.class, id ); // ...电影微服务的业务... return user;&#125;public User findByIdFallback(Long id, Throwable throwable) &#123; log.error("进入回退方法", throwable); return new User(id, "默认用户", "默认用户", 0, new BigDecimal(1));&#125; Feign 整合 Hystrix默认Feign是不启用Hystrix的，如果需要启用，只需要在配置文件中配置即可： 123feign: hystrix: enabled: true Hystrix Command 详解监控端点与数据应用整合Hystrix，同时应用包含spring-boot-starter-actuator 依赖，就会存在一个/actuator/hystrix.stream 端点，用来监控Hystrix Command。当被@HystrixCommand 注解了的方法被调用时，就会产生监控信息，并暴露到该端点中。当然，该端点默认是不会暴露的，需使用如下配置将其暴露。 12345management: endpoints: web: exposure: include: 'hystrix.stream' 此时，访问/actuator/hystrix.stream 可返回如下结果： 1&#123;"type":"HystrixCommand","name":"findById","group":"MovieController","currentTime":1547905939151,"isCircuitBreakerOpen":false,"errorPercentage":0,"errorCount":0,"requestCount":0,"rollingCountBadRequests":0,"rollingCountCollapsedRequests":0,"rollingCountEmit":0,"rollingCountExceptionsThrown":0,"rollingCountFailure":0,"rollingCountFallbackEmit":0,"rollingCountFallbackFailure":0,"rollingCountFallbackMissing":0,"rollingCountFallbackRejection":0,"rollingCountFallbackSuccess":0,"rollingCountResponsesFromCache":0,"rollingCountSemaphoreRejected":0,"rollingCountShortCircuited":0,"rollingCountSuccess":0,"rollingCountThreadPoolRejected":0,"rollingCountTimeout":0,"currentConcurrentExecutionCount":0,"rollingMaxConcurrentExecutionCount":0,"latencyExecute_mean":0,"latencyExecute":&#123;"0":0,"25":0,"50":0,"75":0,"90":0,"95":0,"99":0,"99.5":0,"100":0&#125;,"latencyTotal_mean":0,"latencyTotal":&#123;"0":0,"25":0,"50":0,"75":0,"90":0,"95":0,"99":0,"99.5":0,"100":0&#125;,"propertyValue_circuitBreakerRequestVolumeThreshold":20,"propertyValue_circuitBreakerSleepWindowInMilliseconds":5000,"propertyValue_circuitBreakerErrorThresholdPercentage":50,"propertyValue_circuitBreakerForceOpen":false,"propertyValue_circuitBreakerForceClosed":false,"propertyValue_circuitBreakerEnabled":true,"propertyValue_executionIsolationStrategy":"THREAD","propertyValue_executionIsolationThreadTimeoutInMilliseconds":1000,"propertyValue_executionTimeoutInMilliseconds":1000,"propertyValue_executionIsolationThreadInterruptOnTimeout":true,"propertyValue_executionIsolationThreadPoolKeyOverride":null,"propertyValue_executionIsolationSemaphoreMaxConcurrentRequests":10,"propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests":10,"propertyValue_metricsRollingStatisticalWindowInMilliseconds":10000,"propertyValue_requestCacheEnabled":true,"propertyValue_requestLogEnabled":true,"reportingHosts":1,"threadPool":"MovieController"&#125; 对于Feign前面讲过Feign默认已经整合了Hystrix，但这个整合其实是“不完整”，因为它默认不带有监控端点，如果你在使用Feign的同时，也想使用监控端点，需按照如下步骤操作： 加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类上添加注解@EnableCircuitBreaker 在application.yml 中添加如下配置： 12345management: endpoints: web: exposure: include: 'hystrix.stream' 可视化监控数据至此，我们已可通过/actuator/hystrix.strem 端点观察Hystrix运行情况，但文字形式的监控数据很不直观。现实项目中一般都需要一个可视化的界面，这样才能迅速了解系统的运行情况。Hystrix提供了一个轮子——Hystrix Dashboard，它的作用只有一个，那就是将文字形式的监控数据转换成图表展示。 编写Hystrix Dashboard 加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;&lt;/dependency&gt; 加注解：@EnableHystrixDashboard 写配置： 123# 端口随便写，这里只是表明下自己的端口规划而已server: port: 8030 启动后，访问http://localhost:8030/hystrix 即可看到类似如下的界面： 将上文的/actuator/hystrix.stream 端点的地址贴到图中，并指定Title，然后点击Monitor Stream 按钮，即可看到类似如下的图表： 图表解读Turbine Turbine上文的Hystrix Dashboard只支持一次监控一个微服务实例，显然是不能满足需求的，所以为了能监控多个微服务，Netflix官方再次发挥造轮子的精神——它们又编写了一个组件，Turbine。 不过这个项目刚出生就死了，14年发布后就再也没有进行更新维护。 简介Turbine是一个聚合Hystrix监控数据的工具，它可将所有相关/hystrix.stream端点的数据聚合到一个组合的/turbine.stream中，从而让集群的监控更加方便。 引入Turbine后，架构图如下： 引入Turbine编写Turbine Server 加依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-turbine&lt;/artifactId&gt;&lt;/dependency&gt; 加注解：@EnableTurbine 写配置： 123456789101112131415server: port: 8031spring: application: name: microservice-hystrix-turbineeureka: client: service-url: defaultZone: http://localhost:8761/eureka/ instance: prefer-ip-address: trueturbine: # 要监控的微服务列表，多个用,分隔 appConfig: microservice-consumer-movie,microservice-consumer-movie-feign clusterNameExpression: "'default'" 测试这样，Tubine即可聚合microservice-consumer-movie,microservice-consumer-movie-feign两个服务的/actuator/hystrix.stream 信息，并暴露在http://localhost:8031/turbine.stream ，将该地址贴到Hystrix Dashboard上，即可看到类似如下的图表： Zuul]]></content>
      <tags>
        <tag>SpringCloud</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态规划笔记]]></title>
    <url>%2F2019%2F12%2F09%2F%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[递归、递推 递归 自顶向下 递推 自底向上 动态规划题的一般思路 先写出递归思路 然后剪枝(前面二者都是自上而下) 然后写出dp(不同于剪枝的是 dp是自底向上) dp问题核心是穷举，dp特点是存在 重叠子问题 最优子结构 然后只要在此基础上列出 状态转移方程 即可 动态规划的三要素： 重叠子问题 最优子结构 状态转移方程 思维框架： 明确「状态」 -&gt; 定义 dp 数组/函数的含义 -&gt; 明确「选择」-&gt; 明确 base case。]]></content>
  </entry>
  <entry>
    <title><![CDATA[jvm笔记]]></title>
    <url>%2F2019%2F12%2F04%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%94%E8%AE%B0.html</url>
    <content type="text"><![CDATA[第二章 Java内存区域与内存溢出异常OutOfMemoryError异常包括 Java堆溢出、虚拟机栈和本地方法栈溢出、方法区和运行时常量池溢出、本地直接内存溢出。 运行时数据区域包括 方法区、堆（前两者都是共享的）、虚拟机栈、本地方法栈、程序计数器（三者是线程私有）。 方法区：与Java堆一样，是各个线程共享的内存区域，用于存储已被虚拟机加载的类信息、常量、静态变量，别名称为Non-Heap。 堆：Java Heap是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，此内存区域的唯一目的是存放对象实例，同时Java堆是垃圾收集管理的主要区域，很多时候也被称为GC堆。 虚拟机栈：描述的是Java方法执行的内存模型，即每个方法会在执行的同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。经常有人把Java内存分为堆内存和栈内存，这里的栈内存就是指的虚拟机栈。 本地方法栈：与虚拟机栈发挥的功能基本一致，区别不过是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务。 程序计数器：一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。 运行时常量池：方法区的一部分。常量池（用于存放编译期生成的各种字面量和符号引用）。 直接内存：并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。 Xms Xmx PermSize MaxPermSize 区别1.参数的含义-vmargs -Xms128M -Xmx512M -XX:PermSize=64M -XX:MaxPermSize=128M-vmargs 说明后面是VM的参数，所以后面的其实都是JVM的参数了-Xms128m JVM初始分配的堆内存-Xmx512m JVM最大允许分配的堆内存，按需分配-XX:PermSize=64M JVM初始分配的非堆内存-XX:MaxPermSize=128M JVM最大允许分配的非堆内存，按需分配 我们首先了解一下JVM内存管理的机制，然后再解释每个参数代表的含义。 1)堆(Heap)和非堆(Non-heap)内存 按照官方的说法：“Java 虚拟机具有一个堆，堆是运行时数据区域，所有类实例和数组的内存均从此处分配。堆是在 Java 虚拟机启动时创建的。”“在JVM中堆之外的内存称为非堆内存(Non-heap memory)”。 可以看出JVM主要管理两种类型的内存：堆和非堆。简单来说堆就是Java代码可及的内存，是留给开发人员使用的；非堆就是JVM留给自己用的， 所以方法区、JVM内部处理或优化所需的内存(如JIT编译后的代码缓存)、每个类结构(如运行时常数池、字段和方法数据)以及方法和构造方法的代码都在非堆内存中。 堆内存分配 JVM初始分配的堆内存由-Xms指定，默认是物理内存的1/64；JVM最大分配的堆内存由-Xmx指定，默认是物理内存的1/4。默认空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制； 空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。因此服务器一般设置-Xms、-Xmx 相等以避免在每次GC 后调整堆的大小。 说明：如果-Xmx 不指定或者指定偏小，应用可能会导致java.lang.OutOfMemory错误，此错误来自JVM，不是Throwable的，无法用try…catch捕捉。 非堆内存分配 JVM使用-XX:PermSize设置非堆内存初始值，默认是物理内存的1/64；由XX:MaxPermSize设置最大非堆内存的大小，默认是物理内存的1/4。（还有一说：MaxPermSize缺省值和-server -client选项相关， -server选项下默认MaxPermSize为64m，-client选项下默认MaxPermSize为32m。这个我没有实验。） 上面错误信息中的PermGen space的全称是Permanent Generation space，是指内存的永久保存区域。还没有弄明白PermGen space是属于非堆内存，还是就是非堆内存，但至少是属于了。XX:MaxPermSize设置过小会导致java.lang.OutOfMemoryError: PermGen space 就是内存益出。说说为什么会内存益出：（1）这一部分内存用于存放Class和Meta的信息，Class在被 Load的时候被放入PermGen space区域，它和存放Instance的Heap区域不同。（2）GC(Garbage Collection)不会在主程序运行期对PermGen space进行清理，所以如果你的APP会LOAD很多CLASS 的话,就很可能出现PermGen space错误。 这种错误常见在web服务器对JSP进行pre compile的时候。 补充： 如果你的WEB APP下都用了大量的第三方jar，其大小超过了服务器jvm默认的大小，那么就会产生内存益出问题了。解决方法： 设置MaxPermSize大小可以在myelipse里选中相应的服务器比如tomcat5，展开里面的JDK子项页面，来增加服务器启动的JVM参数设置：-Xms128m-Xmx256m-XX:PermSize=128M-XX:MaxNewSize=256m-XX:MaxPermSize=256m或者手动设置MaxPermSize大小,比如tomcat，修改TOMCAT_HOME/bin/catalina.bat，在echo “Using CATALINA_BASE: $CATALINA_BASE”上面加入以下行：JAVA_OPTS=”-server -XX:PermSize=64M -XX:MaxPermSize=128m]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>jvm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[十大内部排序]]></title>
    <url>%2F2019%2F10%2F27%2F%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[前言最近一直比较忙，马上就要考试了，所以LeetCode稍微暂时放了放，集中精力回顾了下内部排序算法，本篇文章会对常见的十大内部排序算法进行系统的回顾。 概述算法分类常见排序算法可以分为两大类： 比较排序：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。 非比较类排序：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 算法复杂度 部分补充 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。 不稳定排序算法：谐音记忆法：快（快排） 些（希尔）选（选择）对（堆）。 总共4个不稳定，6个稳定。 冒泡排序基本思想冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 算法描述 一次比较两个数字，两两比较，如果前者比后者大，则交换，以此类推，一轮下来，就会产生一个最大的数； 当某一轮没有产生任何一次交换，则说明冒泡完成。 动图演示 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344package 排序;import JAVA_I_O.Buffer.BufferedInputStream;import java.util.ArrayList;import java.util.Arrays;import java.util.Scanner;//测试类public class SortTest &#123; public static void main(String[] args) throws Exception &#123; System.out.println("请输入一个数组，用逗号分隔："); Scanner sc = new Scanner(System.in); String next = sc.nextLine(); String[] net = next.split(",");// String[] arr = Arrays.copyOf(net,net.length);// int[] arr = new int[0]; ArrayList&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;(); for (int i = 0 ; i &lt; net.length ; i++) &#123; arrayList.add(Integer.parseInt(net[i]));// System.out.println(arr[i]); &#125; int size = arrayList.size(); Integer[] arrInt = arrayList.toArray(new Integer[size]); int[] arr = new int[size]; for(int i = 0 ; i &lt; arrInt.length;i++)&#123; arr[i] = arrInt[i]; &#125;// System.out.println(arr[i]);// int[] InsertSortArray = Sort.InsertSort(arr);// int[] SelectSortArray = Sort.SelectSort(arr); Sort.BubbleSort(arr);// int[] ShellSortArray = Sort.ShellSort2(arr);// Sort.quickSort(arr,0,arr.length-1);// Sort.heapSort(arr,arr.length-1);// Sort.courtSort(arr);// Sort.BucketSort(arr);// Sort.radixSort(arr);// for (int i = 0 ; i &lt; ShellSortArray.length ; i++) &#123;// System.out.print(ShellSortArray[i] + " ");// &#125; &#125;&#125; 1234567891011121314151617181920212223242526272829 /** * 冒泡 * * @param sortArray 原始数组 * @return 排序数组 */public static void BubbleSort(int[] sortArray) &#123; //复制一份原始数组，用于排序操作 int[] arr = Arrays.copyOf(sortArray, sortArray.length); //循环n-1轮，剩最后一个就不需要交换了 for (int i = 1; i &lt; arr.length; i++) &#123; //标志位，当一轮下来没有任何变化时，说明冒泡结束，需要结束循环 boolean flag = true; //每一轮都要两两比较，注意每一轮结束都会确认一个值在正确的位置上，所以j的遍历次数得稍加注意 for (int j = 0; j &lt; arr.length - i; j++) &#123; //位置变化的同时说明冒泡没有结束 if (arr[j] &gt; arr[j + 1]) &#123; int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; flag = false; &#125; &#125; if (flag) &#123; break; &#125; &#125; System.out.println(Arrays.toString(arr));&#125; 算法效率 时间复杂度：很明显，看代码就知道，冒泡有两个for循环，所以一般情况下和最坏情况下的复杂度都为O(n²)，最好的时间复杂度就是一次冒泡就完成了，即为O(n); 空间复杂度：在冒泡中，只用了temp来存储中间变量交换，没有用到其他空间(我的代码中的复制初始数组的容量其实可以省去)，所以空间复杂度是O(1); 稳定性：交换过程中，如果相邻两者的值一样，则不会交换，所以明显冒泡排序是稳定的。 tips 外循环 n-1次； 注意添加标志位，判断冒泡是否结束； 注意内部循环的次数，每外部循环结束一次，就确定一个数的最终位置。 快速排序基本思想快速排序（Quicksort）是对冒泡排序的一种改进，借用了分治的思想，由C. A. R. Hoare在1962年提出。它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 算法描述 首先选定一个基准值（pivot），我一般的做法是选定最左边的作为基准； 定义两个指针，一个指向最右边，一个指向最左边，然后注意让右边的先动，等右边指针所指的数值小于pivot时，右边指针不再往左走，不准动了，然后移动左边指针，等左边指针所指向的数值大于pivot时，左边指针停下，不再向右移动，然后二者交换； 交换完毕后，重复第二步，右边指针继续向左，重复； 直到左右两个指针相遇，两个都停下，将指向的数值和pivot交换，至此数组就分成了两个子数组，pivot左侧比其小，右边比其大； 然后递归子数组，直到子数组为0（low &gt; high）。 动图演示 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 快速排序 * 后续所有测试都跟冒泡那章写的一样 * @param sortArray 原始数组 * @param low 最左侧 * @param high 最右侧 */public static void quickSort(int[] sortArray, int low, int high) &#123; //当low = high 时，说明子数组只剩一个数了，还排个锤子啊 if (low &lt; high) &#123; //拿到基准值，这样就可以愉快的递归了 int pivot = partition(sortArray, low, high); //注意哦，递归时可没有把pivot放入其中 quickSort(sortArray, low, pivot - 1); quickSort(sortArray, pivot + 1, high); System.out.println(Arrays.toString(sortArray)); &#125;&#125;/** * 快排主思路 * @param sortArray * @param low * @param high * @return */private static int partition(int[] sortArray, int low, int high) &#123; //我个人习惯是把最左边定为基准值，具体方法有很多啦，随便你，爱咋咋的 int pivot = low; //定义左右两指针 int p = low; int q = high; //相遇就结束了哈，然后直接交换基准和指向的数值就行咯 while (p &lt; q) &#123; //没相遇并且右指针指向的值比基准值大，就向左移动，若比基准值小，那就得停下 while (p &lt; q &amp;&amp; sortArray[pivot] &lt;= sortArray[q]) q--; while (p &lt; q &amp;&amp; sortArray[pivot] &gt;= sortArray[p]) p++; //都停下了就交换叭！ swap(sortArray, p, q); &#125; swap(sortArray, pivot, p); //不要忘记最后要返回这个基准值 return p;&#125;public static void swap(int[] sum, int i, int j) &#123; int temp = sum[i]; sum[i] = sum[j]; sum[j] = temp;&#125; 算法效率快排嘛，用了分治的思想咯，所以复杂度肯定是比冒泡低的，至于是多少，我们稍加分析一下： 时间复杂度：分治思想，但是绝壁不是线性的，因为它一轮下来搞来搞去，交换这交换那的，所以一轮是logN,n轮下来就是nlogN了。我说的是最好情况和平均情况哈，最坏那肯定还是O(n²)，因为可能你很不幸，基准值就是最大的，然后就得疯狂交换。 空间复杂度：不瞎的都看得出来，就用了一个temp中间变量用来存值，所以是O(1) 。 稳定性：哎呀肯定是不稳定的啊，两个指针在那换来换去，能稳定嘛… tips 注意递归时的子串是不包括pivot的，一个是(low,pivot-1)，一个是(pivot+1,high)； 两个指针相遇，不用判断和pivot值的大小，直接交换即可，因为两个指针只会有一个在移动，那么此时此刻另一个指针一定是静止的，假如此时是右边的指针移动，那么相遇的位置即左指针停下的位置，而左指针停下说明之前右边指针也停下来过并且和左边指针指向的数进行了交换(因为只有右边停下，左边才能移动)，那么此时左边指向的数是一定比pivot小的，所以必然可以直接交换，换个角度考虑也是一样的。 还有，我一直强调必须右指针先动(其实只要是和基准相反方向的指针先动就行)，为什么捏，因为嘛，给你举个例子吧，假如有这样一个数组 9,3,4,5,6,7,10 ,左边的先动那就凉了啊，因为最后你都定在10，一叫换就变成了10,3,4,5,6,7,9，这还玩个锤子啊———–&gt; 快排从右边开始的原因 至于快排的优化，网上到处都是，懒得写了… 到时候需要再说。 简单插入排序基本思想看名字叭，插入，还尼玛简单插入，顾名思义，就是把这个待排序数组看成是一步步插好的数组，用的是最简单的方法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。 算法描述一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下： 从第一个元素开始，该元素可以认为已经被排序； 取出下一个元素，在已经排序的元素序列中从后向前扫描； 如果该元素（已排序）大于新元素，将该元素移到下一位置； 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置； 将新元素插入到该位置后； 重复步骤2~5。 注：啥是in-place知道不：原地算法) 动图演示 代码实现1234567891011121314151617181920212223/** * 直接插入排序 * 我没有in-place哈，但是是可以的 * @param SortArray 原始数组 * @return 排序数组 */ public static void InsertSort(int[] SortArray) &#123; int[] arr = Arrays.copyOf(SortArray, SortArray.length); //从1开始哦，因为第一个数默认是排好序的啦 for (int i = 1; i &lt; arr.length; i++) &#123; int temp = arr[i]; int j = i; for (; (j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp); j--) &#123; //这一步最关键，因为要注意每当插入一个数字，其后面都要往后顺移一位，不然的话就空不出要插入的位置！！！ arr[j] = arr[j - 1]; &#125; //如果没有变化，则temp依然等于arr[i],如果变化，则将arr[i]移动过来就行 //注意不能直接arr[j] = arr[i]哦，因为此时的i索引值已经可能变化啦！！！！temp非常的关键！！ arr[j] = temp; &#125; System.out.println(Arrays.toString(arr)); &#125; 算法效率 时间复杂度：这种直接插入麻烦的一笔，如果是原数组是倒序，那每一轮都得疯狂插，毫无疑问最坏情况下的时间复杂度是O(n²)，最好的时间复杂度就是一次都不用给后来者让位，那么就是线性复杂度了O(n)，平均下来依旧是O(²)。 空间复杂度：in-place,O(1) 。 稳定性：当然是稳定的啦！ tips 注意插入的时候是将比插入的数大的已经排序好的数全部后移一位哦！！！给朕让位的赶脚… 用temp来保存当前需要插入的数据是非常重要的，这也是插入排序唯二需要注意的地方，还要一个需要注意的地方就是全部后移一位。 希尔排序基本思想希尔排序又叫缩小增量排序，1959年Shell发明。是插入排序的一种高速而稳定的改进版本。 希尔排序是先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。 算法描述希尔排序有n种步长方式，这里介绍两种，一种是循环折半，另一种是 gap = gap * 3 + 1。 具体：希尔排序增量序列介绍 。 先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述： 选择一个增量序列t1，t2，…，tk，其中ti&gt;tj，tk=1； 按增量序列个数k，对序列进行k 趟排序； 每趟排序，根据对应的增量ti，将待排序列分割成若干长度为m 的子序列，分别对各子表进行直接插入排序。仅增量因子为1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 动图演示 代码实现1234567891011121314151617181920212223/*** 其实就是将直接插入排序的间隔1变为更大，也就是其实就多了一个循环，就是多次缩小间隔的循环，其他跟直接插入是一样的** @param sortArray* @return*/ public static int[] ShellSort2(int[] sortArray) &#123; int[] arr = Arrays.copyOf(sortArray, sortArray.length); int size = sortArray.length; for (int increment = size / 2; increment &gt; 0; increment /= 2) &#123; for (int i = increment; i &lt; size; i++) &#123; int temp = arr[i]; int j = i; for (; (j &gt; 0 &amp;&amp; arr[j - increment] &gt; temp); j -= increment) &#123; //这一步最关键，因为要注意每当插入一个数字，其后面都要往后顺移increment位，不然的话就空不出要插入的位置！！！ arr[j] = arr[j - increment]; &#125; //如果没有变化，则temp依然等于arr[i],如果变化，则将arr[i]移动过来就行 arr[j] = temp; &#125; &#125; return arr; &#125; 12345678910111213141516171819202122232425262728293031 /** * 不是我写的 * * @param sourceArray * @return * @throws Exception */public static int[] ShellSort1(int[] sourceArray) throws Exception &#123; // 对 arr 进行拷贝，不改变参数内容 int[] arr = Arrays.copyOf(sourceArray, sourceArray.length); int gap = 1; while (gap &lt; arr.length) &#123; gap = gap * 3 + 1; &#125; while (gap &gt; 0) &#123; for (int i = gap; i &lt; arr.length; i++) &#123; int tmp = arr[i]; int j = i; for (; j &gt;= 0 &amp;&amp; arr[j - gap] &gt; tmp; j -= gap) &#123; arr[j] = arr[j - gap]; &#125; arr[j] = tmp; &#125; gap = (int) Math.floor(gap / 3); &#125; return arr;&#125; 算法效率 时间复杂度：最坏和最好我们都知道，这个就跟直接插入没区别，最好最坏都是取决于原数组序列，所以最好的时间复杂度依旧是O(n)，最坏的时间复杂度依旧是O(n²)，平均复杂度？我tm也不知道为啥，记住就是啦，O(n^1.3)。 空间复杂度：这个简单的一批，还不就是O(1)。 稳定性：这种跳跃性的当然是不稳定了。例如arr = {3,2,2}。 tips简单的一批…不就是把直接插入的1变成 increment 嘛 …… 没啥需要注意的！ 啊！！！不对，其实还是有一个需要注意的！！！ 这里是三重循环，因为那个步长要变化，然后不同步长都要进行排序，一次排序是两重循环 over 简单选择排序基本思想选择排序，意在突出选择 二字，所以我们要做的就是有一个选择的过程，至于简单选择，简而言之就是非常非常简单的选择排序，那不就是每次都找个最小值往前扔嘛… 选择排序(Selection-sort)是一种简单直观的排序算法。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 算法描述n个记录的直接选择排序可经过 n-1 趟直接选择排序得到有序结果。具体算法描述如下：(这么官方肯定是复制的啦哈哈哈哈哈) 初始状态：无序区为R[1..n]，有序区为空； 第i趟排序(i=1,2,3…n-1)开始时，当前有序区和无序区分别为R[1..i-1]和R(i..n）。该趟排序从当前无序区中-选出关键字最小的记录 R[k]，将它与无序区的第1个记录R交换，使R[1..i]和R[i+1..n)分别变为记录个数增加1个的新有序区和记录个数减少1个的新无序区；(这种屁话读起来简直就是浪费生命) n-1趟结束，数组有序化了。 注：就是说 ——– 每次遍历数组都选一个最小的扔到最前面（跟要扔的位置的数进行交换），然后从剩下的还没排序的继续遍历，继续扔，扔了n-1次就结束了叭。 动图演示 代码实现1234567891011121314151617181920212223242526272829/** * 简单选择排序 * * @param SortArray 原始数组 * @return 排序数组 */public static int[] SelectSort(int[] SortArray) &#123; int[] arr = Arrays.copyOf(SortArray, SortArray.length); //注意是n-1轮，一轮一个最小值，最后那个不用轮了 for (int i = 0; i &lt; arr.length - 1; i++) &#123; //最开始默认第一个是最小的，然后进入内层循环，分别进行比较，一定要记录下min的下标，这是最后比较完交换的关键 //每一次循环的目的就是找到一个最小值，然后与当前外部循环的值进行一个交换 int min = i; for (int j = i + 1; j &lt; arr.length; j++) &#123; //min = Math.min(min,arr[j]); if (arr[min] &gt; arr[j]) &#123; min = j; &#125; &#125; //判断是否需要交换 if (i != min) &#123; int temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125; &#125; return arr;&#125; 算法效率必须要吐槽的是，这个直接选择排序是垃圾中的战斗机，因为它无视任何数组，干啥都是废物的O(n²)时间复杂度！！！！！！！ 时间复杂度：O(n²) ； 空间复杂度：O(1) ； 稳定性：当然是不稳定的了，涉及到瞎鸡儿交换（不临近）的，就肯定不稳定的啦。 tips没啥注意点，就是非常的垃圾，不要用… 堆排序基本思想这个牛逼勒，我个人最欣赏这个，因为java中的PriorityQueue用了堆排序…在做k个有序链表合并等问题时，用PriorityQueue简直就是神器啊… 堆排序的基本思想是：将待排序序列构造成一个大顶堆，此时，整个序列的最大值就是堆顶的根节点。将其与末尾元素进行交换，此时末尾就为最大值。然后将剩余n-1个元素重新构造成一个堆，这样会得到n个元素的次小值。如此反复执行，便能得到一个有序序列了。 算法描述 将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆; 将堆顶元素与末尾元素交换，将最大元素”沉”到数组末端; 重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。 动图演示 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 /** * 堆排序 * * @param sortArray * @param len 注意这里是arr.length，跟之前不一样，堆排序是从1开始的 */ public static void heapSort(int[] sortArray, int len) &#123; //建立大根堆 BuildMaxHeap(sortArray, len); //每次都将根取出，然后将最底下的放到根，然后进行堆调整 for (int i = len; i &gt; 0; i--) &#123; swap(sortArray, i, 0);// AdjustDown(sortArray,0,i-1); AdjustDown2(sortArray, 0, i - 1); &#125; System.out.println(Arrays.toString(sortArray)); &#125; /** * 先写一个递归的，比较好理解 * * @param sortArray * @param i * @param len */ private static void AdjustDown(int[] sortArray, int i, int len) &#123; //注意这里的len是length-1，然后根的序号是1，所以left是2i+1 int left = 2 * i + 1; int right = 2 * i + 2; int largest = i; if (left &lt;= len &amp;&amp; sortArray[left] &gt; sortArray[largest]) largest = left; if (right &lt;= len &amp;&amp; sortArray[right] &gt; sortArray[largest]) largest = right; if (largest != i) &#123; swap(sortArray, largest, i); AdjustDown(sortArray, largest, len); &#125; &#125; /** * 写一个非递归的吧，注意哈，这里的len是length-1，跟上面的一样 * * @param sortArray * @param i * @param len */ private static void AdjustDown2(int[] sortArray, int i, int len) &#123; int t = i; for (int m = 2 * i + 1; m &lt;= len; m = t * 2 + 1) &#123; if (sortArray[m] &gt; sortArray[t]) t = m; if (m + 1 &lt;= len &amp;&amp; sortArray[m + 1] &gt; sortArray[t]) t = m + 1; if (t == i) break; else &#123; swap(sortArray, t, (m - 1) / 2); i = (m - 1) / 2; &#125; &#125; &#125; private static void BuildMaxHeap(int[] sortArray, int len) &#123; double lens = len; //注意是从lens/2开始 for (int i = (int) Math.round((lens / 2)) - 1; i &gt;= 0; i--) &#123;// System.out.println(i);// AdjustDown(sortArray,i,len); AdjustDown2(sortArray, i, len); &#125; &#125; 算法效率 时间复杂度：平均时间、最坏和最好情况下都一样，都是O(nlogn) 。 建立堆的过程, 从length/2 一直处理到0, 时间复杂度为O(n); 调整堆的过程是沿着堆的父子节点进行调整, 执行次数为堆的深度, 时间复杂度为O(lgn); 堆排序的过程由n次第②步完成, 时间复杂度为O(nlgn)。 空间复杂度：O(1)。 稳定性：由于堆排序中初始化堆的过程比较次数较多, 因此它不太适用于小序列。同时由于多次任意下标相互交换位置, 相同元素之间原本相对的顺序被破坏了, 因此, 它是不稳定的排序。 tips 堆排序，主要就是把根拿出来，然后剩下的调整成最大堆，所以第一个拿出来的最大的就应该放到最好一个位置，一共循环 n-1 次即可； 注意代码中的 len 是 length-1。 还有一个容易出错的地方在建立大根堆的时候，i 应该是从最后一个节点的父亲节点开始调整。 写的非递归还是不太好…虽然好像能通过，非递归中代码中的m是指节点的左孩子，如果有交换，切勿忘记更新新的父亲节点(i = (m-1)/2)，然后进行下一步和孩子节点的比较。 归并排序基本思想归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用 分治法（Divide and Conquer）的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2-路归并。 算法描述 把长度为n的输入序列分成两个长度为n/2的子序列，然后子序列首端各维护一个指针，互相比较； 对这两个子序列分别采用归并排序； 将两个排序好的子序列合并成一个最终的排序序列。 动图演示 代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647 /** * 自己写一个 底层是数组 */ public static void mergeSort(int[] sortArray, int low, int high) &#123; int mid = (low + high) / 2; if (low &lt; high) &#123; //注意和快排区分一下，这里的mid是要在递归里面的 mergeSort(sortArray, low, mid); mergeSort(sortArray, mid + 1, high); //思路就是先一分为二再合二为一 merge(sortArray, low, mid, high); System.out.println(Arrays.toString(sortArray)); &#125; &#125; private static void merge(int[] sortArray, int low, int mid, int high) &#123; //牺牲了空间，引入了一个新的空间来存储排好序的数组 int[] temp = new int[high - low + 1]; int i = low; int j = mid + 1; int k = 0; while (i &lt;= mid &amp;&amp; j &lt;= high) &#123; if (sortArray[i] &lt; sortArray[j]) &#123; temp[k++] = sortArray[i++]; &#125; else &#123; temp[k++] = sortArray[j++]; &#125; &#125; //非常严重的错误，if中的j++后会影响下一个if，所以会超出索引值。数组越界// if(i &gt; mid)&#123;// temp[k++] = sortArray[j++];// &#125;// if(j &gt; high)&#123;// temp[k++] = sortArray[i++];// &#125; if (i &lt;= mid) &#123; temp[k++] = sortArray[i++]; &#125; if (j &lt;= high) &#123; temp[k++] = sortArray[j++]; &#125; for (int t = 0; t &lt; temp.length; t++) &#123; //这里也是易错点，注意sortArray的下标是从low开始的 sortArray[low + t] = temp[t]; &#125; &#125; 算法效率 时间复杂度：归并排序可算是排序算法中的”佼佼者”。假设数组长度为n，那么拆分数组共需logn, 又每步都是一个普通的合并子数组的过程，时间复杂度为O(n)， 故其综合时间复杂度为O(nlogn)。注意，平均时间复杂度、最好时间复杂度、最坏时间复杂度都是O(nlogn)。 空间复杂度：需要一个额外的数组来存储排序好的数组，所以是O(N)。 稳定性：稳定。 tips 首先注意递归部分，跟快排有所区别，快排是排序一轮结束后才能返回中间节点，而归并是直接算出中间节点，并且归并的mid是要参与递归的，而快排中的基准值不需要参加递归。 合并过程。首先是要new一个新的数组来存储排序好的数组，两个指针轮流比较，如果底层是链表，两个头结点互相比较，最后合并之后返回一个头结点即可。 注意最后将合并排序好的数组放回到原数组时，下标是从 low 开始的。 计数排序计数排序、基数排序、桶排序属于非比较排序。非比较排序是通过确定每个元素之前，应该有多少个元素来排序。针对数组arr，计算arr[i]之前有多少个元素，则唯一确定了arr[i]在排序后数组中的位置。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度O(n)。非比较排序时间复杂度低，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。 基本思想计数排序需要占用大量空间，它仅适用于数据比较集中的情况。比如 [0~100]，[10000~19999] 这样的数据。 计数排序的基本思想是： 对每一个输入的元素arr[i]，确定小于 arr[i] 的元素个数。所以可以把 arr[i] 放到它输出数组中的位置上。 假设有5个数小于 arr[i]，所以 arr[i] 应该放在数组的第6个位置上。 其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 算法描述 找出待排序的数组中最大和最小的元素； 统计数组中 arr[i] 的元素出现的次数，将 arr[i] - min 作为辅助数组helper的索引值； 对所有的计数累加，helper 索引值对应的值即为该 arr[i] 出现的次数； 反向填充目标数组：将 helper 中的元素根据索引依次放回原数组，索引对应的数值即为该数出现的次数，每放一个元素就将 helper[arr[i]-min] 减去1。 动图演示 代码实现12345678910111213141516171819202122232425/** * 计数排序 * 要有两个数组，分别是原数组，中间数组用来排序的 * * @param sortArray */public static void courtSort(int[] sortArray) &#123; int max = Integer.MIN_VALUE; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; sortArray.length; i++) &#123; max = Math.max(max, sortArray[i]); min = Math.min(min, sortArray[i]); &#125; int[] helparr = new int[max - min + 1]; for (int i = 0; i &lt; sortArray.length; i++) &#123; helparr[sortArray[i] - min]++; &#125; int index = 0; for (int i = 0; i &lt; helparr.length; i++) &#123; while (helparr[i]-- &gt; 0) &#123; sortArray[index++] = i + min; &#125; &#125; System.out.println(Arrays.toString(sortArray));&#125; 算法效率 时间复杂度：当输入元素是 n 个 0到 k 之间的整数时，平均时间、最坏和最好情况下都一样，都是O(n+k) 。其排序速度快于任何比较排序算法。当k不是很大并且序列比较集中时，计数排序是一个很有效的排序算法。 空间复杂度：O(n+k) 。 稳定性：稳定。 tips 注意：为了节省空间，helper 必须是 arr[i]-min作为索引值。 在将排序好的数组放回原数组时，别忘了把中间数组索引对应的值减去1，当为0时说明该索引代表的值不存在。 桶排序基本思想 桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 桶排序 (Bucket sort) 的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行排）。 桶排序可用于最大最小值相差较大的数据情况，比如[9012,19702,39867,68957,83556,102456]。但桶排序要求数据的分布必须均匀，否则可能导致数据都集中到一个桶中。比如[104,150,123,132,20000], 这种数据会导致前4个数都集中到同一个桶中。导致桶排序失效。 桶排序的基本思想是：把数组 arr 划分为n个大小相同子区间（桶），每个子区间各自排序，最后合并。计数排序是桶排序的一种特殊情况，可以把计数排序当成每个桶里只有一个元素的情况。 算法描述 找出待排序数组中的最大值 max、最小值 min； 我们使用 动态数组 ArrayList 作为桶，桶里放的元素也用 ArrayList 存储。桶的数量为 (max-min)/BucketSize+1； 遍历数组 arr，计算每个元素 arr[i] 放的桶； 每个桶各自排序； 遍历桶数组，把排序好的元素放进输出数组。 图片演示 代码实现1234567891011121314151617181920212223242526272829303132/** * 桶排序 * * @param sortArray */public static void BucketSort(int[] sortArray) &#123; //1.设置固定数量的空桶 int max = Integer.MIN_VALUE; int BucketSize = 5; int min = Integer.MAX_VALUE; for (int i = 0; i &lt; sortArray.length; i++) &#123; max = Math.max(max, sortArray[i]); min = Math.min(min, sortArray[i]); &#125; int BucketCount = (max - min) / BucketSize + 1; //2.把数据放到对应桶中 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; buckets = new ArrayList&lt;&gt;(BucketCount); for (int i = 0; i &lt; BucketCount; i++) &#123; buckets.add(new ArrayList&lt;Integer&gt;()); &#125; for (int i = 0; i &lt; sortArray.length; i++) &#123; int num = (sortArray[i] - min) / BucketSize; buckets.get(num).add(sortArray[i]); &#125; //3.排序 for (int i = 0; i &lt; buckets.size(); i++) &#123; //直接用的是集合自带的排序，可以选择插入或者递归使用桶排序 Collections.sort(buckets.get(i)); &#125; System.out.println(buckets.toString()); &#125; 算法效率 时间复杂度：桶排序最好情况下使用线性时间 O(n)，桶排序的时间复杂度，取决与对各个桶中数据进行排序的时间复杂度，因为其它部分的时间复杂度都为 O(n)。很显然，桶的范围划分的越小，桶越多，各个桶之间的数据越少，排序所用的时间也会越少。所以最差的时间复杂度为 O(n²)，平均时间复杂度为 O(n+k)，最好的时间复杂度为 O(n)。 空间复杂度：O(n+k) 。 稳定性：稳定。 tips 桶最好是用ArrayList，里面的数据最好也是ArrayList装载，因为这样方便动态的添加数据到桶中。 桶内排序可以随便选择一种排序算法，这里采用的是java集成好的集合排序的方法。 基数排序基本思想基数排序（Radix Sort）是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。 算法描述 取得数组中的最大数，并取得位数； arr 为原始数组，从最低位开始取每个位组成 radix 数组； 对 radix 进行计数排序（利用计数排序适用于小范围数的特点）； 动图演示 代码实现123456789101112131415161718192021222324252627282930313233343536373839/** 基数排序 * 可以采用桶的思想，也可以采用队列的思想 * * @param array */ public static void radixSort(int[] array) &#123; if (array == null || array.length &lt; 2) return; // 1.先算出最大数的位数； int max = array[0]; for (int i = 1; i &lt; array.length; i++) &#123; max = Math.max(max, array[i]); &#125; int maxDigit = 0; while (max != 0) &#123; max /= 10; maxDigit++; &#125; int mod = 10, div = 1; //桶可以用二维数组实现，也可以用ArrayList实现，推荐列表，因为是动态的 ArrayList&lt;ArrayList&lt;Integer&gt;&gt; bucketList = new ArrayList&lt;ArrayList&lt;Integer&gt;&gt;(); for (int i = 0; i &lt; 10; i++) &#123; bucketList.add(new ArrayList&lt;Integer&gt;()); &#125; for (int i = 0; i &lt; maxDigit; i++, mod *= 10, div *= 10) &#123; for (int j = 0; j &lt; array.length; j++) &#123; int num = (array[j] % mod) / div; bucketList.get(num).add(array[j]); &#125; int index = 0; for (int j = 0; j &lt; bucketList.size(); j++) &#123; for (int k = 0; k &lt; bucketList.get(j).size(); k++) &#123; array[index++] = bucketList.get(j).get(k); &#125; bucketList.get(j).clear(); &#125; &#125; System.out.println(Arrays.toString(array)); &#125; 算法效率 时间复杂度：基数排序基于分别排序，分别收集，所以是稳定的。但基数排序的性能比桶排序要略差，每一次关键字的桶分配都需要 O(n)的时间复杂度，而且分配之后得到新的关键字序列又需要 O(n)的时间复杂度。假如待排数据可以分为 d个关键字，则基数排序的时间复杂度将是 O(d*2n) ，当然 d 要远远小于 n，因此基本上还是线性级别的。最好、最差、平均时间复杂度都是O(n*k)级别的。 空间复杂度：O(n+k)，其中k为桶的数量。一般来说 n&gt;&gt;k，因此额外空间需要大概 n 个左右。 稳定性：稳定。 tips 注意每个桶内数据排序好然后返回给原数组后，记得clear； 点睛之笔是 将基数排序转换为计数排序，分别对其个位、十位…进行计数排序。 参考文献 十大经典排序算法 十大经典排序算法之JAVA实现 计数排序和桶排序之JAVA实现 十大经典排序算法动画与解析，看我就够了！（配代码完全版） 面试必备：八种排序算法原理及Java实现]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[darkmode for mac]]></title>
    <url>%2F2019%2F10%2F24%2Fdarkmode%E6%95%99%E7%A8%8B.html</url>
    <content type="text"><![CDATA[Mac端darkmode设置Mac端外观具体操作方式 打开 系统偏好设置 点击 通用 修改 外观 修改完之后，部分软件会自动适配系统的环境色，例如chrome，网易云等等。 修改chrome网页颜色在谷歌插件商店中查找一款Dark Reader的插件，可以完美配合暗黑模式的使用 自动切换白天黑夜的模式下载一款叫做DarkNight的软件，可以根据当地的日落日出时间自动切换屏保，配合暗黑模式的使用。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java实现单链表]]></title>
    <url>%2F2019%2F10%2F16%2Fjava%E5%AE%9E%E7%8E%B0%E5%8D%95%E9%93%BE%E8%A1%A8.html</url>
    <content type="text"><![CDATA[Java实现单向链表基本功能先说一下，参考借鉴的博客有： Java实现单向链表基本功能 Java单链表反转 详细过程 从链表中删除重复数据（三种方法) 补充写的没人家好，这部分主要是对第一个博客的补充，其单向链表中的链表反转和从链表中删除重复数据解释的不够清晰，后面两个博客是扩展这两个知识点的，在看这个知识点的同时，发现用到了部分HashTable的知识，过段时间需要把这个知识点也完善一下。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[transient关键字]]></title>
    <url>%2F2019%2F10%2F12%2Ftransient%E5%85%B3%E9%94%AE%E5%AD%97.html</url>
    <content type="text"><![CDATA[transient关键字作用(转载)作用及使用方法​ 我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。 ​ 然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。 ​ 总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Alexia"); user.setPasswd("123456"); System.out.println("read before Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream("C:/user.txt")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; ObjectInputStream is = new ObjectInputStream(new FileInputStream( "C:/user.txt")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println("\nread after Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; private String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 1234567read before Serializable: username: Alexiapassword: 123456read after Serializable: username: Alexiapassword: null 密码字段为null，说明反序列化时根本没有从文件中获取到信息。 transient使用小结 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 第三点可能有些人很迷惑，因为发现在User类中的username字段前加上static关键字后，程序运行结果依然不变，即static类型的username也读出来为“Alexia”了，这不与第三点说的矛盾吗？实际上是这样的：第三点确实没错（一个静态变量不管是否被transient修饰，均不能被序列化），反序列化后类中static型变量username的值为当前JVM中对应static变量的值，这个值是JVM中的不是反序列化得出的，不相信？好吧，下面我来证明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.io.Serializable;/** * @description 使用transient关键字不序列化某个变量 * 注意读取的时候，读取数据的顺序一定要和存放数据的顺序保持一致 * * @author Alexia * @date 2013-10-15 */public class TransientTest &#123; public static void main(String[] args) &#123; User user = new User(); user.setUsername("Alexia"); user.setPasswd("123456"); System.out.println("read before Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); try &#123; ObjectOutputStream os = new ObjectOutputStream( new FileOutputStream("C:/user.txt")); os.writeObject(user); // 将User对象写进文件 os.flush(); os.close(); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; // 在反序列化之前改变username的值 User.username = "jmwang"; ObjectInputStream is = new ObjectInputStream(new FileInputStream( "C:/user.txt")); user = (User) is.readObject(); // 从流中读取User的数据 is.close(); System.out.println("\nread after Serializable: "); System.out.println("username: " + user.getUsername()); System.err.println("password: " + user.getPasswd()); &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;class User implements Serializable &#123; private static final long serialVersionUID = 8294180014912103005L; public static String username; private transient String passwd; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPasswd() &#123; return passwd; &#125; public void setPasswd(String passwd) &#123; this.passwd = passwd; &#125;&#125; 1234567read before Serializable: username: Alexiapassword: 123456read after Serializable: username: jmwangpassword: null 这说明反序列化后类中static型变量username的值为当前JVM中对应static变量的值，为修改后jmwang，而不是序列化时的值Alexia。 3. transient使用细节——被transient关键字修饰的变量真的不能被序列化吗？123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.Externalizable;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.ObjectInput;import java.io.ObjectInputStream;import java.io.ObjectOutput;import java.io.ObjectOutputStream;/** * @descripiton Externalizable接口的使用 * * @author Alexia * @date 2013-10-15 * */public class ExternalizableTest implements Externalizable &#123; private transient String content = "是的，我将会被序列化，不管我是否被transient关键字修饰"; @Override public void writeExternal(ObjectOutput out) throws IOException &#123; out.writeObject(content); &#125; @Override public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException &#123; content = (String) in.readObject(); &#125; public static void main(String[] args) throws Exception &#123; ExternalizableTest et = new ExternalizableTest(); ObjectOutput out = new ObjectOutputStream(new FileOutputStream( new File("test"))); out.writeObject(et); ObjectInput in = new ObjectInputStream(new FileInputStream(new File( "test"))); et = (ExternalizableTest) in.readObject(); System.out.println(et.content); out.close(); in.close(); &#125;&#125; content变量会被序列化吗？ 好吧，我把答案都输出来了，是的，运行结果就是：是的，我将会被序列化，不管我是否被transient关键字修饰 这是为什么呢，不是说类的变量被transient关键字修饰以后将不能序列化了吗？ ​ 我们知道在Java中，对象的序列化可以通过实现两种接口来实现，若实现的是Serializable接口，则所有的序列化将会自动进行，若实现的是Externalizable接口，则没有任何东西可以自动序列化，需要在writeExternal方法中进行手工指定所要序列化的变量，这与是否被transient修饰无关。因此第二个例子输出的是变量content初始化的内容，而不是null。 转载于：Java transient关键字使用小记]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>transient</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode学习]]></title>
    <url>%2F2019%2F10%2F12%2Fleetcode%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[第1题：两数之和题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 我的思路 先排序 排除比target大的数 从最靠近target的数开始遍历 记录找到的数的下标输出即可 我的代码（未AC）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Arrays;public class twoNumbersSum &#123; public int[] twoSum(int[] nums, int target) &#123; //先排序 int[] nums_copy = Arrays.copyOf(nums,nums.length); Arrays.sort(nums_copy); int i; //排除比target大的数 //从最靠近target的数开始遍历 //记录找到的数的下标，输出即可 int t; int k; for(i = nums_copy.length-1; i &gt; 0 ;i--)&#123; if(nums_copy[i] &lt;= target)&#123; if(Arrays.binarySearch(nums_copy,0,i,target-nums_copy[i]) &gt;= 0)&#123; if(nums_copy[i] * 2 == target) &#123; int[] twobro = new int[2]; int d=0; for(int h=0;h&lt;nums.length;h++)&#123; if(nums[h] == nums_copy[i])&#123; twobro[d] = h; d++; &#125; &#125; return twobro; &#125; else&#123; for(int m=0;m &lt; nums.length;m++)&#123; if(nums[m] == nums_copy[i])&#123; t = m; &#125; if(nums[m] == (target-nums_copy[i]))&#123; k = m; &#125; &#125; k = Arrays.binarySearch(nums,target-nums_copy[i]); t = Arrays.binarySearch(nums,nums_copy[i]); &#125; return new int[]&#123;k,t&#125;; &#125; &#125; &#125; return null; &#125; public static void main(String[] args) &#123; twoNumbersSum tws = new twoNumbersSum(); int[] receive = new int[20]; receive = tws.twoSum(new int[]&#123;0,4,3,0&#125;,0); if(receive == null) &#123; System.out.println("不存在"); &#125; else&#123; System.out.println(receive[0] + "\n" + receive[1]); &#125; &#125;&#125; 正确思路利用 HashMap 记录数组元素值和对应的下标，对于一个数 nums[i]，判断 target - nums[i] 是否存在 HashMap 中，存在的话，返回两个下标组成的数组。注意，已存在的元素下标在前，当前元素下标在后。 正确代码123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(target - nums[i])) &#123; return new int[] &#123;map.get(target - nums[i]), i&#125;; &#125; map.put(nums[i], i); &#125; return null; &#125;&#125; 涉及的知识点数组内容 一维和二维数组一维数组：int[] a = new int[4];二维数组： 1234//第一行4个元素，第二行5个元素int[][] a = new int[2][];a[0] = new int[4];a[1] = new int[5]; Arrays类java.util.Arrays类能够方便的操作数组，提供的所有方法都是静态的： 12345678910import java.util.Arrays;public int[] twoSum(int[] nums, int target) &#123; int[] nums_copy = Arrays.copyOf(nums,nums.length); Arrays.fill(nums,2); Integer index = Arrays.binarySearch(nums,target); Arrays.equals(nums,nums_copy); Arrays.sort(nums); return new int[]&#123;0,0,0&#125;;&#125; 总共5个方法，分别是copyOf,fill,binarySearch,equals,sort。第一个用来复制原始数组，方便后续排序的操作，fill是用来初始化数组比较方便，可以将所有数组中的值全部初始化为同一个值，binarySearch是二分查找，返回的是该数的索引值，sort是用来排序的。 binarySearch()自己写代码的时候用到了这个方法，首先该方法需要数组排好序才能调用，其次很特别的是，如果要找的值在数组中，则会返回搜索键的索引，但是，注意：值不存在于数组的话会返回-1或者是目标值需要插入的位置，从1开始数起，不是0哦！！！这个写的贼好哈哈哈哈：数组查询Arrays类的binarySearch()方法详解 map.containsKey和map.get()区别hashmap判断是否存在key时，使用get(key)==null判断还是containsKey？key值可能为null，若此时Map集合值对象为null，并且没有个数限制，所以当get()方法的返回值为null时，可能有两种情况，一种是在集合中没有该键对象，另一种是该键对象没有映射任何值对象，即值对象为null。因此，在Map集合中不应该利用get(Object key)方法来判断是否存在某个键，而应该利用containsKey()方法来判断,containsKey方法用来判断Map集合对象中是否包含指定的键名。一句话概括:get()如果得到null，可能这是键对应的值对象为null也可能是不存在该键，而containsKey则是false或true，不存在这种疑问。 扩充:map.containsKey()、map.containsValue()、map.get() get的过程是先计算hash，然后通过hash与table.length取摸计算index值，然后遍历table[index]上的链表，直到找到key，然后返回； 1234567891011121314public V get(Object key) &#123; if (key == null) return getForNullKey();//处理null值 int hash = hash(key.hashCode());//计算hash //在table[index]遍历查找key，若找到则返回value，找不到返回null for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null; &#125; containsKey方法也是先计算hash，然后使用hash和table.length取摸得到index值，遍历table[index]元素查找是否包含key相同的值； 123456789101112131415public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; int hash = (key == null) ? 0 : hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 看代码能看到区别，一个是返回key对应的value值，一个是返回是否有该key的boolean变量。 containsValue方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见HashMap的containsValue方法本质上和普通数组和list的contains方法没什么区别，你别指望它会像containsKey那么高效。 1234567891011public boolean containsValue(Object value) &#123; if (value == null) return containsNullValue(); Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; 知识缺陷 压根没想到用Map去做 自己只考虑到了全是正数的情况，所以用了排序和跟0判断，如果含有负数的话就做不了了…… 收获在遇到数组问题时，可以考虑用map，因为索引和数值就是一个天生的map集合，如果我知道数值，我就可以通过map找到其索引，本题思路就是这样，当已知一个值是我所需要的，直接从map中拿出就行。 插入知识点既然复习到了map，那就给list、set和map来一个全部的复习吧！！！嘿嘿开始吧！！！先来上个链接，主要是看的这个写的：Java集合中List,Set以及Map等集合体系详解(史上最全) collection先上个图：这个图画的好啊哈哈哈哈哈哈哈不瞎的都看得到，Collection这个接口下有三个接口继承，分别是Set、List、Queue(我他妈好像没怎么用过Queue啊，以后要多用点了)，Set有三个实现类，分别是HashSet、LinkedHashSet、TreeSet，List有三个实现类，分别是ArrayList、Vector(感觉现在是不是用的比较少啊…)、LinkedList，咦这个LinkedList牛逼啊，竟然还是Queue的实现类，不过看别人博客好像是说继承Queue部分的LinkedList是被阉割了的实现类，也就是Queue不能访问到LinkedList的所有方法(管它呢我都没用过…)，还有一个PriorityQueue,看名字就知道是优先级队列啦！(妈呀看的资料太多，想单独开一篇来总结集合源码和Map源码了…算了先这样写着吧) ####先列个提纲： 1.先综述一下collection中三个儿子接口得各个实现类的特点，比如底层实现，优缺点等等； 2.分别阐述，分述时记得贴上源码分析 3.面试常问到的点 综述— List 有序,可重复 ArrayList优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程不安全，效率高特点: 允许null，不同步Vector优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程安全，效率低tips:所谓的线程安全，是相对的，在vector内部内部内部，其所有方法不会被多线程所访问，单个方法的原子性（注：原子性，程序的原子性即不会被线程调度机制打断），并不能保证复合操作也具有原子性，所以如果是复合操作，同样线程不安全！！如果要保证真正的线程安全，还需要以vector对象为锁，来进行操作，但这样就跟ArrayList没啥区别了…———–&gt; Vector是线程安全吗特点：允许null，不同步LinkedList优点: 底层数据结构是双向链表，查询慢，增删快。缺点: 线程不安全，效率高特点：允许null，不同步 —Set 无序,唯一 HashSet（不同步，允许null）底层数据结构是哈希表(无序,唯一)，其实就是HashMap的实例，只不过值是key，value是一个固定的对象。如何来保证元素唯一性?1.依赖两个方法：hashCode()和equals() LinkedHashSet（不同步，允许null）底层数据结构是双向链表和哈希表。(FIFO插入有序,唯一)，实际上依旧是LinkedHashMap的实例，待会源码分析看看1.由链表保证元素有序2.由哈希表保证元素唯一 TreeSet（允许null，不同步）底层数据结构是红黑树。(唯一，有序，这里的有序指的是排序好的，不是说FIFO之类的)，实际上依旧是TreeMap的实例 如何保证元素排序的呢?自然排序(重写):1.Student类中实现 Comparable接口 2.重写Comparable接口中的Compareto方法比较器排序:1.单独创建一个比较类，这里以MyComparator为例，并且要让其继承Comparator接口 2.重写Comparator接口中的Compare方法2.如何保证元素唯一性的呢?根据比较的返回值是否是0来决定 -Queue PriorityQueue：优先级队列，按照大小排序好了的队列，并不遵循先进先出，不允许null元素，头部是最小元素，底层采用的数组和堆。 * PriorityQueue不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问PriorityQueue 实例，这时请使用线程安全的PriorityBlockingQueue 类。 * 不允许插入 null 元素。 * PriorityQueue实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是O(1)。所以在遍历时，若不需要删除元素，则以peek的方式遍历每个元素。 * 方法iterator()中提供的迭代器并不保证以有序的方式遍历PriorityQueue中的元素。 剩余有关Queue队列看—–&gt; Java集合（七） Queue详解 分别阐述这个还是另开一篇吧…内容太多了…够写两星期了！！还是不放在这喧宾夺主了!! map 具体展开见另一篇博客：map源码分析 第2题：两数相加题目给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。 如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。 您可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807 我的思路 先讲输入输出。要输入两个链表，首先就要构造Node实体类，注意构造函数有多个，根据参数的不同进行选择，输出同输入，将组合好的链表的头结点(有数据的)返回后，就可以循环将整个链表打印出来了； 再讲实现。见代码注释。 我的代码（AC）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100package 链表实现_java.leecode第二题;public class leecode_second_Link &#123; public static void main(String[] args) &#123; Node head = new Node(2); Node node1 = new Node(5); Node node2 = new Node(8); Node node3 = new Node(7); head.setNext(node1); node1.setNext(node2); node2.setNext(node3); // 打印链表1 Node temp = head; while (temp != null) &#123; if(temp.next == null) &#123; System.out.println(temp.getData()); &#125; else &#123; System.out.print(temp.getData() + "--&gt;"); &#125; temp = temp.getNext(); &#125; System.out.println("+"); Node head_sec = new Node(2); Node node1_sec = new Node(4); Node node2_sec = new Node(6); Node node3_sec = new Node(7); head_sec.setNext(node1_sec); node1_sec.setNext(node2_sec); node2_sec.setNext(node3_sec); // 打印链表2 Node temp1 = head_sec; while (temp1 != null) &#123; if(temp1.next == null) &#123; System.out.println(temp1.getData()); &#125; else &#123; System.out.print(temp1.getData() + "--&gt;"); &#125; temp1 = temp1.getNext(); &#125; System.out.println("="); Node head3 = new leecode_second_Link().addTwoNums(head,head_sec); //打印总和链表 Node temp3 = head3; while(temp3 != null)&#123; if(temp3.next == null) &#123; System.out.println(temp3.getData()); &#125; else &#123; System.out.print(temp3.getData() + "--&gt;"); &#125; temp3 = temp3.getNext(); &#125; &#125; public Node addTwoNums(Node head1,Node head2)&#123; //没啥用，初始化头结点(可以不带数据) Node res = new Node(0); //temp是后面用来遍历链表的 Node temp = res; //这个是商，用来进位给下一位的 int quo = 0; //循环，只有当第一个链表中的值为空且第二个链表中的值为空且没有了进位，计算才算结束 while(head1 != null || head2 != null || quo != 0)&#123; //t为两链表相同位置的和加上前面一位的进位 int t = (head1 == null ? 0 : head1.data ) + (head2 == null ? 0 : head2.data) + quo; //商 quo = t/10; //新链表在该位的值 Node head3 = new Node(t % 10); //新链表的第一个值 temp.next = head3; //只有这样，才能让链表next下去，这两步要学会，以后链表经常要用 temp = head3; //分别看两个链表是否为空，如果为空说明该位已经没了，否则就next下去 head1 = (head1 == null ? head1 : head1.next); head2 = (head2 == null ? head2 : head2.next); &#125; //返回链表第一个有值的节点，相当于有值的头结点 return res.next; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package 链表实现_java.leecode第二题;public class Node &#123; //数据域 public Integer data; //指针域，指向下一个节点 public Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; public int getData() &#123; return data; &#125; public void setData(int Data) &#123; this.data = Data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node Next) &#123; this.next = Next; &#125;&#125; 正确思路同时遍历两个链表，对应值相加(还有 quotient)求余数得到值并赋给新创建的结点。而商则用quotient存储，供下次相加。 正确代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//复杂版/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode res = new ListNode(-1); ListNode cur = res; int quotient = 0; int t = 0; while (l1 != null &amp;&amp; l2 != null) &#123; t = l1.val + l2.val + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; l1 = l1.next; l2 = l2.next; cur = node; &#125; while (l1 != null) &#123; t = l1.val + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; l1 = l1.next; cur = node; &#125; while (l2 != null) &#123; t = l2.val + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; l2 = l2.next; cur = node; &#125; if (quotient != 0) &#123; cur.next = new ListNode(quotient); cur = cur.next; &#125; return res.next; &#125;&#125; 1234567891011121314151617181920212223242526//简化版/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; ListNode res = new ListNode(-1); ListNode cur = res; int quotient = 0; while (l1 != null || l2 != null || quotient != 0) &#123; int t = (l1 == null ? 0 : l1.val) + (l2 == null ? 0 : l2.val) + quotient; quotient = t / 10; ListNode node = new ListNode(t % 10); cur.next = node; cur = node; l1 = (l1 == null) ? l1 : l1.next; l2 = (l2 == null) ? l2 : l2.next; &#125; return res.next; &#125;&#125; 涉及的知识点java中的单链表见我写的另外一篇博文 ——&gt; Java实现单向链表 第3题：无重复字符的最长子串题目给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。 示例示例 1: 123输入: "abcabcbb"输出: 3 解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。 示例 2: 123输入: "bbbbb"输出: 1解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。 示例 3: 1234输入: "pwwkew"输出: 3解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。 我的思路要找到一个最长子串，就必须有一头一尾，所以就必须有两个指针，然后又是字符串对应索引值，所以肯定是需要用map来操作的，key为索引值，value为索引所在位置的值。于是设定两个指针p、q，最开始同时指定在最开始的位置，然后q向后移动，每移动一次，只要q对应的值没有在map中，就将其值放入map，并且记录下串的大小，当碰到了map中相同的值时，就将p向后移到map中出现该值的索引后一位，同时注意！！！此时p可能会回溯，所以此时要用max函数判断一下，然后继续判断串的大小和继续遍历的最长子串的长度，最后返回最长子串长度即可。 我的代码（AC）1234567891011121314151617181920212223242526272829303132package 第三题;import java.util.HashMap;import java.util.Scanner;public class lengthOfLongestSubstring &#123; public static void main(String[] args) &#123; Scanner a = new Scanner(System.in); System.out.println("请输入串: "); String string = a.nextLine(); int num = new lengthOfLongestSubstring().lengthofSubstring(string); System.out.println("最长子串的长度为：" + num); &#125; private int lengthofSubstring(String string) &#123; int max = 0; char[] chars = string.toCharArray(); int p=0,q=0; int len = chars.length; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while(q &lt; len)&#123; if(map.containsKey(chars[q]))&#123; p = Math.max(p,map.get(chars[q])+1); &#125; map.put(chars[q],q); max = Math.max(max,q-p+1); q++; &#125; return max; &#125;&#125; 正确思路利用指针 p, q，初始指向字符串开头。遍历字符串，q 向右移动，若指向的字符在 map 中，说明出现了重复字符，此时，p 要在出现重复字符的下一个位置 map.get(chars[q]) + 1 和当前位置 p 之间取较大值，防止 p 指针回溯。循环的过程中，要将 chars[q] 及对应位置放入 map 中，也需要不断计算出max 与 q - p + 1 的较大值，赋给 max。最后输出 max 即可。 正确代码123456789101112131415161718192021222324class Solution &#123; public int lengthOfLongestSubstring(String s) &#123; if (s == null || s.length() == 0) &#123; return 0; &#125; char[] chars = s.toCharArray(); int len = chars.length; int p = 0, q = 0; int max = 0; Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;(); while (q &lt; len) &#123; if (map.containsKey(chars[q])) &#123; // 防止p指针回溯，导致计算到重复字符的长度 // eg. abba,当q指向最右的a时，若简单把p赋为map.get(chars[q] + 1)，则出现指针回溯 p = Math.max(p, map.get(chars[q]) + 1); &#125; map.put(chars[q], q); max = Math.max(max, q - p + 1); ++q; &#125; return max; &#125;&#125; 涉及的知识点好像并没有啥新知识点，其实就是用map代替指针的作用。 第237题： 删除链表中的节点题目请编写一个函数，使其可以删除某个链表中给定的（非末尾）节点，你将只被给定要求被删除的节点。 示例示例 1 123输入: head = [4,5,1,9], node = 5输出: [4,1,9]解释: 给定你链表中值为 5 的第二个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 1 -&gt; 9 示例 2: 123输入: head = [4,5,1,9], node = 1输出: [4,5,9]解释: 给定你链表中值为 1 的第三个节点，那么在调用了你的函数之后，该链表应变为 4 -&gt; 5 -&gt; 9 说明: 链表至少包含两个节点。 链表中所有节点的值都是唯一的。 给定的节点为非末尾节点并且一定是链表中的一个有效节点。 不要从你的函数中返回任何结果。 我的思路本题题干个人觉得没有交代的很清楚，让人感觉有点摸不着头脑，正常来说应该是给定两个参数，但是要写的函数只有一个参数，所以最开始会让人感觉很突兀，但是实际上这道题设计的很巧妙，不需要给定头结点，可以采用替身攻击，给定的node其实就可以当做头结点来处理，因为不可能是最后一个节点，所以后面一定有节点，故可以将node后节点牺牲掉，这样就相当于将node本身干掉了。 个人遇到的困难主要是在输入输出，尤其是构造单链表的过程花费了比较长的时间，总而言之还是对单链表的操作不够熟练，接下来会重点攻克单链表这一块的知识点！ ##我的代码（AC） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package 第237题_删除链表中的节点;import java.util.ArrayList;import java.util.Scanner;public class deleteNode &#123; public static void main(String[] args) &#123; System.out.println("请输入一串数字代表链表："); Scanner sc = new Scanner(System.in); String head = sc.nextLine(); char[] chars = head.toCharArray();// System.out.println(chars); ArrayList list = new ArrayList(); Node head_first = new Node(-1); Node temp = head_first; for(int i = 0 ; i &lt; chars.length ; i++)&#123; temp.next = new Node(Integer.parseInt(String.valueOf(chars[i]))); temp = temp.next; list.add(chars[i]); &#125; System.out.println("您输入的链表为： "+ list); System.out.println("请您输入要删除的数字："); String data = sc.nextLine(); int data_int = Integer.parseInt(data); Node temp1 = head_first; for(int i = 0 ; i &lt; chars.length ; i++)&#123; temp1 = temp1.next; if(data_int == temp1.data)&#123; deleteNode(temp1); break; &#125; &#125; System.out.println("删除后的链表为："); Node temp3 = head_first.next; for(int i = 0 ; i &lt; chars.length-1 ; i++) &#123; System.out.print(temp3.data + " "); temp3 = temp3.next; &#125; System.out.println("\n"); &#125; public static void deleteNode(Node node) &#123; Node tmp = node.next; node.data = node.next.data; node.next = node.next.next; tmp = null; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940package 第237题_删除链表中的节点;public class Node &#123; //数据域 public Integer data; //指针域，指向下一个节点 public Node next; public Node() &#123; &#125; public Node(int data) &#123; this.data = data; &#125; public Node(int data, Node next) &#123; this.data = data; this.next = next; &#125; public int getData() &#123; return data; &#125; public void setData(int Data) &#123; this.data = Data; &#125; public Node getNext() &#123; return next; &#125; public void setNext(Node Next) &#123; this.next = Next; &#125;&#125; 正确思路只提供 node 依然可以解决此题。只要把下个结点的 值 &amp; next 赋给当前 node，然后删除下个结点，就可以搞定。 正确代码12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public void deleteNode(ListNode node) &#123; // 保存下一个结点 ListNode tmp = node.next; // 将下个结点的值赋给当前要删除的结点 node.val = node.next.val; node.next = node.next.next; // tmp 置为空，让 jvm 进行垃圾回收 tmp = null; &#125;&#125; 涉及的知识点 链表的构建 链表删除 不足对链表操作还不是很驾轻就熟，接下来会重点训练链表操作。 第19题：删除链表的倒数第N个节点题目给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。 示例123给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5. 说明： 给定的 n 保证是有效的。 我的思路删除倒数第n个节点，这个思路比较简单，就是运用两个指针 fast 和 slow ，一个指针比另外一个多n-1步，这样的话当fast指针到最后一个节点的时候，slow指针刚好到达要删除的节点的位置，此时就可以用上题用过的替身牺牲法，牺牲掉要删除节点的下一个节点，只需要将下一个节点的值赋值给当前节点并且将slow.next = slow.next.next即可。但是，有特殊情况 ： 当要删除的节点是最后一个时，无法做到用下一个节点替换，这个时候就要提前预判，不能等到slow到了最后一个节点才考虑删除，要在slow.next.next == null时就考虑！！！ 我的代码（AC）12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package 第19题;//import 第237题_删除链表中的节点.Node;import java.util.ArrayList;import java.util.Scanner;public class removeNthFromEnd &#123; public static void main(String[] args) &#123; System.out.println("请输入一串数字代表链表："); Scanner sc = new Scanner(System.in); String head = sc.nextLine(); char[] chars = head.toCharArray();// System.out.println(chars); ArrayList list = new ArrayList(); ListNode head_first = new ListNode(-1); ListNode temp = head_first; for(int i = 0 ; i &lt; chars.length ; i++)&#123; temp.next = new ListNode(Integer.parseInt(String.valueOf(chars[i]))); temp = temp.next; list.add(chars[i]); &#125; System.out.println("您输入的链表为： "+ list); System.out.print("请您输入要删除的倒数第n个数的节点，n = "); String number = sc.nextLine(); int num = Integer.parseInt(number); ListNode result_node = removeNthFromEnd(head_first.next,num); ListNode temp1 = result_node; while(temp1 != null)&#123;// int data = Integer.parseInt(String.valueOf(temp1.val)); System.out.print(temp1.val); temp1 = temp1.next; &#125; &#125; public static ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode pre = new ListNode(-1); pre.next = head; ListNode fast = pre; ListNode slow = pre; // 快指针先走 n-1 步 for (int i = 0; i &lt; n-1; ++i) &#123; fast = fast.next; &#125; while (fast.next != null &amp;&amp; slow.next.next != null) &#123; fast = fast.next; slow = slow.next; &#125;// ListNode tmp = slow.next; if(slow.next.next == null &amp;&amp; (n == 1)) &#123; slow.next = null; &#125; else &#123; slow.val = slow.next.val; slow.next = slow.next.next;// tmp = null; &#125; return pre.next; &#125;&#125; 12345678910package 第19题;public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; &#125; 正确思路快指针 fast 先走 n 步，接着快指针 fast 与慢指针 slow 同时前进，等到快指针指向链表最后一个结点时，停止前进。然后将 slow 的 next 指向 slow.next.next，即删除了第 n 个结点。最后返回头指针。 这里设置了 pre 虚拟结点(指向 head )是为了方便处理只有一个结点的情况。 正确代码12345678910111213141516171819202122232425262728/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode pre = new ListNode(-1); pre.next = head; ListNode fast = pre; ListNode slow = pre; // 快指针先走 n 步 for (int i = 0; i &lt; n; ++i) &#123; fast = fast.next; &#125; while (fast.next != null) &#123; fast = fast.next; slow = slow.next; &#125; slow.next = slow.next.next; return pre.next; &#125;&#125; 涉及的知识点单链表的删除…比较简单啦 不足个人感觉其实答案的解法还是要比我的好一些，它是通过直接找到删除节点的前一个，这样就非常好处理了，而且还没有特殊情况…我就很笨了，还自以为是的用了一个替身攻击的方法…学到了！！！要记得用到删除节点的前一个节点，这才是单链表的关键。 第21题：合并两个有序链表题目将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 我的思路创建一个新链表，然后比较两个链表，哪个小就让新链表的next指向他，如果有一个提前结束了，剩下的链表接上新链表的后半部分。 我的代码（AC）123456789101112131415161718192021public static ListNode merge(ListNode l1, ListNode l2)&#123; ListNode prehead = new ListNode(-1); ListNode prev = prehead; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt;= l2.val) &#123; prev.next = l1; l1 = l1.next; &#125; else &#123; prev.next = l2; l2 = l2.next; &#125; prev = prev.next; &#125; // exactly one of l1 and l2 can be non-null at this point, so connect // the non-null list to the end of the merged list. prev.next = l1 == null ? l2 : l1; return prehead.next; &#125; 1234567package 第21题;public class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125;&#125; 正确思路利用链表天然的递归性。如果 l1 为空，返回 l2；如果 l2 为空，返回 l1。如果 l1.val &lt; l2.val，返回 l1-&gt;mergeTwoLists(l1.next, l2)；否则返回 l2-&gt;mergeTwoLists(l1, l2.next)。 正确代码123456789101112131415161718192021222324/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 涉及的知识点链表算法题面试必看必看必看！！！！！！！ 第23题：合并K个排序链表题目合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。 示例1234567输入:[ 1-&gt;4-&gt;5, 1-&gt;3-&gt;4, 2-&gt;6]输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6 我的思路我没做出来，然后看了下讨论区，大概总结出三种思路： * 运用优先级队列，将整个链表扔到优先级队列中，然后一个个取出来就可以了，这种思路代码实现比较简单，但是用了人家封装好的东西，总感觉有点投机取巧的感觉... * 运用分治归并的思想，K个链表两两进行归并。 * 强行归并，两个归并完直接放到后者，然后后者再跟后面的排序，这样复杂度很高。 我的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) &#123; return null; &#125; int len = lists.length; if (len == 1) &#123; return lists[0]; &#125; // 合并前后两个链表，结果放在后一个链表位置上，依次循环下去 for (int i = 0; i &lt; len - 1; ++i) &#123; lists[i + 1] = mergeTwoLists(lists[i], lists[i + 1]); &#125; return lists[len - 1]; &#125; /** * 合并两个有序链表 * @param l1 * @param l2 * @return listNode */ private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) &#123; return l2; &#125; if (l2 == null) &#123; return l1; &#125; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; l2.next = mergeTwoLists(l1, l2.next); return l2; &#125;&#125; 正确思路 第一种，优先级队列，20ms, 复杂度 时间复杂度： O(N\log k)O(Nlogk) ，其中 \text{k}k 是链表的数目。弹出操作时，比较操作的代价会被优化到 O(logk) 。同时，找到最小值节点的时间开销仅仅为 O(1)。最后的链表中总共有 N 个节点。 空间复杂度：O(n) 。创造一个新的链表需要 O(n) 的开销。O(k) 。以上代码采用了重复利用原有节点，所以只要 O(1) 的空间。同时优先队列（通常用堆实现）需要 O(k) 的空间（远比大多数情况的 N要小）。 过程： 1.因为链表有序，所以用每个链表的首元素构建初试堆(小顶堆) – 的队列 2.首元素出队，该元素next指向元素入队 第二种，归并分治，典型的归并分治思想，自底向上，依次合并(可结合归并排序理解，将每个链表理解成排序的值)。 复杂度分析 时间复杂度： O(N\log k)O(Nlogk) ，其中 \text{k}k 是链表的数目。 空间复杂度：O(1)O(1) 我们可以用 O(1) 的空间实现两个有序链表的合并。 第三种，强行做。见我的代码，170ms 用第一个链依次和后面的所有链进行双链合并，利用021的双顺序链合并，秒杀！但是效率极低， 时间复杂度是O(x(a+b) + (x-1)(a+b+c) + … + 1 * (a+b+…+z);[a-z]是各链表长度，x表示链表个数-1，可见时间复杂度是极大的。 正确代码 优先级队列 12345678910111213141516171819202122public ListNode mergeKLists(ListNode[] lists) &#123; int len = 0; if((len=lists.length)==0 || lists == null) return null; ListNode preHead = new ListNode(-1); ListNode preNode = preHead; PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;&gt;(len, new Comparator&lt;ListNode&gt;() &#123; @Override public int compare(ListNode o1, ListNode o2) &#123; return o1.val - o2.val; &#125; &#125;); for (ListNode node : lists) &#123; if(node!=null) queue.add(node); &#125; while(!queue.isEmpty())&#123; ListNode small = queue.poll(); preNode.next = small; if(small.next!=null) queue.add(small.next); //将最小值节点后面的节点添加到队里中 preNode = preNode.next; &#125; return preHead.next; &#125; 归并分治 1234567891011121314151617181920212223242526272829303132333435363738394041/* * @lc app=leetcode.cn id=23 lang=java * * [23] 合并K个排序链表 */// @lc code=start/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeKLists(ListNode[] lists) &#123; if (lists == null || lists.length == 0) return null; return merge(lists, 0, lists.length - 1); &#125; private ListNode merge(ListNode[] lists, int left, int right) &#123; if (left == right) return lists[left]; int mid = left + (right - left) / 2; ListNode l1 = merge(lists, left, mid); ListNode l2 = merge(lists, mid + 1, right); return mergeTwoLists(l1, l2); &#125; private ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if (l1 == null) return l2; if (l2 == null) return l1; if (l1.val &lt; l2.val) &#123; l1.next = mergeTwoLists(l1.next, l2); return l1; &#125; else &#123; l2.next = mergeTwoLists(l1,l2.next); return l2; &#125; &#125; &#125; 涉及的知识点包括了优先级队列、最小堆、归并以及 分治的思想 优先级队列。java中的优先级队列是PriorityQueue，是通过最小堆实现的 最小堆 归并 分治 第5题 最长回文子串题目给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。 示例示例 1： 123输入: "babad"输出: "bab"注意: "aba" 也是一个有效答案。 示例 2： 12输入: "cbbd"输出: "bb" 我的思路 最开始的想法是将源字符串翻转，然后判断翻转后的字符串和源字符串的最长公共子序列，但是貌似有点问题，例如accbbdcca翻转后变为accdbbcca,最长公共子序列为acc，但是最长回文子串为bb。 但是上面的思路有可取之处，其实遇到回文子串最核心的问题是从中间开始依次比较左右是否相等，直到不相等，返回左右相等的子串，当然还有一个问题，就是该回文子串可能是单数，也可能是双数，单数的话，直接比较该数的左右即可，双数则需要先判断最开始两数是否相等。 时间复杂度是O(n²)，空间复杂度O(1) 我的代码（AC）美其名曰 中心扩展算法 12345678910111213141516171819202122232425262728package Dynamic_Programming.最长回文子串;public class Solution &#123; public static String longestPalindrome(String s) &#123; String res = ""; for(int i = 0;i &lt; s.length(); i++)&#123; String single = palindrome(s,i,i); String dou = palindrome(s,i,i+1); res = res.length() &gt; single.length() ? res : single; res = res.length() &gt; dou.length() ? res : dou; &#125; return res; &#125; private static String palindrome(String s, int left, int right) &#123; char[] s1 = s.toCharArray(); while(left &gt;= 0 &amp;&amp; right &lt; s.length() &amp;&amp; s1[left] == s1[right])&#123; left--; right++; &#125; return s.substring(left + 1,right); &#125; public static void main(String[] args) &#123; String res = longestPalindrome("aaabaacc"); System.out.println(res); &#125;&#125; 正确思路和代码dp12345678910111213141516171819202122232425 private static String dp(String s)&#123; //每次都忘记了边界处理 if(s == null || s.length() &lt; 1)&#123; return ""; &#125; char[] s1 = s.toCharArray(); int len = s1.length; int max = 1;// int over = 1; int start = 0; boolean res[][] = new boolean[len][len]; //此时的j是最右边的数 //此时的i是最左边的数 for(int j = 0; j &lt; s1.length; j++)&#123; for(int i = 0; i &lt;= j ;i++ )&#123; res[i][j] = (j &lt;= i + 2) ? s1[i] == s1[j] : res[i+1][j-1] &amp;&amp; s1[i] == s1[j]; if(res[i][j] &amp;&amp; max &lt; j - i + 1)&#123; max = j - i + 1; start = i; &#125; &#125; &#125; return s.substring(start,start + max); &#125; 关键就是暴力法： res[i][j] = (j &lt;= i + 2) ? s1[i] == s1[j] : res[i+1][j-1] &amp;&amp; s1[i] == s1[j]; 上面就是dp最为关键的状态转移递推式，为什么在dp中不用考虑回文串长度的奇偶呢，因为我的方法中是从中间扩散，那么就必然需要分类，而dp是从两边向中间靠，要是回文串首尾必须相同，而当回文串小于等于3时，只要比较的首尾相等，则无需再比较，这样回文串的奇偶就不需要再考虑了。 细细想来，其实dp就是中心扩展方法的逆，一个是从中间向两边发散，一个是两边向中间靠拢！！ Tips： 注意边界处理，因为 str.substring 这个是不允许字符串为 null 的 时间复杂度为O(n²)，空间复杂度为O(n²) 注意二维数组的维度分别是代表首和尾，子串是否为回文串取决于子子串和首尾是否相等，要注意base case是子串为1个字符时，它必为回文子串 最核心的就是状态转移的条件，是分为两种小情况，一种是当源字符串长度&lt;=3时 当源字符串元素个数为3个，若左右边界相等，则去掉他们，只剩一个字符，必为回文串 当源字符串元素个数为2个，若左右边界相等，则必为回文串 此时该串是否为回文串就取决于首尾，另一种情况是当源字符串长度&gt;3时，则需要判断首尾是否相等并且去除首尾后的子串是否为回文串 当发现有回文串时，则判断一下长度是否比之前发现的长，如果是，则记录长度，并且将最长回文串的起始位置拿到，最后全部循环完一遍后截取最长回文串即可 部分知识点补充暂无 第96题 不同的二叉搜索树题目描述给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？ 示例: 12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树: 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解法原问题可拆解为子问题的求解。 二叉搜索树，可以分别以 1/2/3..n 做为根节点。所有情况累加起来，也就得到了最终结果。 res[n] 表示整数n组成的二叉搜索树个数。它的左子树可以有0/1/2...n-1 个节点，右子树可以有n-1/n-2...0 个节点。res[n] 是所有这些情况的加和。 时间复杂度分析：状态总共有 n 个，状态转移的复杂度是 O(n)，所以总时间复杂度是 O(n²)。 普通的dp 123456789101112class Solution &#123; public int numTrees(int n) &#123; int[] dp = new int[n+1]; dp[0] = 1; for(int i=1;i&lt;=n;i++)&#123; for(int j =1;j&lt;=i;j++)&#123; dp[i] += dp[j-1] * dp[i-j]; &#125; &#125; return dp[n]; &#125;&#125; 上面的解法明显还可以得到改进，因为左-右子树的节点个数为0,n-1,和左右子树节点个数为n-1,0。这两者的二叉搜索树的结果肯定是一致的，所以我们就没有必要算两遍。但是同时要考虑到奇偶的问题。 如果n=4，那么G(4) = G(0) G(3) + G(1) G(2) + G(2) G(1) + G(3) G(0) = 2[G(0) G(3) + G(1) G(2)] 如果n=5，那么G(5) = G(0) G(4) + G(1) G(3) + G(2) G(2) + G(3) G(1) + G(4) G(0) = 2[G(0) G(4) + G(1) G(3) ] + G(2) G(2) 12345678910111213141516171819202122232425262728class Solution &#123; public int numsTrees2(int n)&#123; if (n == 0) &#123; return 0; &#125; int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = 1; // 长度为 1 到 n for (int i = 2; i &lt;= n; i++) &#123; // 将不同的数字作为根节点，只需要考虑到 len for (int root = 1; root &lt;= i / 2; root++) &#123; int left = root - 1; // 左子树的长度 int right = i - root; // 右子树的长度 dp[i] += dp[left] * dp[right]; &#125; dp[i] *= 2;// 利用对称性乘 2 // 考虑奇数的情况 if ((i &amp; 1) == 1) &#123; int root = (i &gt;&gt; 1) + 1; int left = root - 1; // 左子树的长度 int right = i - root; // 右子树的长度 dp[i] += dp[left] * dp[right]; &#125; &#125; return dp[n]; &#125;&#125; 知识点补充 LeetCode二叉树专题——&gt;DFS和BFS 第95题 不同的二叉搜索树II题目描述给定一个整数 n，生成所有由 1 … n 为节点所组成的二叉搜索树。 示例123456789输入: 3输出:[ [1,null,3,2], [3,2,null,1], [3,1,null,null,2], [2,1,3], [1,null,2,null,3]] 解释1234567以上的输出对应以下 5 种不同结构的二叉搜索树： 1 3 3 2 1 \ / / / \ \ 3 2 1 1 3 2 / / \ \ 2 1 2 3 解法这题就是典型的运用递归去做，明确三个点： 递归出口 递归返回值 一级递归需要做什么 递归出口当树没有节点了，递归结束，怎么表示树没有节点呢，所以就需新建一个函数，参数包括节点的起始和终止。 递归返回值返回值很明显就是符合条件的各种二叉树,是一个含根节点的列表(根据题目最终需要得到的)。 一级递归需要做什么这个是比较难的地方，我们来缕缕现在有什么，我们现在有三个节点，根节点，左子树根节点，右子树根节点，这三个节点我们可以随意将任意一个节点当做根节点，然后去组合得到新的搜索二叉树。注意！！！我们只需要关注一级递归就可以了，无需关注太多，我们现在手上假设就三个节点分别是1,2,3，首先要做的就是遍历1，2，3，分别将其作为根节点，假设以2为根节点，1代表就是左子树返回的根节点列表，3代表的是右子树返回的根节点列表，我们要做的就是遍历左右子树的根节点列表，分别将其添加到根节点的左右子树，然后将该根节点添加至列表，返回列表即可。 代码12 部分知识点补充明天继续进军二叉树部分 同时复习并且捡回来原先要完成的集合那部分的源码分析！（2020.1.1） 杨辉三角(118)Tip:今天第一次写题解，还是非常开心的！！！！！ 今天重点就是掌握了一下递归的思想，最重要的三点！！！！！ 递归思想 找整个递归的终止条件 找返回值 本地递归需要如何操作 主要参考：递归 题目描述给定一个非负整数 numRows，生成杨辉三角的前 numRows 行。 在杨辉三角中，每个数是它左上方和右上方的数的和。 示例: 123456789输入: 5输出:[ [1], [1,1], [1,2,1], [1,3,3,1], [1,4,6,4,1]] 思路方法一：递归递归方法总而言之就是抓住三点： 找整个递归的终止条件 找返回值 一次递归需要如何操作 找整个递归的终止条件咱来分析一下题目，递归到numRows = 0 时或者numRows = 1时都可以终止，因为第一行比较特殊，只有一个1,所以我们可以将其当成整个递归的终止条件，当numRows = 1时，我们就可以终止递归向下返回值了。 找返回值找返回值，我们也需要分析下，题目要我们求的是整个杨辉三角的所有数，那最后递归得到的应该就是 List&lt;List&lt;Integer&gt;&gt; (题目给定)，也就是每递归完一层，我们就更新完List并返回即可，最后递归完成就是我们要的答案。 一次递归需要如何操作递归的难点就在这里，很多童靴刚学递归时，总是在这里搞晕，其实我们只需要关注一次递归即可，因为每一层递归的过程都是一样的，我们只需要找到最上层的递归的规律，就可以了。 如图所示，我们只需要分析第二行到第三行这级递归即可！先上代码！ 递归 代码12345678910111213141516171819202122232425262728293031class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; //存储要返回的杨辉三角 List&lt;List&lt;Integer&gt;&gt; dg = new ArrayList&lt;&gt;(); //若0行，则返回空 if(numRows == 0)&#123; return dg; &#125; //递归出口，这是第一步！找到出口 if(numRows == 1)&#123; dg.add(new ArrayList&lt;&gt;()); dg.get(0).add(1); return dg; &#125; //递归，注意返回值！！！这是第二步 dg = generate(numRows-1); //一级递归要做啥，我们可以看第二行到第三行需要做啥 //首先是要申请一个list来存储第三行，然后通过第二行得到第三行 //第三行的首尾为1是确定了的，然后就是中间的数如何得到 //通过观察很容易拿到for循环里面的式子 //最后别忘了返回值！！！ List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); row.add(1); for(int j = 1;j &lt; numRows - 1;j++)&#123; row.add(dg.get(numRows-2).get(j-1) + dg.get(numRows-2).get(j)); &#125; row.add(1); dg.add(row); return dg; &#125;&#125; 方法二：动态规划思路其实差不多，只是一个递归，一个变成了迭代而，仅此而已！ 1234567891011121314151617181920212223class Solution &#123; public List&lt;List&lt;Integer&gt;&gt; generate(int numRows) &#123; List&lt;List&lt;Integer&gt;&gt; dp = new ArrayList&lt;&gt;(); if(numRows == 0)&#123; return dp; &#125; dp.add(new ArrayList&lt;&gt;()); dp.get(0).add(1); //注意这里的 i 是指行数，但是dp是从0开始的 //所以preRow是i-2 for(int i = 2;i &lt;= numRows;i++)&#123; List&lt;Integer&gt; row = new ArrayList&lt;&gt;(); List&lt;Integer&gt; preRow = dp.get(i-2); row.add(1); for(int j = 1;j &lt; i-1;j++)&#123; row.add(preRow.get(j) + preRow.get(j-1)); &#125; row.add(1); dp.add(row); &#125; return dp; &#125;&#125; 单词拆分(139)123456789101112131415class Solution &#123; public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123; boolean[] dp = new boolean[s.length()+1]; dp[0] = true; for(int i = 1;i &lt;= s.length();i++)&#123; for(int j = 0;j &lt; i;j++)&#123; if(dp[j] == true &amp;&amp; wordDict.contains(s.substring(j,i)))&#123; dp[i] = true; break; &#125; &#125; &#125; return dp[s.length()]; &#125;&#125; 解码方法(91)题目描述1234567一条包含字母 A-Z 的消息通过以下方式进行了编码：'A' -&gt; 1'B' -&gt; 2...'Z' -&gt; 26给定一个只包含数字的非空字符串，请计算解码方法的总数。 示例1234567891011示例 1:输入: "12"输出: 2解释: 它可以解码为 "AB"（1 2）或者 "L"（12）。示例 2:输入: "226"输出: 3解释: 它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。 思路所有可以用dp的，基本都有三个方法： 递归 ——-&gt; 带备忘录的自顶向下 ——-&gt; dp 递归1234567891011121314151617181920212223242526272829class Solution &#123; public int numDecodings(String s) &#123; if(s.length() == 0 || s == null)&#123; return 0; &#125; return numDecodingsByRecrusion(s,0,s.length()-1); &#125; private int numDecodingsByRecrusion(String s,int start,int end)&#123; //1.递归出口：数字为最后一个数字时即结束递归 //2.返回值：返回解码方法数 //3.一次递归的过程 if(start &gt; end)&#123; return 1; &#125; if(s.charAt(start) == '0')&#123; return 0; &#125; if(start == end)&#123; return 1; &#125; int num1 = numDecodingsByRecrusion(s,start+1,end); int num2 = 0; if((s.charAt(start) - '0') * 10 + (s.charAt(start+1)-'0') &lt;= 26)&#123; num2 = numDecodingsByRecrusion(s,start+2,end); &#125; return num1+num2; &#125;&#125; 带备忘录的自顶向下123456789101112131415161718192021222324252627282930313233343536class Solution &#123; public int numDecodings(String s) &#123; if(s.length() == 0 || s == null)&#123; return 0; &#125; // int res = numDecodingsByRecrusion(s,0,s.length()-1); // int res = numDecodingsByDp(s); HashMap&lt;Integer,Integer&gt; memo = new HashMap&lt;&gt;(); return numDecodingsByMemo(s,0,s.length()-1,memo); &#125; private int numDecodingsByMemo(String s, int start, int end, HashMap&lt;Integer, Integer&gt; memo)&#123; //1.递归出口：数字为最后一个数字时即结束递归 //2.返回值：返回解码方法数 //3.一次递归的过程 if(start &gt; end)&#123; return 1; &#125; if(s.charAt(start) == '0')&#123; return 0; &#125; if(start == end)&#123; return 1; &#125; if(memo.containsKey(start))&#123; return memo.get(start); &#125; int num1 = numDecodingsByMemo(s,start+1,end,memo); int num2 = 0; if((s.charAt(start) - '0') * 10 + (s.charAt(start+1)-'0') &lt;= 26)&#123; num2 = numDecodingsByMemo(s,start+2,end,memo); &#125; memo.put(start,num1+num2); return num1+num2; &#125;&#125; dp注意：难点在处理&#39;0&#39;,&#39;00&#39;等边界问题！尤其是在dp[n]、dp[n-1]的赋值问题上有一点难度，而且，这个由于是倒序的，跟平时处理的dp问题略微有些许不同，以前是dp[1]对应第一个字符，而这里是dp[0]对应第一个字符。 123456789101112131415161718192021222324252627class Solution &#123; public int numDecodings(String s) &#123; int len = s.length(); int[] dp = new int[len + 1]; dp[len] = 1; //将递归法的结束条件初始化为 1 //最后一个数字不等于 0 就初始化为 1 if (s.charAt(len - 1) != '0') &#123; dp[len - 1] = 1; &#125; for (int i = len - 2; i &gt;= 0; i--) &#123; //当前数字时 0 ，直接跳过，0 不代表任何字母 if (s.charAt(i) == '0') &#123; continue; &#125; int ans1 = dp[i + 1]; //判断两个字母组成的数字是否小于等于 26 int ans2 = 0; int ten = (s.charAt(i) - '0') * 10; int one = s.charAt(i + 1) - '0'; if (ten + one &lt;= 26) &#123; ans2 = dp[i + 2]; &#125; dp[i] = ans1 + ans2; &#125; return dp[0]; &#125;&#125; 零钱兑换(322)回文子串(647)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>Leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo提交文章出现问题]]></title>
    <url>%2F2019%2F10%2F09%2F%E8%A7%A3%E5%86%B3hexo%E6%97%A0%E6%B3%95git%E4%B8%8A%E7%9A%84%E9%97%AE%E9%A2%98.html</url>
    <content type="text"><![CDATA[问题记录hexo发布文章报错记录：Unhandled rejection TypeError: Cannot set property ‘lastIndex’ of undefined发布文章时出现问题，同时报的错还有：xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 解决措施发现是git出现问题！！！ 控制端输入： 1brew install git 1xcode-select --install 在xcode-select指令安装好之后，再命令检查一下git指令的帮助信息： 1git -h 可以正确输出相应的帮助信息，意味着git已经被修复好了。 原因更新了Catalina导致的，新系统辣鸡哈哈哈哈哈哈]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[喜大普奔]]></title>
    <url>%2F2019%2F10%2F09%2F%E5%96%9C%E5%A4%A7%E6%99%AE%E5%A5%94.html</url>
    <content type="text"><![CDATA[开心哇！！！终于写到10w字了！！！继续加油！！]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>happy </tag>
        <tag>happy day</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList源码分析]]></title>
    <url>%2F2019%2F10%2F07%2FArrayList%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html</url>
    <content type="text"><![CDATA[ArrayList 源码分析（转载）不知道各位朋友，还记得开工前制定的学习目标么？ 有没有一直为了那个目标废寝忘食呢？继 搞懂 Java 内部类 后开始探索总结 Java 集合框架源码的知识，希望能给自己夯实基础，也希望能为自己实现目标更近一步。 ArrayList 源码分析思路ArrayList 是我们 App 开发中常用的 Java 集合类，从学习 Java 开始我们基本上就对它天天相见了，但是通过探索ArrayList 源码，我们将会把它从普通朋友变成知根知底的老朋友,本文将从以下几部分开始分析 ArrayList： ArrayList 概述 ArrayList 的构造函数，也就是我们创建一个 ArrayList 的方法 ArrayList 的添加元素的方法， 以及 ArrayList 的扩容机制 ArrayList 的删除元素的常用方法 ArrayList 的 改查常用方法 ArrayList 的 toArray 方法 ArrayList 的遍历方法，以及常见的错误操作即产生错误操作的原因 ArrayList 概述ArrayList的基本特点 ArrayList 底层是一个动态扩容的数组结构 允许存放（不止一个） null 元素 允许存放重复数据，存储顺序按照元素的添加顺序 ArrayList 并不是一个线程安全的集合。如果集合的增删操作需要保证线程的安全性，可以考虑使用 CopyOnWriteArrayList 或者使用 collections.synchronizedList(List l) 函数返回一个线程安全的ArrayList类. ArrayList 的继承关系12public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable 从 ArrayList 的继承关系来看， ArrayList 继承自 AbstractList ，实现了List\, RandomAccess, Cloneable, java.io.Serializable 接口。 其中 AbstractList和 List 是规定了 ArrayList 作为一个集合框架必须具备的一些属性和方法，ArrayList 本身覆写了基类和接口的大部分方法，这就包含我们要分析的增删改查操作。 ArrayList 实现 RandomAccess 接口标识着其支持随机快速访问，查看源码可以知道 RandomAccess 其实只是一个标识，标识某个类拥有随机快速访问的能力，针对 ArrayList 而言通过 get(index) 去访问元素可以达到 O(1) 的时间复杂度。有些集合类不拥有这种随机快速访问的能力，比如 LinkedList 就没有实现这个接口。 ArrayList 实现 Cloneable 接口标识着他可以被克隆/复制，其内部实现了 clone 方法供使用者调用来对 ArrayList 进行克隆，但其实现只通过 Arrays.copyOf 完成了对 ArrayList 进行「浅拷贝」，也就是你改变 ArrayList clone后的集合中的元素，源集合中的元素也会改变，对于深浅拷贝我已经单独整理一篇文章来讲述这里不再过多的说。 对于 java.io.Serializable 标识着集合可被被序列化。 我们发现了一些有趣的事情，除了 List\ 以外，ArrayList 实现的接口都是标识接口，标识着这个类具有怎样的特点，看起来更像是一个属性。 ArrayList 的构造方法在说构造方法之前我们要先看下与构造参数有关的几个全局变量： 12345678910111213141516171819202122/*** ArrayList 默认的数组容量*/ private static final int DEFAULT_CAPACITY = 10;/*** 这是一个共享的空的数组实例，当使用 ArrayList(0) 或者 ArrayList(Collection&lt;? extends E&gt; c) * 并且 c.size() = 0 的时候讲 elementData 数组讲指向这个实例对象。*/ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;/*** 另一个共享空数组实例，再第一次 add 元素的时候将使用它来判断数组大小是否设置为 DEFAULT_CAPACITY*/ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/*** 真正装载集合元素的底层数组 * 至于 transient 关键字这里简单说一句，被它修饰的成员变量无法被 Serializable 序列化 * 有兴趣的可以去网上查相关资料*/ transient Object[] elementData; // non-private to simplify nested class access 对于上述几个成员变量，我们只是在注释中简单的说明，对于他们具体有什么作用，在下边分析构造方法和扩容机制的时候将会更详细的讲解。 ArrayList 一共三种构造方式，我们先从无参的构造方法来开始： 无参构造方法123456/*** 构造一个初始容量为10的空列表。*/ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; 这是我们经常使用的一个构造方法，其内部实现只是将 elementData 指向了我们刚才讲得 DEFAULTCAPACITY_EMPTY_ELEMENTDATA 这个空数组，这个空数组的容量是 0， 但是源码注释却说这是构造一个初始容量为10的空列表。这是为什么？其实在集合调用 add 方法添加元素的时候将会调用 ensureCapacityInternal 方法，在这个方法内部判断了： 123if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);&#125; 可见，如果采用无参数构造方法的时候第一次添加元素肯定走进 if 判断中 minCapacity 将被赋值为 10，所以构造一个初始容量为10的空列表 也就是这个意思。 指定初始容量的构造方法12345678910111213141516/*** 构造一个具有指定初始容量的空列表。* @param 初始容量 * @throws 如果参数小于 0 将会抛出 IllegalArgumentException 参数不合法异常 */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125; 如果我们预先知道一个集合元素的容纳的个数的时候推荐使用这个构造方法，比如我们有个FragmentPagerAdapter 一共需要装 15 个 Fragment ，那么我们就可以在构造集合的时候生成一个初始容量为 15 的一个集合。有人会认为 ArrayList 自身具有动态扩容的机制，无需这么麻烦，下面我们讲解扩容机制的时候我们就会发现，每次扩容是需要有一定的内存开销的，而这个开销在预先知道容量的时候是可以避免的。 源代码中指定初始容量的构造方法实现，判断了如果 我们指定容量大于 0 ，将会直接 new 一个数组，赋值给 elementData 引用作为集合真正的存储数组，而指定容量等于 0 的时候讲使用成员变量 EMPTY_ELEMENTDATA 作为暂时的存储数组，这是 EMPTY_ELEMENTDATA 这个空数组的一个用处（不必太过于纠EMPTY_ELEMENTDATA 的作用，其实它的在源码中出现的频率并不高）。 使用另个一个集合 Collection 的构造方法12345678910111213141516/*** 构造一个包含指定集合元素的列表，元素的顺序由集合的迭代器返回。* @param 源集合，其元素将被放置到这个集合中。 * @如果参数为 null，将会抛出 NullPointerException 空指针异常*/public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray 可能(错误地)不返回 Object[]类型的数组 参见 jdk 的 bug 列表(6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // 如果集合大小为空将赋值为 EMPTY_ELEMENTDATA 等同于 new ArrayList(0); this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 看完这个代码我最疑惑的地方是 Collection.toArray() 和 Arrays.copyOf() 这两个方法的使用，看来想明白这个构造参数具体做了什么必须理解这两个方法了。 Object[] Collection.toArray() 方法我们都知道 Collection 是集合框架的超类，其实 Collection.toArray 是交给具体的集合子类去实现的，这就说明不同的集合可能有不同的实现。他用来将一个集合转化为一个 Object[] 数组，事实上的真的是这样的么？参见 jdk 的 bug 列表(6260652)又是什么意思呢 ？我们来看下下边的这个例子： 12345678910111213List&lt;String&gt; subClasses = Arrays.asList("abc","def");// class java.util.Arrays$ArrayList System.out.println(list.getClass()); Object[] objects = subClasses.toArray();// class java.lang.String; Object[] objArray = list.toArray(); //这里返回的是 String[]System.out.println(objects.getClass().getSimpleName()); objArray[0] = new Object(); // cause ArrayStoreException 咦？为啥这里并不是一个 Object 数组呢？其实我们注意到，list.getClass 得到的并不是我们使用的 ArrayList 而是 Arrays 的内部类 Arrays$ArrayList。 123456789ArrayList(E[] array) &#123; //这里只是检查了数组是否为空，不为空直接将原数组赋值给这个 ArrayList 的存储数组。 a = Objects.requireNonNull(array);&#125;@Overridepublic Object[] toArray()&#123; return a.clone();&#125; 而我们调用的 toArray 方法就是这个内部对于 Collection.toArray 的实现， a.clone() ,这里 clone 并不会改变一个数组的类型，所以当原始数组中放的 String 类型的时候就会出现上边的这种情况了。 其实我们可以认为这是 jdk 的一个 bug，早在 05年的时候被人提出来了，但是一直没修复，但是在新的 「jdk 1.9」 种这个 bug 被修复了。 有兴趣的可以追踪 bug 6260652 看下。 Arrays.copyOf 方法这个方法是在集合源码中常见的一个方法，他有很多重载方式,我们来看下最根本的方法： 1234567891011public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") //根据class的类型是否是 Object[] 来决定是 new 还是反射去构造一个泛型数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //使用 native 方法批量赋值元素至新数组中。 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 上边的注释也看出来了，Arrays.copyOf 方法复制数组的时候先判断了指定的数组类型是否为 Object[] 类型，否则使用反射去构造一个指定类型的数组。最后使用 System.arraycopy 这个 native 方法，去实现最终的数组赋值，newLength 如果比 original.length 大的时候会将多余的空间赋值为 null 由下边的例子可见: 12345String[] arrString = &#123;"abc","def"&#125;;Object[] copyOf = Arrays.copyOf(arrString, 5, Object[].class);//[abc, def, null, null, null]System.out.println(Arrays.toString(copyOf)); 当然 ArrayList(Collection&lt;? extends E&gt; c) 复制的时候传递的是 c.size() 所以不会出现 null。 ex: 对于 System.arraycopy 该方法，本文不再展开讨论，有一篇对于其分析很好的文章大家可以去参考System：System.arraycopy方法详解 ok，绕了这么大的圈子终于明白了，ArrayList(Collection&lt;? extends E&gt; c)干了啥了，其实就是将一个集合中的元素塞到 ArrayList 底层的数组中。至此我们也将 ArrayList 的构造研究完了。 ArrayList的添加元素 &amp; 扩容机制敲黑板了！这块是面试的常客了，所以必须仔细研究下了。我们先看下如何给一个 ArrayList 添加一个元素: 在集合末尾添加一个元素的方法123456789101112131415//成员变量 size 标识集合当前元素个数初始为 0int size；/*** 将指定元素添加到集合（底层数组）末尾* @param 将要添加的元素* @return 返回 true 表示添加成功*/public boolean add(E e) &#123; //检查当前底层数组容量，如果容量不够则进行扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //将数组添加一个元素，size 加 1 elementData[size++] = e; return true;&#125; 调用 add 方法的时候总会调用 ensureCapacityInternal 来判断是否需要进行数组扩容， ensureCapacityInternal 参数为当前集合长度 size + 1，这很好理解，是否需要扩充长度，需要看当前底层数组是否够放 size + 1个元素的。 扩容机制1234567891011121314151617//扩容检查private void ensureCapacityInternal(int minCapacity) &#123; //如果是无参构造方法构造的的集合，第一次添加元素的时候会满足这个条件 minCapacity 将会被赋值为 10 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; // 将 size + 1 或 10 传入 ensureExplicitCapacity 进行扩容判断 ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; //操作数加 1 用于保证并发访问 modCount++; // 如果 当前数组的长度比添加元素后的长度要小则进行扩容 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 上边的源码主要做了扩容前的判断操作，注意参数为当前集合元素个数+1，第一次添加元素的时候 size + 1 = 1 ,而 elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA, 长度为 0 ，1 - 0 &gt; 0, 所以需要进行 grow 操作也就是扩容。 1234567891011121314151617181920212223242526272829303132333435/*** 集合的最大长度 Integer.MAX_VALUE - 8 是为了减少出错的几率 Integer 最大值已经很大了*/private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;/*** 增加容量，以确保它至少能容纳最小容量参数指定的元素个数。* @param 满足条件的最小容量*/private void grow(int minCapacity) &#123; //获取当前 elementData 的大小，也就是 List 中当前的容量 int oldCapacity = elementData.length; //oldCapacity &gt;&gt; 1 等价于 oldCapacity / 2 所以新容量为当前容量的 1.5 倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); //如果扩大1.5倍后仍旧比 minCapacity 小那么直接等于 minCapacity if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果新数组大小比 MAX_ARRAY_SIZE 就需要进一步比较 minCapacity 和 MAX_ARRAY_SIZE 的大小 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity通常接近 size 大小 //使用 Arrays.copyOf 构建一个长度为 newCapacity 新数组 并将 elementData 指向新数组 elementData = Arrays.copyOf(elementData, newCapacity);&#125;/*** 比较 minCapacity 与 Integer.MAX_VALUE - 8 的大小如果大则放弃-8的设定，设置为 Integer.MAX_VALUE */private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125; 由此看来 ArrayList 的扩容机制的知识点一共又两个 每次扩容的大小为原来大小的 1.5倍 （当然这里没有包含 1.5倍后大于 MAX_ARRAY_SIZE 的情况）扩容的过程其实是一个将原来元素拷贝到一个扩容后数组大小的长度新数组中。所以 ArrayList 的扩容其实是相对来说比较消耗性能的。 在指定角标位置添加元素的方法123456789101112131415161718/*** 将指定的元素插入该列表中的指定位置。将当前位置的元素(如果有)和任何后续元素移到右边(将一个元素添加到它们的索引中)。* @param 要插入的索引位置* @param 要添加的元素* @throws 如果 index 大于集合长度 小于 0 则抛出角标越界 IndexOutOfBoundsException 异常*/public void add(int index, E element) &#123; // 检查角标是否越界 rangeCheckForAdd(index); // 扩容检查 ensureCapacityInternal(size + 1); //调用 native 方法新型数组拷贝 System.arraycopy(elementData, index, elementData, index + 1,size - index); // 添加新元素 elementData[index] = element; size++;&#125; 我们知道一个数组是不能在角标位置直接插入元素的，ArrayList 通过数组拷贝的方法将指定角标位置以及其后续元素整体向后移动一个位置，空出 index 角标的位置，来赋值新的元素。 将一个数组 src 起始 srcPos 角标之后 length 长度间的元素，赋值到 dest 数组中 destPos 到 destPos + length -1长度角标位置上。只是在 add 方法中 src 和 dest 为同一个数组而已。 123public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 批量添加元素由于批量添加和添加一个元素逻辑大概相同则这里不详细说了，代码注释可以了解整个添加流程。 在数组末尾添加 12345678910111213public boolean addAll(Collection&lt;? extends E&gt; c) &#123; // 调用 c.toArray 将集合转化数组 Object[] a = c.toArray(); // 要添加的元素的个数 int numNew = a.length; //扩容检查以及扩容 ensureCapacityInternal(size + numNew); // Increments modCount //将参数集合中的元素添加到原来数组 [size，size + numNew -1] 的角标位置上。 System.arraycopy(a, 0, elementData, size, numNew); size += numNew; //与单一添加的 add 方法不同的是批量添加有返回值，如果 numNew == 0 表示没有要添加的元素则需要返回 false return numNew != 0;&#125; 在数组指定角标位置添加1234567891011121314151617181920public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; //同样检查要插入的位置是否会导致角标越界 rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); //这里做了判断，如果要numMoved &gt; 0 代表插入的位置在集合中间位置，和在 numMoved == 0最后位置 则表示要在数组末尾添加 如果 &lt; 0 rangeCheckForAdd 就跑出了角标越界 int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0;&#125;private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 两个方法不同的地方在于如果移动角标即之后的元素，addAll(int index, Collection&lt;? extends E&gt; c)里做了判断，如果要 numMoved &gt; 0 代表插入的位置在集合中间位置，和在 numMoved == 0 最后位置 则表示要在数组末尾添加 如果 numMoved &lt; 0 ，rangeCheckForAdd 就抛出了角标越界异常了。 与单一添加的 add 方法不同的是批量添加有返回值，如果 numNew == 0 表示没有要添加的元素则需要返回 false。 ArrayList 删除元素根据角标移除元素1234567891011121314151617181920212223242526/*** 将任何后续元素移到左边(从它们的索引中减去一个)。*/public E remove(int index) &#123; //检查 index 是否 &gt;= size rangeCheck(index); modCount++; //index 位置的元素 E oldValue = elementData(index); // 需要移动的元素个数 int numMoved = size - index - 1; if (numMoved &gt; 0) //采用拷贝赋值的方法将 index 之后所有的元素 向前移动一个位置 System.arraycopy(elementData, index+1, elementData, index, numMoved); // 将 element 末尾的元素位置设为 null elementData[--size] = null; // clear to let GC do its work // 返回 index 位置的元素 return oldValue;&#125;// 比较要移除的角标位置和当前 elementData 中元素的个数private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index));&#125; 根据角标移除元素的方法源码如上所示，值得注意的地方是： rangeCheck 和 rangeCheckForAdd 方法不同 ，rangeCheck 只检查了 index是否大于等于 size，因为我们知道 size 为 elementData 已存储数据的个数，我们只能移除 elementData 数组中 [0 , size -1] 的元素，否则应该抛出角标越界。 但是为什么没有和 rangeCheckForAdd 一样检查小于0的角标呢，是不是remove(-1) 不会抛异常呢？ 其实不是的，因为 rangeCheck(index); 后我们去调用 elementData(index) 的时候也会抛出 IndexOutOfBoundsException 的异常，这是数组本身抛出的，不是 ArrayList 抛出的。那为什么要检查&gt;= size 呢？ 数组本身不也会检查么？ 哈哈.. 细心的同学肯定知道 elementData.length 并不一定等于 size，比如： 123456ArrayList&lt;String&gt; testRemove = new ArrayList&lt;&gt;(10); testRemove.add("1"); testRemove.add("2"); // java.lang.IndexOutOfBoundsException: Index: 2, Size: 2 String remove = testRemove.remove(2); System.out.println("remove = " + remove + ""); new ArrayList&lt;&gt;(10) 表示 elementData 初始容量为10，所以 elementData.length = 10 而我们只给集合添加了两个元素所以 size = 2 这也就是为啥要 rangeCheck 的原因了。 移除指定元素1234567891011121314151617181920212223242526272829303132333435/*** 删除指定元素，如果它存在则反会 true，如果不存在返回 false。* 更准确地说是删除集合中第一出现 o 元素位置的元素 ，* 也就是说只会删除一个，并且如果有重复的话，只会删除第一个次出现的位置。*/public boolean remove(Object o) &#123; // 如果元素为空则只需判断 == 也就是内存地址 if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; //得到第一个等于 null 的元素角标并移除该元素 返回 ture fastRemove(index); return true; &#125; &#125; else &#123; // 如果元素不为空则需要用 equals 判断。 for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; //得到第一个等于 o 的元素角标并移除该元素 返回 ture fastRemove(index); return true; &#125; &#125; return false;&#125;//移除元素的逻辑和 remve(Index)一样 private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work&#125; 由上边代码可以看出来，移除元素和移除指定角标元素一样最终都是通过 System.arraycopy 将 index 之后的元素前移一位，并释放原来位于 size 位置的元素。 还可以看出，如果数组中有指定多个与 o 相同的元素只会移除角标最小的那个，并且 null 和 非null 的时候判断方法不一样。至于 equals 和 == 的区别，还有 hashCode 方法，我会之后在总结一篇单独的文章。等不急的可以先去网上找找喽。 批量移除/保留 removeAll/retainAllArrayList 提供了 removeAll/retainAll 操作，这两个操作分别是 批量删除与参数集合中共同享有的元素 和 批量删除与参数集合中不共同享有的元素，保留共同享有的元素，两个方法只有一个参数不同!!! 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** 批量删除与参数集合中共同享有的元素*/public boolean removeAll(Collection&lt;?&gt; c) &#123; //判空 如果为空则抛出 NullPointerException 异常 Objects 的方法 Objects.requireNonNull(c); return batchRemove(c, false);&#125; /** 只保留与 c 中元素相同的元素相同的元素*/public boolean retainAll(Collection&lt;?&gt; c) &#123; Objects.requireNonNull(c); return batchRemove(c, true);&#125; /** 批量删除的指定方法 */private boolean batchRemove(Collection&lt;?&gt; c, boolean complement) &#123; final Object[] elementData = this.elementData; // r w 两个角标 r 为 elementData 中元素的索引 // w 为删除元素后集合的长度 int r = 0, w = 0; boolean modified = false; try &#123; for (; r &lt; size; r++) // 如果 c 当前集合中不包含当前元素，那么则保留 if (c.contains(elementData[r]) == complement) elementData[w++] = elementData[r]; &#125; finally &#123; // 如果c.contains（o）可能会抛出异常，如果抛出异常后 r!=size 则将 r 之后的元素不在比较直接放入数组 if (r != size) &#123; System.arraycopy(elementData, r, elementData, w, size - r); // w 加上剩余元素的长度 w += size - r; &#125; // 如果集合移除过元素，则需要将 w 之后的元素设置为 null 释放内存 if (w != size) &#123; // clear to let GC do its work for (int i = w; i &lt; size; i++) elementData[i] = null; modCount += size - w; size = w; modified = true; &#125; &#125; //返回是否成功移除过元素，哪怕一个 return modified;&#125; 可以看到移除指定集合中包含的元素的方法代码量是目前分析代码中最长的了，但是逻辑也很清晰： 从 0 开始遍历 elementData 如果 r 位置的元素不存在于指定集合 c 中，那么我们就将他复制给数组 w 位置， 整个遍历过程中 w &lt;= r。 由于 c.contains(o)可能会抛出异常ClassCastException/NullPointerException，如果因为异常而终止（这两个异常是可选操作，集合源码中并没有显示生命该方法一定会抛异常），那么我们将会产生一次错误操作，所以 finally 中执行了判断操作，如果 r!= size 那么肯定是发生了异常，那么则将 r 之后的元素不在比较直接放入数组。最终得到的结果并不一定正确是删除了所有与 c 中的元素。 批量删除和保存中，涉及高效的保存/删除两个集合公有元素的算法，是值得我们学习的地方,写的真好哈哈哈哈哈！！！ ArrayList 的改查对于一个ArrayList 的改查方法就很简单了，set 和 get 方法。下面我们看下源码吧： 修改指定角标位置的元素1234567891011121314public E set(int index, E element) &#123; //角标越界检查 rangeCheck(index); //下标取数据注意这里不是elementData[index] 而是 elementData(index) 方法 E oldValue = elementData(index); //将 index 位置设置为新的元素 elementData[index] = element; // 返回之前在 index 位置的元素 return oldValue;&#125;E elementData(int index) &#123; return (E) elementData[index];&#125; 查询指定角标的元素123456public E get(int index) &#123; //越界检查 rangeCheck(index); //下标取数据注意这里不是elementData[index] 而是 elementData(index) 方法 return elementData(index); &#125; 查询指定元素的角标或者集合是否包含某个元素12345678910111213141516171819202122232425262728293031323334353637//集合中是否包含元素 indexOf 返回 -1 表示不包含 return false 否则返回 truepublic boolean contains(Object o) &#123; return indexOf(o) &gt;= 0;&#125;/*** 返回集合中第一个与 o 元素相等的元素角标，返回 -1 表示集合中不存在这个元素* 这里还做了空元素直接判断 == 的操作*/public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1;&#125;/** * 从 elementData 末尾开始遍历遍历数组，所以返回的是集合中最后一个与 o 相等的元素的角标*/public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1;&#125; ArrayList 集合的 toArry 方法其实 Object[] toArray(); 方法，以及其重载函数 \ T[] toArray(T[] a); 是接口 Collection 的方法，ArrayList 实现了这两个方法，很少见ArrayList 源码分析的文章分析这两个方法，顾名思义这两个方法的是用来，将一个集合转为数组的方法，那么两者的不同之处是，后者可以指定数组的类型，前者返回为一个 Object[] 超类数组。那么我们具体下源码实现： 1234567891011121314public Object[] toArray() &#123; return Arrays.copyOf(elementData, size);&#125;@SuppressWarnings("unchecked")public &lt;T&gt; T[] toArray(T[] a) &#123; if (a.length &lt; size) // Make a new array of a's runtime type, but my contents: return (T[]) Arrays.copyOf(elementData, size, a.getClass()); System.arraycopy(elementData, 0, a, 0, size); if (a.length &gt; size) a[size] = null; return a;&#125; 可以看到 Object[] toArray() 只是调用了一次 Arrays.copyOf() 将集合中元素拷贝到一个新的 Object[] 数组并返回。这个 Arrays.copyOf() 方法前边已经讲了。所以 toArray() 方法并没有什么疑问，有疑问的地方在于toArray(T[] a) 。 我们可以传入一个指定类型的标志数组作为参数，toArray(T[] a) 方法最终会返回这个类型的包含集合元素的新数组。但是源码判断了 ： 如果 a.length &lt; size 即当前集合元素的个数与参数 a 数组元素的大小的时候将和 toArray() 一样返回一个新的数组。 如果 a.length == size 将不会产生新的数组直接将集合中的元素调用 System.arraycopy() 方法将元素复制到参数数组中，返回 a。 a.length &gt; size 也不会产生新的数组,但是值得注意的是 a[size] = null; 这一句改变了原数组中 index = size 位置的元素，被重新设置为 null 了。 下面我们来看下第三种情况的例子： 12345678910111213141516171819202122232425SubClass[] sourceMore = new SubClass[4]; for (int i = 0; i &lt; sourceMore.length; i++) &#123; sourceMore[i] = new SubClass(i);&#125; //当 List.toArray(T[] a) 中 a.length == list.size 的时候使用 Array.copyOf 会将 list 中的内容赋值给 sourceMore 并将其返回//sourceMore[0,size-1] = list&#123;0, size-1&#125; 而 sourceMore[size] = nullSubClass[] sourceMore = new SubClass[4];for (int i = 0; i &lt; sourceMore.length; i++) &#123; sourceMore[i] = new SubClass(i);&#125;//list to Array 之前 sourceMore [SubClass&#123;test=0&#125;, SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, SubClass&#123;test=3&#125;] sourceEqual.length:: 4System.out.println("list to Array 之前 sourceMore " + Arrays.toString(sourceMore) + " sourceEqual.length:: " + sourceMore.length);SubClass[] desSourceMore = tLists.toArray(sourceMore);//list to Array 之后 desSourceMore [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, null, SubClass&#123;test=3&#125;]desSourceMore.length:: 4System.out.println("list to Array 之后 desSourceMore " + Arrays.toString(desSourceMore) + "desSourceMore.length:: " + desSourceMore.length);//list to Array 之后 source [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, null, SubClass&#123;test=3&#125;]sourceEqual.length:: 4System.out.println("list to Array 之后 source " + Arrays.toString(sourceMore) + "sourceEqual.length:: " + sourceMore.length);//source == desSource trueSystem.out.println("source == desSource " + (sourceMore == desSourceMore)); ArrayList 的遍历ArrayList 的遍历方式 jdk 1.8 之前有三种 ：for 循环遍历， foreach 遍历，迭代器遍历,jdk 1.8 之后又引入了forEach 操作，我们先来看看迭代器的源码实现： 迭代器迭代器 Iterator 模式是用于遍历各种集合类的标准访问方法。它可以把访问逻辑从不同类型的集合类中抽象出来，从而避免向客户端暴露集合的内部结构。 ArrayList 作为集合类也不例外，迭代器本身只提供三个接口方法： 12345public interface Iterator &#123; boolean hasNext();//是否还有下一个元素 Object next();// 返回当前元素 可以理解为他相当于 fori 中 i 索引 void remove();// 移除一个当前的元素 也就是 next 元素。 &#125; ArrayList 中调用 iterator() 将会返回一个内部类对象 Itr 其实现了 Iterator 接口。 123public Iterator&lt;E&gt; iterator() &#123; return new Itr();&#125; 下面让我们看下其实现的源码： 正如我们的 for 循环遍历一样，数组角标总是从 0 开始的，所以 cursor 初始值为 0 ， hasNext 表示是否遍历到数组末尾，即 i &lt; size 。对于 modCount 变量之所以一直没有介绍是因为他集合并发访问有关系，用于标记当前集合被修改（增删）的次数，如果并发访问了集合那么将会导致这个 modCount 的变化，在遍历过程中不正确的操作集合将会抛出 ConcurrentModificationException ，这是 Java 「fast-fail 的机制」，对于如果正确的在遍历过程中操作集合稍后会有说明。 12345678private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // 对照 hasNext 方法 cursor 应理解为下个调用 next 返回的元素 初始为 0 int lastRet = -1; // 上一个返回的角标 int expectedModCount = modCount;//初始化的时候将其赋值为当前集合中的操作数， // 是否还有下一个元素 cursor == size 表示当前集合已经遍历完了 所以只有当 cursor 不等于 size 的时候 才会有下一个元素 public boolean hasNext() &#123; return cursor != size; &#125; next 方法是我们获取集合中元素的方法，next 返回当前遍历位置的元素，如果在调用 next 之前集合被修改，并且迭代器中的期望操作数并没有改变，将会引发ConcurrentModificationException。next 方法多次调用 checkForComodification 来检验这个条件是否成立。 1234567891011121314151617@SuppressWarnings("unchecked") public E next() &#123; // 验证期望的操作数与当前集合中的操作数是否相同 如果不同将会抛出异常 checkForComodification(); // 如果迭代器的索引已经大于集合中元素的个数则抛出异常，这里不抛出角标越界 int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; // 由于多线程的问题这里再次判断是否越界，如果有异步线程修改了List（增删）这里就可能产生异常 if (i &gt;= elementData.length) throw new ConcurrentModificationException(); // cursor 移动 cursor = i + 1; //最终返回 集合中对应位置的元素，并将 lastRet 赋值为已经访问的元素的下标 return (E) elementData[lastRet = i]; &#125; 只有 Iterator 的 remove 方法会在调用集合的 remove 之后让 期望 操作数改变使expectedModCount与 modCount 再相等，所以是安全的。 12345678910111213141516171819202122// 实质调用了集合的 remove 方法移除元素public void remove() &#123; // 比如操作者没有调用 next 方法就调用了 remove 操作，lastRet 等于 -1的时候抛异常 if (lastRet &lt; 0) throw new IllegalStateException(); //检查操作数 checkForComodification(); try &#123; //移除上次调用 next 访问的元素 ArrayList.this.remove(lastRet); // 集合中少了一个元素，所以 cursor 向前移动一个位置（调用 next 时候 cursor = lastRet + 1） cursor = lastRet; //删除元素后赋值-1，确保先前 remove 时候的判断 lastRet = -1; //修改操作数期望值， modCount 在调用集合的 remove 的时候被修改过了。 expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; // 集合的 remove 会有可能抛出 rangeCheck 异常，catch 掉统一抛出 ConcurrentModificationException throw new ConcurrentModificationException(); &#125; &#125; 检查期望的操作数与当前集合的操作数是否相同。Java8 发布了很多函数式编程的特性包括 lamada 和Stream 操作。迭代器也因此添加了 forEachRemaining 方法，这个方法可以将当前迭代器访问的元素（next 方法）后的元素传递出去还没用到过，源码就不放出来了,大家有兴趣自己了解下。 1234567891011 @Override @SuppressWarnings("unchecked")public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123; //... Java8 的新特性，可以将当前迭代器访问的元素（next 方法）后的元素传递出去还没用到过，源码就不放出来了,大家有兴趣自己了解下。 &#125; // 检查期望的操作数与当前集合的操作数是否相同 final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125;&#125; ListIterator 迭代器ArrayList 可以通过以下两种方式获取 ListIterator 迭代器，区别在于初始角标的位置。不带参数的迭代器默认的cursor = 0 123456789public ListIterator&lt;E&gt; listIterator(int index) &#123; if (index &lt; 0 || index &gt; size) throw new IndexOutOfBoundsException("Index: "+index); return new ListItr(index);&#125; public ListIterator&lt;E&gt; listIterator() &#123; return new ListItr(0);&#125; ListItr对象继承自前边分析的 Itr，也就是说他拥有 Itr 的所有方法，并在此基础上进行扩展，其扩展了访问当前角标前一个元素的方法。以及在遍历过程中添加元素和修改元素的方法。 ListItr 的构造方法如下： 12345private class ListItr extends Itr implements ListIterator&lt;E&gt; &#123; ListItr(int index) &#123; super(); cursor = index;&#125; ListItr 的 previous 方法： 123456789101112131415161718192021222324252627282930public boolean hasPrevious() &#123; // cursor = 0 表示游标在数组第一个元素的左边，此时 `hasPrevious` 返回false return cursor != 0;&#125;public int nextIndex() &#123; return cursor;//调用返回当前角标位置&#125;public int previousIndex() &#123; return cursor - 1;//调用返回上一个角标&#125;//返回当前角标的上一个元素，并前移移动角标@SuppressWarnings("unchecked")public E previous() &#123; // fast-fail 检查 checkForComodification(); int i = cursor - 1; // 如果前移角标 &lt;0 代表遍历到数组遍历完成，一般在调用 previous 要调用 hasPrevious 判断 if (i &lt; 0) throw new NoSuchElementException(); //获取元素 Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); //获取成功后修改角标位置和 lastRet 位置 cursor = i; return (E) elementData[lastRet = i];&#125; ListItr 的 add 方法 1234567891011121314151617public void add(E e) &#123; // fast-fail 检查 checkForComodification(); try &#123; // 获取当前角标位置，一般的是调用 previous 后，角标改变后后去 cursor int i = cursor; //添加元素在角标位置 ArrayList.this.add(i, e); //集合修改完成后要改变当前角标位置 cursor = i + 1; //重新置位 -1 如果使用迭代器修改了角标位置元素后不允许立刻使用 set 方法修改修改后角标未知的额元素 参考 set 的源代码 lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125;&#125; 可能对比两个迭代器后，会对 curor 指向的位置有所疑惑，现在我们来看下一段示例代码对应的图： 1234567891011121314151617181920private void testListItr()&#123; ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(1); list.add(2); list.add(3); list.add(4); ListIterator&lt;Integer&gt; listIterator = list.listIterator(list.size()); while (listIterator.hasPrevious())&#123; if (listIterator.previous() == 2)&#123; listIterator.add(0); // listIterator.set(10); //Exception in thread "main" java.lang.IllegalStateException &#125; &#125; System.out.println("list " + list.toString());&#125; 由此可以看 cursor 于 数组角标不同，它可以处的位置总比角标多一个，因为在我们使用 Iterator 操作集合的时候，总是要先操作 cursor 移动， listIterator.previous 也好 iterator.next() 也好，都是一样的道理，如果不按照规定去进行操作，带给使用者的只有异常。 java8 新增加的遍历方法 forEachjava8增加很多好用的 API，工作和学习中也在慢慢接触这些 API，forEach 操作可能是我继 lambda 后，第一个使用的 API 了（囧），jdk doc 对这个方法的解释是： 对此集合的每个条目执行给定操作，直到处理完所有条目或操作抛出异常为止。 除非实现类另有规定，否则按照条目集迭代的顺序执行操作（如果指定了迭代顺序）。操作抛出的异常需要调用者自己处理。 其实其内部实现也很简单，只是一个判断了操作数的 for 循环，所以在效率上不会有提升，但是在安全性上的确有提升，也少些很多代码不是么？ 1234567891011121314151617@Overridepublic void forEach(Consumer&lt;? super E&gt; action) &#123; //检查调用者传进来的操作函数是否为空 Objects.requireNonNull(action); //与迭代不同期望操作被赋值为 final 也就是 forEach 过程中不允许并发修改集合否则会抛出异常 final int expectedModCount = modCount; @SuppressWarnings("unchecked") final E[] elementData = (E[]) this.elementData; final int size = this.size; //每次取元素之前判断操作数，确保操作正常 for (int i=0; modCount == expectedModCount &amp;&amp; i &lt; size; i++) &#123; action.accept(elementData[i]); &#125; if (modCount != expectedModCount) &#123; throw new ConcurrentModificationException(); &#125;&#125; 对于高级 for 循环以及最普通的 fori 方法这里不再赘述。下面我们看下面试会问到一个问题，也是我们在单线程操作集合的时候需要注意的一个问题，如果正确的在遍历过程中修改集合。 错误操作 1 在 for循环修改集合后继续遍历第一个例子： 1234567891011121314List&lt;SubClass&gt; list2 = new ArrayList&lt;&gt;();list2.add(new SubClass(1));list2.add(new SubClass(2));list2.add(new SubClass(3));list2.add(new SubClass(3));for (int i = 0; i &lt; list2.size(); i++) &#123; if (list2.get(i).test == 3) &#123; list2.remove(i); &#125;&#125;System.out.println(list2);//[SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;, SubClass&#123;test=3&#125;] 这个例子我们会发现，程序并没有抛出异常，但是从运行经过上来看并不是我们想要的，因为还有 SubClass.test = 3的数据在，这是因为 remove 操作改变了list.size(),而 fori 中每次执行都会重新调用一次lists2.size()，当我们删除了倒数第二个元素后，list2.size() = 3,i = 3 &lt; 3 不成立则没有在进行 remove 操作，知道了为什么以后我们试着这样改变了循环方式： 123456789int size = list2.size();for (int i = 0; i &lt; size; i++) &#123; if (list2.get(i).test == 3) &#123; list2.remove(i);//remove 以后 list 内部将 size 重新改变了 for 循环下次调用的时候可能就不进去了 &#125;&#125;System.out.println(list2);//Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 3, Size: 3 果真程序抛出了角标越界的异常，因为这样每次 fori 的时候我们不去拿更新后的 list 元素的 size 大小，所以当我们删除一个元素后，size = 3 当我们 for 循环去list2.get(3)的时候就会被 rangeCheck方法抛出异常。 错误操作导致 ConcurrentModificationException 异常我们分析迭代器的时候，知道 ConcurrentModificationException是指因为迭代器调用 checkForComodification 方法比较 modCount 和 expectedModCount 方法大小的时候抛出异常。我们在分析 ArrayList 的时候在每次对集合进行修改， 即有 add 和 remove 操作的时候每次都会对 modCount ++。 modCount 这个变量主要用来记录 ArrayList 被修改的次数，那么为什么要记录这个次数呢？是为了防止多线程对同一集合进行修改产生错误，记录了这个变量，在对 ArrayList 进行迭代的过程中我们能很快的发现这个变量是否被修改过，如果被修改了 ConcurrentModificationException 将会产生。下面我们来看下例子，这个例子并不是在多线程下的，而是因为我们在同一线程中对 list 进行了错误操作导致的： 12345678910111213Iterator&lt;SubClass&gt; iterator = lists.iterator();while (iterator.hasNext()) &#123; SubClass next = iterator.next(); int index = next.test; if (index == 3) &#123; list2.remove(index);//操作1： 注意是 list2.remove 操作 //iterator.remove()；/操作2 注意是 iterator.remove 操作 &#125;&#125;//操作1： Exception in thread "main" java.util.ConcurrentModificationException//操作2： [SubClass&#123;test=1&#125;, SubClass&#123;test=2&#125;]System.out.println(list2); 我们对操作1，2分别运行程序，可以看到，操作1很快就抛出了 java.util.ConcurrentModificationException 异常，操作2 则顺利运行出正常结果，如果对 modCount 注意了的话，我们很容易理解，list.remove(index) 操作会修改List 的 modCount，而 iterator.next() 内部每次会检验 expectedModCount != modCount，所以当我们使用 list.remove 下一次再调用 iterator.next() 就会报错了，而iterator.remove为什么是安全的呢？因为其操作内部会在调用 list.remove 后重新将新的 modCount 赋值给 expectedModCount。所以我们直接调用 list.remove 操作是错误的。对于多线程的影响这里不在展开这里推荐有兴趣的朋友看下这个文章 Java ConcurrentModificationException异常原因和解决方法; 经过了一轮分析我们我们知道了错误产生原因了，但是大家是否能真的分辨出什么操作是错误的呢？我们来看下边这个面试题，这是我在网上无意中看到的一道大众点评的面试题： 123456789ArrayList&lt;String&gt; list = new ArrayList&lt;String&gt;();for (int i = 0; i &lt; 10; i++) &#123; list.add("sh" + i);&#125;for (int i = 0; list.iterator().hasNext(); i++) &#123; list.remove(i); System.out.println("秘密" + list.get(i));&#125; 一道面试题相信大家肯定知道这样操作是会产生错误的，但是最终会抛出角标越界还是ConcurrentModificationException呢？ 其实这里会抛出角标越界异常，为什么呢，因为 for 循环的条件 list.iterator().hasNext()，我们知道 list.iterator() 将会new 一个新的 iterator 对象，而在 new 的过程中我们将 每次 list.remove 后的 modCount 赋值给了新的 iterator 的 expectedModCount，所以不会抛出 ConcurrentModificationException 异常，而 hasNext 内部只判断了 size 是否等于 cursor != size 当我们删除了一半元素以后，size 变成了 5 而新的 list.iterator() 的 cursor 等于 0 ，0!=5 for 循环继续，那么当执行到 list.remove（5）的时候就会抛出角标越界了。 总结 ArrayList 底层是一个动态扩容的数组结构,每次扩容需要增加1.5倍的容量 ArrayList 扩容底层是通过 Arrays.CopyOf 和 System.arraycopy 来实现的。每次都会产生新的数组，和数组中内容的拷贝，所以会耗费性能，所以在多增删的操作的情况可优先考虑 LinkList 而不是 ArrayList。 ArrayList 的 toArray 方法重载方法的使用。 允许存放（不止一个） null 元素， 允许存放重复数据，存储顺序按照元素的添加顺序 ArrayList 并不是一个线程安全的集合。如果集合的增删操作需要保证线程的安全性，可以考虑使用 CopyOnWriteArrayList 或者使collections.synchronizedList(List l)函数返回一个线程安全的ArrayList类. 不正确访问集合元素的时候 ConcurrentModificationException和 java.lang.IndexOutOfBoundsException 异常产生的时机和原理。本文又长篇大论的分析了一波 ArrayList 的源码，对我个人而言这很有意义，在查看源码的过程中，注意到了平时很少有机会接触的知识点。当然这只是集合源码分析的开端，以后还会更细，其他常用集合源码的分析。如果大家感觉我写的还可以， 请留言 + 点赞 + 关注。 ** 转载：搞懂 Java ArrayList 源码]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ArrayList</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JAVA对数组的四种拷贝方式]]></title>
    <url>%2F2019%2F10%2F07%2FJAVA%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[数组拷贝的四种方式 for clone System.arraycopy arrays.copyof 赋值、浅拷贝、深拷贝在谈及四种数组拷贝方式之前，先来缕缕赋值、浅拷贝、深拷贝三者的关系和区别。 数据类型谈及深拷贝和浅拷贝，首先要弄清数据类型有哪些,数据分为基本数据类型(元数据)和引用数据类型(对象引用)。 基本数据类型的特点：直接存储在栈(stack)中的数据 引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里，引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 深拷贝和浅拷贝 深拷贝和浅拷贝是只针对引用类型的数据而言的，对于基本数据类型来说，深拷贝和浅拷贝都是直接进行值传递的，与赋值的方式是一样的，三者没有任何区别，区别就在于对于引用数据类型来说，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存,所以如果修改对象的话会互相影响。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 总而言之，在数组内都是基本数据类型时，是不会有深拷贝和浅拷贝这样的概念出现的，只有出现了引用类型的数据，才能谈深拷贝和浅拷贝。Tips: String不是基本数据类型，但是在深复制的时候并没有进行单独的复制，也就是说违反了深复制，仅仅复制了引用，而String没有实现cloneable接口，也就是说只能复制引用。 那么在修改克隆之后的对象之后，会不会将原来的值也改变了? 答案肯定是不会改变，因为String是在内存中不可以被改变的对象，就比如说在for大量循环中不推荐使用+的方式来拼凑字符串一样，每次使用都会新分配一块内存，不在原来上修改，原来的没有指向它的引用，会被回收。所以克隆相当于1个String内存空间有两个引用，当修改其中的一个值的时候，会新分配一块内存用来保存新的值，这个引用指向新的内存空间，原来的String因为还存在指向他的引用，所以不会被回收，这样，虽然是复制的引用，但是修改值的时候，并没有改变被复制对象的值。 数组拷贝方式之一——for()就是for循环咯！！！ 12345/** 1 for 循环拷贝*/int[] arr1 = new int[len];for (int i = 0; i &lt; len; i++) &#123; arr1[i] = arr0[i];&#125; 也是浅拷贝咯！ 数组拷贝方式之二——clone()（主要参考）细说 Java 的深拷贝和浅拷贝 在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中，使用它。而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。 首先需要说明的是，clone()是浅拷贝的方式！！！其次，我们应该如何实现深拷贝呢，有两种方法： 用多层浅拷贝达到深拷贝的目的，要知道，浅拷贝和深拷贝的区别就是在处理对象引用时，浅拷贝不会创造新的对象，而深拷贝会，但是如果一个对象的属性变成了基本类型数据，那么浅拷贝同样会创造新的对象，所以说，多层浅拷贝就能达到深拷贝的目的，例如：在对fatherClass和childClass进行两级浅拷贝之后，fatherB就有浅拷贝变成了深拷贝，因为此时基本数据类型和Child对象都是指向不同的地址的，也就是二者都是不同的对象，所以就是达到了深拷贝的目的了。 序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。总结下来就是做了5件事： 确保对象图中的所有类都是可序列化的 创建输入输出流 使用这个输入输出流来创建对象输入和对象输出流 将你想要拷贝的对象传递给对象输出流 从对象输入流中读取新的对象并且转换回你所发送的对象的类 最后，推一个序列化实现深拷贝的例子：序列化的方式使得其变为深拷贝 数组拷贝方式之三——System.arraycopy()native方法，依旧是一个浅拷贝——–&gt; 详细传送门 数组拷贝方式之四——arrays.copyof()1234567891011public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") //根据class的类型是否是 Object[] 来决定是 new 还是反射去构造一个泛型数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //使用 native 方法批量赋值元素至新数组中。 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 你看看，底层也在用System.arraycopy()这个native方法，所以就不再赘述了，这个在ArrayList源码分析中也有涉及哦！！！！]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>JAVA</tag>
        <tag>数组</tag>
        <tag>Array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.2----10.7收获]]></title>
    <url>%2F2019%2F10%2F02%2F10-2-10-7.html</url>
    <content type="text"><![CDATA[10.2 学习完ajax异步调用； 完成添加然后数据库里有数据并且能正常跳转； b站上再看看springboot+mybatis的结合； 总结博客，分别总结分页排序还要mongodb在springboot中的相关操作； 收获 springboot启动很慢的原因：未修改host目录的文件，导致每次启动都很慢。步骤 在terminal终端输入: 1$ hostname 复制下来，然后修改host文件中的localhost： 1$ sudo vim /etc/hosts 然后将自己hostname替换掉localhost 123127.0.0.1&lt;两个tab&gt;localhost 替换为$hostname255.255.255.255&lt;两个tab&gt;broadcasthost::1&lt;两个tab&gt;localhost 替换为$hostname 在js传值给controller时，一直不能将json数据传过去，原因是没有给data的值加上JSON.stringify()处理，具体错误：springboot 接收参数，解析json出现错误：was expecting ‘null’, ‘true’, ‘false’ or NaN解决方案：见—-&gt;js与controller之间传值常见问题 JQuery.ajaxajax和springboot传值 jquery中字符串转日期，日期转字符串 MyBatis主键回填策略 表中部分属性自动生成，不需要额外传入参数 先是尝试了在bean中加@value，加载配置文件中的随机数，但是发现执行一次，随机数是唯一的，这样就不能做到插入一条数据，随机数就变化； 后面发现可以在mybatis直接配置结果集，好像也不行…因为如果你用结果集将id转换为taskId,那原本bean中的id属性就会取不到值… jQuery获取html中的值获取html中的值 10.3收获使用最大的id！！！mysql插入数据后返回自增ID的方法（AUTO_INCREMENT） 10.4收获 复杂json转成多层map 12345678910111213141516171819public Map&lt;String, Object&gt; parseJSON2Map(@RequestBody String jsonStr)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); JSONObject json = JSONObject.parseObject(jsonStr); for(Object k : json.keySet())&#123; Object v = json.get(k); if(v instanceof JSONArray)&#123; List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); Iterator it = ((JSONArray)v).iterator(); while(it.hasNext())&#123; Object json2 = it.next(); list.add(parseJSON2Map(json2.toString())); &#125; map.put(k.toString(), list); &#125; else &#123; map.put(k.toString(), v); &#125; &#125; return map; &#125; mac强制刷新缓存：command + shift + R普通刷新：command + R Springboot使用多线程 最近遇到一个需求，就是当服务器接到请求并不需要任务执行完成才返回结果，可以立即返回结果，让任务异步的去执行。开始考虑是直接启一个新的线程去执行任务或者把任务提交到一个线程池去执行，这两种方法都是可以的。但是 Spring 这么强大，肯定有什么更简单的方法，就 google 了一下，还真有呢。就是使用 @EnableAsync 和 @Async 这两个注解就 ok 了。传送门：SpringBoot非官方教程 | 第二十三篇： 异步方法 首先声明一下自己用了比较长的时间才弄出来的原因是，自己把异步方法写到了Controller层，导致在controller的另一个方法调用时无法开启异步功能，所以对此我有三点见解： 在@SpringBootApplication启动类 添加注解@EnableAsync 异步方法使用注解@Async ,返回值为void或者Future 切记一点，异步方法和调用方法一定要 写在不同的类中,如果写在一个类中，是没有效果的，至于为什么—-&gt;因为Spring像@Transaction @Async等这些都是使用了动态代理，Spring容器在初始化的时候就会将含有AOP注解的类对象替换为代理对象，再由Proxy对象去调用被增强方法，重点来了：方法里想用增强方法(第三点)则需要得到当前的Proxy对象，但如果是同一个类的话，是不会经过spring容器的，此时是真正的对象本身去调用方法，并不是代理对象，这样的话被增强方法就失效了，详情请看 -&gt;Spring的 AopContext.currentProxy()方法 解决方案 我采用的方案是，将异步方法写入service层，然后再controller层中调用，这样就经过了spring容器，调用方法时就是采用的代理对象。 第二种方法，我没有成功！！！！真的是气的不行，因为我看网上博客别人都成功了……就是用AopContext.currentProxy()这个方法,步骤为： 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类中添加注释 1@EnableAspectJAutoProxy(exposeProxy=true,proxyTargetClass=true) 然后在调用方法处写： 1((TaskController)AopContext.currentProxy()).testAsy("www.baidu.com"); 按理说应该可以了的，结果吧，我一跑程序就报错，说我的哦代理怎么没暴露啊，我真是卧槽了，那他妈不是已经配置了暴露了嘛！！！我服了！！！算了，懒得搭理了…甩个跟这个原理一样的链接，学习一下：JDK动态代理给Spring事务埋下的坑！再甩一个链接，三种方法配置这个exposeProxy(然而我一个都没成功…)—-&gt;springboot中如何配置aop动态代理模式 (原创)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-9-26]]></title>
    <url>%2F2019%2F09%2F26%2F2019-9-26.html</url>
    <content type="text"><![CDATA[今日任务 springboot + mongodb,完成mongo在springboot中的搭建，写一个小demo 最主要的是把repository这一层写完，业务逻辑可以放到明天来写 完成过程mongodb的安装macOS下mongodb的安装与启动 Springboot下的相关注解 @DataData注解使用 @Document标注在实体类上，类似于hibernate的entity注解，标明由mongo来维护该表，collection代表表的名称。SpringBoot中MongoDB中的相关注解 @Entity等一系列Spring Data JPA注解 @DynamicUpdate、@DynamicInsert 是hibernate里面的注解，这两个注解加上之后就不会为字段值不变的字段生成sql语句，这样sql的长度就减少了提高了传输效率和执行效率，在插入和修改数据的时候,语句中只包括要插入或者修改的字段。 @Entity 标识这个实体类是一个JPA实体，告诉JPA在程序运行的时候记得生成这个实体类所对应的表~！ GeneratedValue、GenericGenerator是用于主键生成策略的，具体见JPA注解主键生成策略-UUID @Column（name = “自定义字段名”，length = “自定义长度”，nullable = “是否可以空”，unique = “是否唯一”，columnDefinition = “自定义该字段的类型和长度”）。表示对这个变量所对应的字段名进行一些个性化的设置，例如字段的名字，字段的长度，是否为空和是否唯一等等设置。 剩余注释：Spring Data JPA中常用的注解详解 @Controller（Spring Boot之 Controller 接收参数和返回数据总结(包括上传、下载文件)）Controller层的注解大概有以下一些：（主要参考：Controller层主要注解） @Controller:标注 Controller 类，处理 http 请求 @RestController:标注 Controller 类，spring 4 新加注解，相当于@Controller + @ResponseBody ，主要是为了使 http 请求返回数据格式为 json 格式，正常情况下都是使用这个注解 @RequestMapping:配置 url 映射，可以作用于类上，也可以在方法上 123456789@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.GET) public String say() &#123; return "我是张少林"; &#125;&#125; @RequestMapping 定义在类上，指定该类下的所有接口 url 映射在 /users 下，定义在方法上，指定 请求方法，可以指定GET，POST，DELETE，PUT四种标准的 Restfulapi请求方法。那么此时的接口 url 为：http://127.0.0.1:8080/users/myInfo 请求方法：GET，类上也可以不用配置 url 映射的。 @PathVariable获取 url 中的数据，我们在 url 中拼接一个字符串 {username}，类似于地址占位符，由用户请求时添加，请求获取。注意注解中的参数必须与占位符参数一致 12345678@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo/&#123;username&#125;", method = RequestMethod.GET) public String say(@PathVariable("username") String username) &#123; return username; &#125;&#125; @RequestParam获取请求参数值，方法随意可以设置，但是通常需求都是使用 POST 请求处理表单提交。 12345678@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.POST) public String say(@RequestParam(value = "username") String username, @RequestParam(value = "password") String password) &#123; return username + password; &#125;&#125; 假如用户输入的的uri是:http://127.0.0.1:8080/users/myInfo?username=yangweijie&amp;password=123456，那么最后返回的是yangweijie123456，如果参数不带值且添加属性required=true，则会报错，此时就建议添加一个defaultValue属性： 12345678910@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.POST) public String say(@RequestParam(value = "username",required = false,defaultValue = "张少林") String username, @RequestParam(value = "password",required = false,defaultValue = "123456") String password) &#123; return username + password; &#125;&#125; @GetMapping、@PostMapping、@DeleteMapping、@PutMapping等是RequestMapping的组合注解，根据method的不同。 @RequestHeader可以把Request请求header部分的值绑定到方法的参数上。 @CookieValue可以把Request header中关于cookie的值绑定到方法的参数上。 RequestBody该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api; ModelAttribute(参考：Spring MVC @ModelAttribute详解)@ModelAttribute有三种用法： 可以标注在方法上； 可以标注在方法中的参数上； 还可以和@RequestMapping一起标注在方法上；目的都是在RequestMapping之前进行model属性的注入，对RestController好像没用，因为是返回json数据，并不能将model里面的数据直接返回给页面。如果没用@RestController，则@ModelAttribute方法通常被用来填充一些公共需要的属性或数据，比如一个下拉列表所预设的几种状态，或者宠物的几种类型，或者去取得一个HTML表单渲染所需要的命令对象，比如Account等。@ModelAttribute标注方法有两种风格： 12345678910111213141516// Add one attribute// The return value of the method is added to the model under the name "account"// You can customize the name via @ModelAttribute("myAccount")@ModelAttributepublic Account addAccount(@RequestParam String number) &#123; return accountManager.findAccount(number);&#125;// Add multiple attributes@ModelAttributepublic void populateModel(@RequestParam String number, Model model) &#123; model.addAttribute(accountManager.findAccount(number)); // add more ... &#125; 在第一种写法中，方法通过返回值的方式默认地将添加一个属性，在第二种写法中，方法接收一个Model对象，然后可以向其中添加任意数量的属性，可以在根据需要，在两种风格中选择合适的一种。model里的数据会被放入到request中,页面通过request域可以获取到。 @SessionAttributes和@SessionAttribute@SessionAttributes注解的使用就是将属性放入session域内，然后可以在session域内进行相关的操作。 SpringMVC中@ModelAttribute和@SessionAttributes注解的使用 @id（好像如果表中数据字段是id，会比较特殊一点，springboot会自动检索传过来的参数是否有id，如果没有会自动添加id） Repository相关注解 Springboot的分页和排序操作由于采用的是Mongo数据库，所以先后使用了MongoTemplate()和MongoRepository(),MongoTemplate在写法上比MongoRepository 更复杂一些，但是带来更多的灵活性。对于复杂的查询操作，我们一般使用MongoTemplate，对于一些简单的查询我们会使用MongoRepository 。可以这么理解，MongoRepository 只是作为一种对于简单查询的简便操作，而MongoTemplate才是我们在做一些复杂查询时的首选。 MongoRepository自己还借用了下@Query和@Modifying注解，方便自己摆脱关键字的查询，如果需要进行更新或者删除数据，则需要在@Query之上加上@Modifing。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度前端技术学院66天学习(争取一个月内完成！)]]></title>
    <url>%2F2019%2F09%2F23%2F%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A266%E5%A4%A9%E5%AD%A6%E4%B9%A0-%E4%BA%89%E5%8F%96%E4%B8%80%E4%B8%AA%E6%9C%88%E5%86%85%E5%AE%8C%E6%88%90%EF%BC%81.html</url>
    <content type="text"><![CDATA[day 1:日期，今天的学习总用时，今天学习的目标是什么，是否达成 今天是2019.9.20，距离春招还有将近6个月的时间，预计1个半月将ife学完并且将js看完，后期开始刷leetcode和vue框架的学习 今天的学习时长总用时为30min 今天的学习目标是搭建好前端环境，做好长期准备学习的过程 目标已达成，将以博客的形式每天更新自己所学内容 哪些东西今天了解得比较透彻，说说自己的理解今天最大的收获是看到了许多非常极具创意的web，也激励自己能够更好的学习前端知识，希望半年后的自己能有一个大大的成长吧！！！ 哪些东西今天了解到了一些，还有哪些点需要后续继续深入阅读今天的内容好像没有什么难的，项目也比较忙，最近在看js，大概看完了前面4章了，后续尽量加快一些进度 哪些东西今天学了之后还有很多疑问没有被解答，把问题记录下来，以待后续解决今天暂无 立Flag，写下大家参加今年前端学院的目标找到一份好实习，找到一份好工作，成为更好的自己 day 2：问题： 这里面的可枚举属性名不知道啥意思； 个人暂时理解：就是是否可遍历的意思 对这个Object.prototype不熟悉！！！ day 3：问题： 图中为什么用Object.defineProperty()就可以完成对writable:false的属性的修改，但是直接用obj.属性的形式就不行？图中所谓的原型链又是什么意思？ 图中的JSON.stringify方法没有接触]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>ife</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习]]></title>
    <url>%2F2019%2F09%2F21%2FJS%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[学习过程：promise—&gt;箭头函数—&gt;作用域—&gt;闭包 js基础入门篇基本语法变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。其中，函数名同样被视为变量名，所以一样会被提升到代码头部。 标识符 不能以数字开头，可以以 _ 和 $ 开头 JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 标签js允许语句前面可以带有标签，方便跳出块区域和多重循环，常与for循环、continue、break连用。 数据类型##null，布尔值 boolean如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN “”或’’（空字符串） 注意，{}和[]都是true。 数值 js中所有数都是小数，64位，其中符号位1位，表示指数的11位，剩余的52位表示精度，但是由于表示精度的最高位1.xxxx中的1被省略，所以可以表示53位精度； parseInt即将字符串转换为整数型，不管是不是字符串，都会先转换为字符串,再转为整数型，其中，parseInt可以传入两个参数，第二个参数可以是转换进制值； 字符串 想输出多行字符串，有一种利用多行注释的变通方法 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\n').slice(1, -1).join('\n')// "line 1// line 2// line 3" Base64转码 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = 'Hello World!';btoa(string) // "SGVsbG8gV29ybGQh"atob('SGVsbG8gV29ybGQh') // "Hello World!" * 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好" 对象 对象的引用两个变量同时指向同一个对象，其中任何一个变量添加属性，另一个变量都可以读写该属性，但是如果取消某个变量对于原对象的引用，并不会影响到另一个变量；注意:仅限于对象，如果两个变量同时指向同一个原始类型的值，那么变量此时都是值的拷贝而已； 如果行首是一个大括号，js引擎一律将其解释为代码块，如果想要表示为对象，则必须在大括号前加上一个圆括号，这种差异在eval语句（作用是对字符串求值）中体现的尤为明显； 12eval('&#123;foo: 123&#125;') // 123eval('(&#123;foo: 123&#125;)') // &#123;foo: 123&#125; 属性读取：一种使用点运算符，另外一种采用方括号运算符，注意若使用方括号运算符，键名必须放在引号里面，否则会被当做变量处理： 123456789var foo = 'bar';var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 查看一个对象本身所有属性，可以使用Object.keys方法 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// ['key1', 'key2'] 属性的遍历：for…in 循环: 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log('键名：', i); console.log('键值：', obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 with语句：作用是操作同一个对象的多个属性时，提供方便，但是不建议使用，因为在with语句里面没有改变作用域，导致绑定对象不明确，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 函数函数声明 function命令 123function print(s)&#123; console.log(s);&#125; 函数表达式(如果function后带函数名，函数名也只在函数体内部有效) 1var print = function()&#123;console.log(s)&#125;; Function构造函数 12345678910var add = new Function( 'x', 'y', 'return x + y');// 等同于function add(x, y) &#123; return x + y;&#125; 函数ToString可以解析注释实现多行字符串： 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split('\n'); return arr.slice(1, arr.length - 1).join('\n');&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// " 这是一个// 多行注释" 函数作用域在ES6中，有三种作用域：全局作用域、块作用域、函数作用域。函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。所以说，如果函数A调用函数B,函数B不会引用函数A的内容。 参数传值 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递； 函数参数如果是复合类型的值（数组、对象、其他函数），传递方式是传址传递； 函数内部修改的如果是参数对象的某个属性，那么会影响到原始值，如果是替换掉整个参数，则不会影响到原始值： 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] arguments arguments对象包含了函数运行时的所有参数，但是它并不是一个数组，而是一个对象，所以它不能用数组中的slice和forEach方法； 在正常模式下，arguments对象可以在运行时修改，但是在严格模式下，修改arguments对象的值并不会改变真实参数的值； 如果要让arguments对象使用数组方法，真正的解决办法就是让arguments对象变为数组，常用的转换方法有两种，分别是slice方法和逐一填入新数组： 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; 闭包闭包，简而言之就是函数中的函数，闭包最大的特点，就是它可以“记住”诞生的环境，用处有三个： 1. 可以读取函数内部的变量； 2. 让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在; 3. 封装对象的私有属性和私有方法。 123456789101112131415161718192021222324252627282930313233function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7``` ```jsfunction Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person('张三');p1.setAge(25);p1.getAge() // 25 “立即调用的函数表达式”（Immediately-Invoked Function Expression）123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 eval 本质是在当前域中注入代码，可以接受一个字符串作为参数，并且将该字符串当做语句执行，如果识别不是字符串，则会原样返回。 同时，eval没有自己的作用域，会改变当前域原有变量的值，当然在严格模式下，eval内部自己声明的变量有自己的作用域，不会影响到外部作用域的值。 由于引擎无法分辨eval的别名调用，所以在eval使用别名时，一律都是全局作用域。 数组数组遍历 数组遍历可以考虑使用for循环、while循环、forEach循环，会返回键值（键名为整数），for…in…循环会同时遍历非整数键（返回的是键名）； 数组遍历空位时，需要格外注意，空位和undefined是不一样的，空位表示数组中没有这个元素，所以在for…in…和forEach循环中不会被遍历到，但是undefined代表数组有这个元素，是会遍历到的； 运算符算术运算符加法运算符 对象的相加如果运算子是对象，必须先转成原始类型的值，引擎会自动调用obj.valueof().toString(),所以我们可以重新valueOf()和toString()方法即可，其中有个特例，当运算子是一个Date对象的实例，那么会优先执行toString方法。 指数运算符** 为指数运算符，是右结合的，当然，三元条件运算符也是右结合的，当然还有赋值运算符（=）也是右结合的。 比较运算符 严格相等运算符JavaScript 提供两种相等运算符：== 和 === 。简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。tip: undefined和null与自身严格相等布尔运算符略二进制位运算符略 其他运算符，运算顺序void 运算符void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined，主要用途是浏览器的书签工具，以及在超链接中插入代码防止网页跳转。 语法专题错误处理机制原生错误类型 SyntaxError ReferenceError RangeError TypeError URIError EvalError 自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象 1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了 1new UserError('这是自定义的错误！'); 标准库Object四个用法： Object本身就是一个函数，可以将任意值转换为对象； 不仅可以当做工具函数使用，还可以当做构造函数使用，即前面可以加new命令； 1注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = &#123;&#125;是等价的。或者说，后者只是前者的一种简便写法。 Object的静态方法，例如Object.print,指部署在Object对象自身的方法； Object的实例方法，即定义在Object.prototype对象上的方法。 Object.prototype.valueof() Object.prototype.toString() Object.prototype.toLocaleString() Object.prototype.hasOwnProperty() Object.prototype.isPrototypeof() Object.prototype.propertyIsEnumerable() 属性描述对象js提供了一个内部数据结构，用来描述对象的属性，比如是否可写可读可遍历，这个内部数据结构就称之为“属性描述对象”。 tip:Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。而这跟Object.keys的行为不同，Object.keys只返回对象自身的可遍历属性的全部属性名。 123456789101112Object.keys([]) // []Object.getOwnPropertyNames([]) // [ 'length' ]Object.keys(Object.prototype) // []Object.getOwnPropertyNames(Object.prototype)// ['hasOwnProperty',// 'valueOf',// 'constructor',// 'toLocaleString',// 'isPrototypeOf',// 'propertyIsEnumerable',// 'toString'] 上面代码中，数组自身的length属性是不可遍历的，Object.keys不会返回该属性。第二个例子的Object.prototype也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的。 Object.defineProperty(),Object.defineProperties()Object.defineProperty()方法接收三个参数，依次如下： Object：属性所在的对象 propertyName:字符串，表示属性名 attributesObject:属性描述对象 1234567891011var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, writable: false, enumerable: true, configurable: false&#125;);obj.p // 123obj.p = 246;obj.p // 123 Object.defineProperties()接收两个参数，如下： 123456789101112var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: 'abc', enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;&#125;);obj.p1 // 123obj.p2 // "abc"obj.p3 // "123abc" Object.prototype.propertyIsEnumerable()返回一个布尔值，用来判断自身属性是否可以遍历。Object.keys是返回所有可以遍历的属性，不包括继承的属性，而Object.getOwnPropertyNames则是返回包括继承的属性在内的所有可以遍历的属性。 es6入门len和const命令lenlen没有变量提升必须先声明后才能使用，注意len变量只在块区域内有用，是块级作用域，而var不同，var具有全局作用域、函数作用域； 暂时性死区123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。非常隐蔽的“死区”： 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。但在ES6中，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined node js入门]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Microsoft Remote Desktop for mac 和 Spark邮箱]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%BD%BF%E7%94%A8Microsoft-Remote-Desktop-for-mac-%E5%92%8C-Spark%E9%82%AE%E7%AE%B1.html</url>
    <content type="text"><![CDATA[前言由于近期需要远程控制windows服务器，所以需要选择一个远程操控的软件，由于mac端并没有嵌入相关的功能，只能选择Microsoft Remote Desktop，并且遗憾的是，在中国区的app store并没有允许其上线，所以要做的第一步就是申请一个美区账号。 步骤 chrome打开apple id注册 按步骤注册，国家填写美国，注册完成之后需要登录一下 登录的时候会要求填写地址，以下是可用的信息街道: 4114 Sepulveda Blvd，城市: Culver City，州: CA邮编: 90230电话: (626) 339-6***商家名称: Clippinger Chevrolet Oldsmobile注意电话号码后三位随便填写几个数字 登录App Store，然后下载即可使用 Spark写这个主要是想吐槽一下，看到网上b乎各种说spark可以接收推送，即使没有打开软件，我想说简直是放屁啊，导致我查了几个小时都没能成功，根本做不到好吗！！！不信？看官网怎么说的 ——–&gt;Spark帮助中心所以只能一直开着了…垃圾的一批！！！！！！]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最近事宜]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%9C%80%E8%BF%91%E4%BA%8B%E5%AE%9C.html</url>
    <content type="text"><![CDATA[最近生病了…加上开学事情很多…停更了一个星期 接下来会慢慢跟上的加油🆙]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask + PyJWT 实现基于Json Web Token的用户认证授权]]></title>
    <url>%2F2019%2F08%2F23%2FFlask-PyJWT-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EJson-Web-Token%E7%9A%84%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83.html</url>
    <content type="text"><![CDATA[前言这注定又将是一篇长文，接触到的第一个关于python的框架flask，本文将从最开始的安装flask，到与mysql结合，最后到用pyjwt和flask-jwt和restful写一个带有token的接口。 技术栈简介Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI(PythonWeb服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI)是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标)工具箱和Jinja2 模板引擎。 Flask使用BSD授权。 Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数据库、窗体验证工具。然而，Flask保留了扩增的弹性，可以用Flask-extension加入这些功能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术 SQLAlchemyFlask是一个微型框架，自身没有提供数据库管理，表单验证，cookie处理等功能，很多功能需要通过扩展才能实现，数据库管理就需要SQLAlchemy。SqlAlchemy是Python编程语言下的一款ORM框架，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简而言之：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果。 The first demo123456789from flask import Flaskapp = Flask(__name__)@app.route("/")def index(): return "hello world"if __name__ == '__main__': app.run() 第一行 from…import…就是导入flask中的Flask模块，不同于直接import，from…import简单来说就是帮我从车里拿瓶水，而import则是把车拿过来，所以二者在使用的时候还是有些区别的，在导入某个.py文件时，使用from…import…可以直接在该文件夹下使用import后的函数名，而如果是import，如果要调用函数必须用类.模块。 第二行 这行代码里有一个参数name，这个参数用到告诉flask你的application的名字，官方有一句话： 12If you are using a single module,__name__ is always the correct value.If you however are using a package, it’s usually recommended to hardcode the name ofyour package there. 意思就是说，如果是单一的应用，用name就可以了，如果是一个应用程序包，就hardcode一个名字给这个参数。比如： 1app = Flask(“myApp”) 由于目前我们的应用都相对简单，所以统一使用name作为参数。 第三行 使用route()修饰器注明通过什么样的url可以访问我们的函数，同时在函数中返回要显示在浏览器中的信息。 最后 调用run()方法，运行flask web应用程序 12if __name__ == '__main__': app.run() 其中if __name__==&#39;__main__&#39;的意思是，如果此文件是直接运行的才会执行app.run()这个方法，如果是通过import在其它py文件中调用的话是不会执行的。 比如我们修改code.py中的hello_world方法，如下： 1234567@app.route('/index')def hello_world(): if __name__=='main': return 'Hello World!' else: return "hello my name is "+__name__ 即当name为main时还是执行原来的逻辑，返回hello world，如果不是则输出此时的名字。 然后我们新建一个sub.py文件然后导入code.py，并且执行hello_world方法: 1234567import codedef CallCodeFun(): result = code.hello_world() print(result)CallCodeFun()print(__name__) 此时的name是Code而不是main，而此时，在sub.py中加一句print(name)可以发现sub.py中的name变成了main 由此我们可以得出 name 如果是 main 那么代表他是一个入口文件，直接执行的。 tip:建文件时文件名最好不要叫code，因为python有模块名就叫code。 flask-sqlalchemy 数据库配置，上demo 12345678910111213141516171819202122from flask_sqlalchemy import SQLAlchemyfrom flask import Flaskimport configparser# 告诉flask app的名字app = Flask(__name__)//通过configparser获取读取配置文件的解释器my_config = configparser.ConfigParser()my_config.read('db.conf')# dialect+driver://username:password@host:port/database?charset=utf8# 配置 sqlalchemy 数据库驱动://数据库用户名:密码@主机地址:端口/数据库?编码# py3无法继续使用sqldb，所以采用pymysqlapp.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://' + my_config.get('DB', 'DB_USER') + ':' + \ my_config.get('DB', 'DB_PASSWORD') + '@' + my_config.get('DB', 'DB_HOST') + '/' + \ my_config.get('DB', 'DB_DB') # 设为True 表示每次请求结束后都会自动提交数据库的变动，但像add delete insert等仍需要commit,建议不要设为trueapp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Truemydb = SQLAlchemy()mydb.init_app(app)if __name__ == "__main__": app.run(debug=True) 为了使代码结构更清晰，这里使用另一种配置方式，即使用单独配置文件的文件来做全局Flask配置 管控所有的配置文件conf.py: 1234567DB_USER = 'root'DB_PASSWORD = 'jwyjwy9951206-=-'DB_HOST = 'localhost'DB_DB = 'flask_migrate_demo'DEBUG = True SQLALCHEMY_TRACK_MODIFICATIONS = FalseSQLALCHEMY_DATABASE_URI = 'mysql+pymysql://' + DB_USER + ':' + DB_PASSWORD + '@' + DB_HOST + '/' + DB_DB SQLAlchemy允许我们根据数据库的表结构来创建数据模型，反之亦可。 所以我们一般无须手动的登录到数据库中使用 SQL 语句来创建表, 我们只需把数据模型定义好了之后, 表结构也就有了 新建model.py，并定义一个用户表数据模型 12345678from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()class User(db.Model):user_id = db.Column(db.Integer, primary_key=True)user_name = db.Column(db.String(60), nullable=False)user_password = db.Column(db.String(30), nullable=False)user_nickname = db.Column(db.String(50))user_email = db.Column(db.String(30), nullable=False) 新建db.py，利用Flask-Script和Flask-Migrate，搭建db和app之间的桥梁 1234567891011from flask import Flaskfrom flask_script import Managerfrom flask_migrate import Migrate, MigrateCommandfrom model import dbapp = Flask(__name__)app.config.from_object('conf')migrate = Migrate(app, db)manager = Manager(app)manager.add_command('db', MigrateCommand)if __name__ == '__main__':manager.run() Flask-Script和Flask-Migrate使用 最后，在pycharm的控制台打下三行迁移代码，这样就能在数据库中看见跟model字段一样的表了 123python db.py db initpython db.py db migratepython db.py db upgrade 示例接口实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# 用到flask中的Flask框架，jsonify返回json数据，request将前端字段传入后端from flask import Flask, jsonify, request# 将model中的User，db对象传入from model import db, User# 告诉flask这个app要用它app = Flask(__name__)# 读取配置文件，主要是连接mysqlapp.config.from_object('conf')# 初始化db.init_app(app)# 开始路由@app.route('/')def index(): return '&lt;h1&gt;Hello Flask!&lt;/h1&gt;'# 增@app.route('/user', methods=['POST'])def addUser(): user_name = request.form.get('user_name') user_password = request.form.get('user_password') user_nickname = request.form.get('user_nickname') user_email = request.form.get('user_email') user = User(user_name=user_name, user_password=user_password, user_nickname=user_nickname, user_email=user_email) try: db.session.add(user) db.session.commit() except: db.session.rollback() db.session.flush() userId = user.user_id if (user.user_id is None): result = &#123;'msg': '添加失败'&#125; return jsonify(data=result) data = User.query.filter_by(user_id=userId).first() result = &#123;'user_id': data.user_id, 'user_name': data.user_name, 'user_nickname': data.user_nickname, 'user_email': data.user_email&#125; return jsonify(data=result)# 查@app.route('/user/&lt;int:userId&gt;', methods=['GET'])def getUser(userId): user = User.query.filter_by(user_id=userId).first() if (user is None): result = &#123;'msg': '找不到数据'&#125; else: result = &#123;'user_id': user.user_id, 'user_name': user.user_name, 'user_nickname': user.user_nickname, 'user_email': user.user_email&#125; return jsonify(data=result)# 改@app.route('/user/&lt;int:userId&gt;', methods=['PATCH'])def updateUser(userId): user_name = request.form.get('user_name') user_password = request.form.get('user_password') user_nickname = request.form.get('user_nickname') user_email = request.form.get('user_email') try: user = User.query.filter_by(user_id=userId).first() if (user is None): result = &#123;'msg': '找不到要修改的记录'&#125; return jsonify(data=result) else: user.user_name = user_name user.user_password = user_password user.user_nickname = user_nickname user.user_email = user_email db.session.commit() except: db.session.rollback() db.session.flush() userId = user.user_id data = User.query.filter_by(user_id=userId).first() result = &#123;'user_id': data.user_id, 'user_name': data.user_name, 'user_password': data.user_password, 'user_nickname': data.user_nickname, 'user_email': data.user_email&#125; return jsonify(data=result)# 查全部@app.route('/user', methods=['GET'])def getUsers(): data = User.query.all() data_all = [] for user in data: data_all.append(&#123;'user_id': user.user_id, 'user_name': user.user_name, 'user_nickname': user.user_nickname, 'user_email': user.user_email&#125;) return jsonify(users=data_all)# 删@app.route('/user/&lt;int:userId&gt;', methods=['DELETE'])def deleteUser(userId): # 删除数据 User.query.filter_by(user_id=userId).delete() db.session.commit() return getUsers()if __name__ == '__main__': app.run(debug=app.config['DEBUG']) ​ SQLAlchemy 几种查询方式总结 使用Flask-RESTful快速创建RESTful API接口先容我把项目做完…待续…….无聊看看文档：flask-restful中文官方文档 使用Flask + PyJWT 实现基于Json Web Token的用户认证授权待更…无聊看看文档：Flask + PyJWT 实现基于Json Web Token的用户认证授权 问题1.主要问题就是flask和mysql的连接问题，出现的最棘手的问题首先是mysqldb是py2的，py3没有，用pymysql代替，在SQLALCHEMY_DATABASE_URI注意修改driver驱动。2.最终修改方案是自己用一个demo建好了数据库和表(记得保存好demo)，demo如下，然后再运行就可以了。 12345678910111213141516from sqlalchemy import create_engine,Table,Column,Integer,String,MetaData,ForeignKeyengine=create_engine("mysql+pymysql://root:a5230411@localhost:3306/test",echo=True)metadata=MetaData(engine)user=Table('user',metadata, Column('id',Integer,primary_key=True), Column('name',String(20)), Column('fullname',String(40)), )address_table = Table('address', metadata, Column('id', Integer, primary_key=True), Column('user_id', None, ForeignKey('user.id')), Column('email', String(128), nullable=False) )metadata.create_all() 3.解决 sqlalchemy 报错:(1193, “Unknown system variable ‘tx_isolation’”): 传送门 参考网址 Flask + PyJWT 实现基于Json Web Token的用户认证授权 使用 Flask 设计 RESTful 的认证 使用Flask-RESTful快速创建RESTful API接口 Flask + flask-jwt 实现基于Json Web Token的用户认证授权 Flask程序目录结构——构建可扩展的Flask应用程序 Python的flask：models.py来创建mysql数据库 python使用sqlalchemy连接mysql数据库 深入浅出Flask(学习教程) 深入浅出理解Python装饰器 flask-restful中文官方文档]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>PyJWT</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术]]></title>
    <url>%2F2019%2F08%2F20%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html</url>
    <content type="text"><![CDATA[第一章Java的11个关键术语 简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 Java applet在网页中运行的Java程序称为applet 第二章部分术语 JDK(java development kit):java开发工具包 JRE(Java Runtime Environment):运行java程序用户所使用的软件 SDK(Software Development Kit):软件开发包 安装过程MAC中JAVA环境变量配置以及Intellij IDEA如何配置JDKIDEA的校园邮箱激活方式IntelliJ IDEA 常用快捷键 之 Mac 版Intellij IDEA快捷生成常用代码 琐碎知识点 0x1.0p-3:0x表示16进制，使用p表示指数，所以就是1.0*2的-3次方 三个特殊的浮点数值：正无穷大(Double.POSITIVE_INFINITY)、负无穷大(Double.NEGATIVE_INFINITY)、NaN(Double.NaN) 浮点数值不适用于无法接受舍入误差的计算中，要想完全没有误差，需要使用BigDecimal类 部分特殊字符的转义序列：\b 退格 \t 制表 \n 换行 \r 回车 \“双引号 \反斜杠 强烈建议不要在程序中使用char类型，因为unicode早已经超过了65536个 第三章部分术语 类常量：static final,类常量的定义在main方法的外部 整数被0除将会产生异常，浮点数被0除将会得到无穷大或NaN结果 public static strictfp void main(String[] args)，在该main函数中所有指令都将使用严格的浮点计算 condition ? expression1 : expression2 eg: x&lt;y ? x : y 位运算符：&amp;、|、^、~拓展：奇数个数，两个两个成对最有一个单独，如何找出这个单独的数字是几，复杂度在O(n)以内：用异或的思想即可，全部异或 移位运算符: &lt;&lt;(算数移位)&gt;&gt; &gt;&gt;&gt;(逻辑右移),其中&gt;&gt;&gt;会用0填充高位，移位运算符的右操作数要满足模32的运算(如果左边操作数是long则要满足模64)，1&lt;&lt;35 == 1&lt;&lt;3 == 8 枚举类型：enum Size{SMALL,MEDIUM,LARGE } 字符串 子串: 12String greeting = "Hello";String s = greeting.substring(0,3); 拼接:直接用+连接、如果需要多个字符串放在一起，并且用一个定界符分割，可以采用静态join方法： 12String all = String.join("/","S","M","L","XL")// string: "S/M/L/XL" java中不允许修改字符，但是可以修改字符串变量*字符串比较用equals方法，例如：”Hello”.equals(greeting),”Hello”.equalsIgnoreCase(“hello”)「无视大小写的比较」 java.lang.string部分apiString类常用方法之charAt()、codePointAt()示例offsetByCodePoints()与codePointAt() 注意lastIndexOf(int cp,int fromindex)，是返回从index位置开始找到的第一个符合的字符串的位置 12345678910111213141516public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1); for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125; &#125; input Scanner在util包中，当使用的类不在java.lang中时，都需要导包 1234567Scanner sc = new Scanner(System.in); String nextLine = sc.nextLine(); System.out.println("please input your name:" + nextLine); int nextInt = sc.nextInt(); System.out.println("please input your age:" + nextInt);String next = sc.next();System.out.println("please input your name:" + next);]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活好难啊]]></title>
    <url>%2F2019%2F08%2F18%2F%E7%94%9F%E6%B4%BB%E5%A5%BD%E9%9A%BE%E5%95%8A.html</url>
    <content type="text"><![CDATA[今天被打击了…卧槽这个大数据怎么这么枯燥…再次怀疑不适合学计算机…把我看睡着了可还行（吐血…算了还是接着干吧）]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>负情绪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka]]></title>
    <url>%2F2019%2F08%2F18%2Fkafka.html</url>
    <content type="text"><![CDATA[初识kafkakafka概念Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据,是用于构建实时数据管道和流应用程序。 四个术语 TopicKafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic)。 Producer发布消息的对象称之为主题生产者(Kafka topic producer)。生产者发布消息时要选定Topic上的分区。 Consumer订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)。一般消费者模型可以分为两类：队列和发布-订阅式。队列的处理方式就是一条消息只有一个消费者知道并处理，发布-订阅的处理方式则是消息被所有人都知道，所有人都可以来处理该消息，kafka为这两种模型提供了单一抽象模型：消费者组（cosumer group）。每个消费者都有一个组名，当所有人的组名都不一样的时候，这个时候就是发布-订阅模式，因为消息要按照消费者组为单位发出的，这意味着此时每个消费者都会收到消息并可以进行处理；当所有人的消费者组名字都一样时，意味着只会有一个消费者收到消息并可以进行处理，此时就是队列模式了。 Broker已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。 三个关键能力 发布和订阅消息流，在这方面，它类似于一个消息队列或企业消息系统 以容错的方式存储消息（流) 在消息流发生时处理他们 四个核心API 应用程序使用 Producer API 发布消息到1个或多个topic（主题）。 应用程序使用 Consumer API 来订阅一个或多个topic，并处理产生的消息 应用程序使用 Streams API 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。 Connector API允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。 kafka安装过程 kafka的安装 1brew install kafka 安装会依赖zookeeper 注意：安装目录：/usr/local/Cellar/kafka/0.10.2.0 安装的配置文件位置/usr/local/etc/kafka/server.properties/usr/local/etc/kafka/zookeeper.properties 启动zookeeper 1zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp; 启动kafka 1kafka-server-start /usr/local/etc/kafka/server.properties &amp; 创建topic让我们使用单个分区和只有一个副本创建一个名为“test”的主题 1kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 查看创建的topic我们现在可以看到该主题，如果我们运行list topic命令： 1kafka-topics --list --zookeeper localhost:2181 发送消息Kafka提供了一个命令行客户端，它将从文件或标准输入接收输入，并将其作为消息发送到Kafka集群。默认情况下，每行都将作为单独的消息发送。运行生产者，然后在控制台中键入一些消息发送到服务器。 1kafka-console-producer --broker-list localhost:9092 --topic test 消费消息Kafka还有一个命令行消费者，将消息转储到标准输出。 1kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning TipQ:安装kafka出现错误： 1234kafka: Java 1.8 is required to install this formula.Install AdoptOpenJDK 8 with Homebrew Cask: brew cask install homebrew/cask-versions/adoptopenjdk8Error: An unsatisfied requirement failed this build. A: 1brew cask install homebrew/cask-versions/adoptopenjdk8 bilibili学习kafkahttps://www.bilibili.com/video/av36607048?p=2 zookeeper 默认是前台启动(关闭了控制台停止)，可以在最前面加上 nohup，这样就可以后台启动了。 三个目录 bin目录1cd usr/local/Cellar/kafka/2.2.1/bin * config文件 1/usr/local/etc/kafka/server.properties * 日志 1234############################# Log Basics ############################## A comma separated list of directories under which to store log fileslog.dirs=/usr/local/var/lib/kafka-logs 删除topic1kafka-topics --delete --zookeeper localhost:2181 --topic test]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实践winrm，实现远程连接调度Windows服务器]]></title>
    <url>%2F2019%2F08%2F17%2Fpython%E5%AE%9E%E8%B7%B5winrm%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%B0%83%E5%BA%A6Windows%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content type="text"><![CDATA[前言最近有个需求：用自己主机控制多个windows节点，实时获取他们的cpu和运存占用情况，通过查询，决定采用python中的winrm。Tip:winrm服务是windows 一种方便远程管理的服务；开启winrm service,便于在日常工作中，远程管理服务器，或通过脚本，同时管理多台服务器，来提高工作效率。 常规做法配置远程主机,使其支持被远程控制 查看winrm service listener（分为http和https）:1winrm e winrm/config/listener 如果没有返回，则没有开启winrm服务。 开启winrm服务： 1winrm quickconfig 为winrm service 配置auth: 1winrm set winrm/config/service/auth @&#123;Basic="true"&#125; 为winrm service 配置加密方式为允许非加密： 1winrm set winrm/config/service @&#123;AllowUnencrypted="true"&#125; 查看winrm服务的配置： 1winrm get winrm/config 客户端主机 装winrm 1pip install pywinrm 测试 1234import winrmwintest = winrm.Session('http://47.98.149.160:5985/wsman',auth=('Administrator','Jwy12345a'))ret = wintest.run_cmd('ipconfig')print(ret) 遇到的问题及解决措施 在测试环节，导入winrm包后，控制台显示：winrm has no attribute session 解决办法：pip导错了包，应该是pywinrm这个包，将pip原来的包删除，重新导入一遍。 pycharm问题：module ‘pip’ has no attribute ‘main’ 解决办法：pip升级导致无法导包 测试的时候，报出以下错误： 1requests.exceptions.ConnectTimeout: HTTPConnectionPool(host='47.98.149.160', port=5985): Max retries exceeded with url: /wsman (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x104921650&gt;, 'Connection to 47.98.149.160 timed out. (connect timeout=30)')) 解决办法：由于云服务器有公网ip地址，所以本机可以ping通服务器，但是由于本机不存在公网地址，是局域网地址，所以服务器不能ping通主机，导致二者不能正常通信，只能换一种方法，也就是在云服务器端运行程序，程序提供了当前cpu运行情况和运存情况，本机可以随时访问并得到信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import timeimport psutil # cd C:\Python36-32\Scripts pip install psutil# 获取本机磁盘使用率和剩余空间G信息import pymysqlconn = pymysql.connect(user="root", passwd="No.93329332", host="134.175.5.88", port=3306, db="node_status")cur = conn.cursor()flag = 0while(True): # 循环磁盘分区 content = "" for disk in psutil.disk_partitions(): # 读写方式 光盘 or 有效磁盘类型 if 'cdrom' in disk.opts or disk.fstype == '': continue disk_name_arr = disk.device.split(':') disk_name = disk_name_arr[0] disk_info = psutil.disk_usage(disk.device) # 磁盘剩余空间，单位G free_disk_size = disk_info.free // 1024 // 1024 // 1024 # 当前磁盘使用率和剩余空间G信息 if (disk_name == 'C'): disk_c_name = disk_name disk_c_info = disk_info free_c_disk_size = free_disk_size info = "%s盘使用率：%s%%， 剩余空间：%iG" % (disk_c_name, str(disk_c_info.percent), free_c_disk_size) # print(info) # print(disk_name) if (disk_name == 'C'): # 拼接多个磁盘的信息 content = content + info print(content) # return content # cpu信息 cpu_percent = psutil.cpu_percent(interval=1) cpu_info = "CPU使用率：%i%%" % cpu_percent print(cpu_info) # return cpu_info # 内存信息 virtual_memory = psutil.virtual_memory() used_memory = virtual_memory.used / 1024 / 1024 / 1024 free_memory = virtual_memory.free / 1024 / 1024 / 1024 memory_percent = virtual_memory.percent memory_info = "内存使用：%0.2fG，使用率%0.1f%%，剩余内存：%0.2fG" % (used_memory, memory_percent, free_memory) print(memory_info) # return memory_info now = time.asctime() if(flag == 0): sql = "INSERT INTO status(ip, \ disk_percent, disk_freesize, CPU_percent, memory_used,memory_free,memory_percent,mytime) \ VALUES ('%s', '%s', '%s', '%s', '%s','%s','%s','%s')" % \ ('106.13.70.159', str(disk_c_info.percent) + "%", str(free_c_disk_size) + "G", str(cpu_percent) + "%",str(used_memory)[:3] + "G",str(free_memory)[:3] + "G",str(memory_percent) + "%",now) flag = 1 else: used_memory_float = str(used_memory)[:3] + 'G' free_memory_folat = str(free_memory)[:3] + 'G' disk_c_info_percent_str = str(disk_c_info.percent) + '%' free_c_disk_size_str = str(free_c_disk_size) + 'G' cpu_percent_str = str(cpu_percent) + '%' memory_percent_str = str(memory_percent) + '%' sql = "update status set disk_percent = '%s', disk_freesize = '%s', \ CPU_percent = '%s', memory_used = '%s' , memory_free = '%s' ,\ memory_percent = '%s' , mytime = '%s' where ip = '106.13.70.159'" % \ (disk_c_info_percent_str,free_c_disk_size_str,cpu_percent_str,used_memory_float,free_memory_folat,memory_percent_str,now) flag = 2 try: # 执行sql语句 cur.execute(sql) # 执行sql语句 conn.commit() if(flag==1): print("insert ok") else: print("update ok") except Exception as e: # 发生错误时回滚 conn.rollback() print("failed") print(e) time.sleep(60)# 关闭数据库连接conn.close() sql中update也可以 1sql = "update table set ss = '%s'where id = '1'"% disk]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>winrm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo的NexT主题---从入门到入土]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%9F%BA%E4%BA%8EHexo%E7%9A%84NexT%E4%B8%BB%E9%A2%98-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.html</url>
    <content type="text"><![CDATA[前言本篇文章主要是针对nexT主题的优化说明，使用hexo其他主题的童靴请绕道~~整理一下大概优化：1.标题部分优化，颜色样式；2.设置博客文章连接为year/month/day/title.html格式3.Menu增加关于、标签、分类、互动、搜索菜单4.禁用关于、标签、分类菜单评论功能5.添加RSS6.设置背景图片7.Canvas_nest动态背景8.图片快速加载设置9.微信支付宝打赏功能10.点击出现桃心效果11.主页文章添加阴影效果12.设置代码高亮13.顶栏背景色14.底栏背景色15.修改文章内链接文本样式16.修改文章底部标签样式17.在文章末尾添加“文章结束”标记18.设置头像19.网站底部加上访问量20.网站底部字数统计21.网站底部添加网站运行时间22.网站底部添加动态桃心23.底部隐藏由Hexo强力驱动、主题–NexT.Mist24.设置网站的图标Favicon25.实现文章文字统计功能和阅读时长26.加来必力云跟帖功能27.去掉底部重复字数统计28.修改字体大小29.侧边栏社交小图标设置30.添加侧栏推荐阅读31.修改侧边栏背景图片32.添加侧边栏音乐33.修改侧边栏文字颜色34.在文章底部增加版权信息35.Hexo博客添加站内搜索36.修改选中字符的颜色37.添加aplay音乐播放38.添加博客左下角门神(看门🐶)39.增加了3D库three_waves，默认关闭40.增加了canvas页面丝带(话说这玩意真的很吃cpu，一开我的mac就铁板烧了)41.增加了首页pace加载进度42.增加图片懒加载lazyload43.增加了fancybox44.增加了fastclick解决延迟问题45.增加了gulp压缩网页css js样式46.截断首页文章内容47.代码复制功能 hexo目录结构主目录结构 _config.yml全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。 package.jsonhexo框架的参数和所依赖插件。 scaffoldsscaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。 source这个目录很重要，新建的文章都是在保存在这个目录下的._posts，需要新建的博文都放在_posts目录下。_posts目录下是一个个 markdown 文件。你应该可以看到一个 hello-world.md 的文件，文章就在这个文件中编辑。_posts 目录下的md文件，会被编译成html文件，放到 public （此文件现在应该没有，因为你还没有编译过）文件夹下。里面还有一个重要文件夹：images，是用来存放博文的图片的，这里建议使用七牛云图床来存储图片，因为可以更快的加载图片。同时强烈建议大家用一款hexo—client来进行可视化博客的书写，一站式服务，支持七牛云图床，接好传送门：hexoclient。 themes网站主题目录，我用的就是nexT主题。 node_moduleshexo依赖的组件都在其中。 主题目录结构12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 高度定制优化篇标题部分优化，颜色样式首先你要确定你是主题中的哪个scheme：Muse、Mist、Pisces、Gemini，我的是Mist,所以我就去themes/nexT/source/css/_schemes/Mist/_header.styl下，添加以下代码：12345//可以加图片，也可以自己调色彩.header &#123; //background: url('/images/headbg.jpg') repeat !important; background: rgba(#EBF2EA,1) none repeat scroll !important; &#125; 设置背景图片默认禁用，可以在themes/nexT/source/css/_custom/custon.styl文件中启用12345678//设置背景图片body &#123; background:url(http://pw5u1sbg2.bkt.clouddn.com/145676.jpg); background-repeat: repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover;&#125; Canvas_nest动态背景背景的几何线条是采用的nest效果, 一个基于html5 canvas绘制的网页背景效果, 非常赞！来自github的开源项目canvas-nest 特性 不依赖任何框架或者内库，比如不依赖jQuery，使用原生的javascript 非常小，只有1.66kb，如果开启gzip，可以更小 非常容易实现，配置简单，即使你不是web开发者，也能简单搞定说明 color：线条颜色，默认： ‘0,0,0’ ；三个数字分别为(R,G,B)，这里推荐一个颜色采集器：ColorSlurp，在AppStore中就可以搜到 opacity：线条透明度（0~1），默认: 0.5 count：线条的总数量， 默认：150 zIndex：背景的z-index属性，css属性用于控制所在层的位置，默认：-1不足内存占用过高做法直接找到主题配置文件，将canvas改为true即可。RSS在你的hexo站点目录下：1$ npm install hexo-generator-feed --save 打开站点目录下的_config.yml:12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml limit: 20 hub: content: 来必力评论系统等第三方插件登录 来必力 ，获取LiveRe UID，编辑主题配置文件，编辑livere_uid字段，将id填入即可，更多第三方集成插件可见：nexT官网，包括评论系统、数据统计与分析、内容分享服务、搜索服务等等。 打赏功能nexT集成了支付宝微信打赏功能，直接在主题配置文件搜索wechat或者alipay即可,然后跟上自己的微信和支付宝的收钱码图片地址即可。 点击出现桃心效果1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 新建 clicklove.js 文件并且将以上代码复制进去，然后保存。 将 clicklove.js文件放到路径 /themes/next/source/js/src 里面 然后打开 \themes\next\layout\_layout.swig 文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; 主页文章添加阴影效果打开 themes/next/source/css/_custom/custom.styl，向里面加代码:12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 代码高亮直接在主题配置文件搜索 highlight_theme：1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night bright 顶部底部背景色改变首先你要确定你是主题中的哪个scheme：Muse、Mist、Pisces、Gemini，我的是Mist,所以我就themes/nexT/source/css/_schemes/Mist/_header.styl下，将颜色进行修改即可。底部颜色则在themes/nexT/source/css/_schemes/Mist/index.styl中进行修改：123456789101112131415161718// Footer// --------------------------------------------------.footer &#123; margin-top: 80px; padding: 10px 0; //background: url('/images/headbg.jpg') repeat !important; background: rgba(#EBF2EA,1) none repeat scroll !important; color: $grey-dim;&#125;.footer-inner &#123; margin: 0 auto; text-align: left; +mobile() &#123; width: auto; text-align: center; &#125;&#125; 修改文章内文本连接样式打开 themes/next/source/css/_custom/custom.styl,添加代码：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 修改网页底部 在图标库中找到你自己喜欢的图标, 修改桃心,打开 themes/next_config.yml ,搜索关键字 authoricon,替换图标名： 12# icon between year and author @Footerauthoricon: id-card 隐藏网页底部 Hexo 强力驱动 打开主题配置文件,搜索关键字 copyright ，如下: 12# Footer `powered-by` and `theme-info` copyrightcopyright: false 添加文章结束标记在themes/next/layout/_macro/post.swig中, 在wechat-subscriber.swig之前添加如下代码:123&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt; 统计功能，统计功能,显示文章字数统计,阅读时长,总字数在站点的根目录下：1$ npm i --save hexo-wordcount 打开 themes/next/_config.yml ，搜索关键字 post_wordcount：1234567891011# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true #字数统计 wordcount: true #预览时间 min2read: true #总字数,显示在页面底部 totalcount: true separated_meta: true 设置头像打开 themes/next/_config.yml ，搜索关键字 avatar：123456789101112# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: http://pw5u1sbg2.bkt.clouddn.com/avatar.png #/images/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 底部添加访问量和字数统计运用第三方插件，见nexT官网，推荐百度统计和不蒜子统计。 底部添加运行时间找到\themes\next\layout\_partials\下面的footer.swig文件，在末尾添加所示代码：12345678910111213141516171819&lt;div class="run_time" style=" text-align:center;"&gt; &lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("08/06/2019 19:00:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125; setInterval("createtime()",250); &lt;/script&gt;&lt;/div&gt; 底部添加红心打开 themes/next/_config.yml ，搜索关键字 footer：123456789101112131415footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 # visitors count counter: true # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" 添加侧边栏音乐框去往网易云音乐搜索喜欢的音乐，点击生成外链播放器， 复制代码直接放到博文末尾即可，height设为0可隐藏播放器，但仍然可以播放音乐，auto设成0可手动播放，默认是1自动播放，可把代码放到themes/next/layout/_custom/sidebar.swig文件里，播放器会显示在站点预览中,示例代码如下：12&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=2588481240&amp;auto=1&amp;height=90"&gt;&lt;/iframe&gt; 添加aplayer音乐播放由于我想在单独的页面加入歌单，所以额外创了个页面，也可以直接在文章中插入，原理都是一样的。 新建页面，命名为guestbook： 1hexo new page guestbook 这时候在 /Hexo/source 文件夹下会生成一个guestbook文件夹，打开里面的index.md，示例如下： 123456789101112---title: 留言互动date: 2019-08-15 12:18:09type: "guestbook"---&lt;div align="center"&gt; &lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558956326532&amp;di=82cc9907fc903cfb978a35206986d3f6&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160809%2F31283a3e2d7f411492d3fb27297180ec_th.jpg" /&gt;&lt;/div&gt;[//]: #(aplay音频播放https://github.com/MoePlayer/hexo-tag-aplayer)&#123;% meting "2331951308" "netease" "playlist" "autoplay" "mutex:false" "order:random" "listmaxheight:250px" "preload:none" "theme:#f7f7f7"%&#125; meting中配置参数含义如下： 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启固定模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 theme #ad7a86 播放器风格色彩设置 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto 打开主题_config.yml文件，在menu下新建一个名为guestbook的类，完成后如下所示： 1234567menu: home: / || home tags: /tags/ || tags categories: /categories/ || bookmark archives: /archives/ || archive about: /about/ || user 互动: /guestbook/ || comments 打开/Hexo/themes/hexo-theme-next/languages/zh-Hans.yml，添加对应的中文翻译： 12menu: guestbook: 互动 至此，歌单页面创建完成，现在只需要在站点配置文件中开启meting模式，在_config.yml中搜索meting： 12aplayer: meting: true Tip同一个歌单不能做到实时刷新，需要24小时后aplayer才会自动更新缓存 添加博客左下角门神安装依赖:12npm install --save hexo-helper-live2dnpm install --save live2d-widget-model-wanko 站点配置添加:12345678910111213141516171819202122# hexo-helper-live2d配置, 参考https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.mdlive2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: scale: 1 use: live2d-widget-model-wanko display: superSample: 2 # 超采样等级 width: 100 height: 100 position: left # 位置 mobile: show: false react: opacityDefault: 0.9 # 默认透明度 opacityOnHover: 0.5 # 鼠标移上透明度 增加首页pace加载进度打开主题配置文件：12345678# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom# pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator# pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimalpace_theme: pace-theme-bounce 增加图片懒加载lazyload打开主题配置文件：123# Vanilla JavaScript plugin for lazyloading images.# Dependencies: https://github.com/theme-next/theme-next-jquery-lazyloadlazyload: true 增加fancybox和fastclick解决延迟问题打开主题配置文件：123456789# Fancybox. There is support for old version 2 and new version 3.# Choose only one variant, do not need to install both.# To install 2.x: https://github.com/theme-next/theme-next-fancybox# To install 3.x: https://github.com/theme-next/theme-next-fancybox3fancybox: true# Polyfill to remove click delays on browsers with touch UIs.# Dependencies: https://github.com/theme-next/theme-next-fastclickfastclick: true 截断首页文章内容打开主题配置文件，搜索auto_excerpt：12345# Automatically Excerpt (Not recommend).# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150 代码复制功能 复制该网页的代码，传送门：clipboard.min.js，然后在themes\next\source\js\src下新建clipboard.min.js文件，将以上内容复制进去即可； 在themes\next\source\js\src目录下，创建clipboard-use.js，文件内容如下： 123456789101112131415161718 /*页面载入完成后，创建复制按钮*/ !function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; //fa fa-globe可以去字体库替换自己想要的图标copyHtml += ' &lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode(); &#125;(window, document); 在themes\next\source\css\_custom\custom.styl样式文件中添加下面代码： 123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 在themes\next\layout\_layout.swig文件中，添加引用（注：在 swig 末尾或 body 结束标签（L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":1,"width":250,"height":300,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});）之前添加）： 123&lt;!-- 代码块复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; 尝试了但未实现的功能1.用mob_share的app_key未能实现share的功能，经过其官方人员电话沟通，已经不再支持pc端博客服务2.aplay音乐播放歌单，不能做到实时更新歌单，究其原因是其api设置了24小时缓存，同一个歌单24小时内不会发生改变 非常有益的网址 NexT主题进阶 基于Hexo的个人博客搭建(进阶版) Hexo+Next主题优化]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[剑指offer算法题]]></title>
    <url>%2F2019%2F08%2F12%2F%E5%89%91%E6%8C%87offer%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为列数。该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。 My code1234567891011121314151617# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here row = len(array) col = len(array[0]) c = col - 1 r = 0 while(r &lt;= row-1 and c &gt;=0): if(target == array[r][c]): return True elif(target &gt; array[r][c]): r+=1 else: c-=1 return False 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路将字符串复制给一个新的列表，碰到空格则替换，没有则copy原字符串，最后对列表进行join，返回字符串。 易错点 My code12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here t = len(s) j = 0 m = list(s) for i in range(0,t): if(s[i] == ' '): m[j] = '%20' j+=1 else: m[j] = s[i] j+=1 pass return ''.join(m)# s = 'I want to sleep'# solution = Solution()# ss = solution.replaceSpace(s)# print(ss) 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路知识点补充python中链表的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node(): '创建节点' def __init__(self,data): self.data = data self.next = None class LinkList(): '创建列表' def __init__(self, node): '初始化列表' self.head = node self.head.next = None self.tail = self.head def add_node(self, node): '添加节点' self.tail.next = node self.tail = self.tail.next def view(self): '查看列表' node = self.head link_str = '' while node is not None: if node.next is not None: link_str += str(node.data) + '--&gt;' else: link_str += str(node.data) node = node.next print ('The Linklist is:' + link_str) def length(self): '列表长度' node = self.head count = 1 while node.next is not None: count += 1 node = node.next print ('The length of linklist are %d' % count) return count def delete_node(self, index): '删除节点' if index+1 &gt; self.length(): raise IndexError('index out of bounds') num = 0 node = self.head while True: if num == index-1: break node = node.next num += 1 tmp_node = node.next node.next = node.next.next return tmp_node.data def find_node(self, index): '查看具体节点' if index+1 &gt; self.length(): raise IndexError('index out of bounds') num = 0 node = self.head while True: if num == index: break node = node.next num += 1 return node.data My code123456789101112131415# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here res=[] while listNode: res.append(listNode.val) listNode=listNode.next return res[::-1] #逆序打印 重建二叉树题目描述输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 解题思路 递归 整体思路就是：利用递归的思想，跟归并和快排有异曲同工之妙。抓住第一个节点是根节点，然后在中序遍历中定位该节点，左边即为根节点的左子树，右边即为根节点的右子树。然后对左子树和右子树分别进行递归即可，直到左子树和右子树都没了。 非递归 整体思路：我还没认真看呢！！！！！！！！ 用两个堆栈来分别存储二叉树和先序中序序列索引值，跟递归思路一样，先找到根节点，然后分别判断在中序遍历中是否还有左右子树，如果有则计数值count+=1,当找到一个节点之后就将计数值count-=1，直到中序遍历中再也没有左右子树。 My code递归1234567891011121314151617181920212223242526272829303132333435/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre, int [] in) &#123; if(pre == null || in == null || pre.length == 0 || in.length == 0)&#123; return null; &#125; return constructBinaryTree(pre,in,0,pre.length-1,0,in.length-1); // 首先看先序遍历的第一个数，这是根节点，然后根据中序遍历然后分为左右两个节点块 // 再看左边的第一个数，这个肯定是根节点，然后定位到中序遍历该数的位置，再将其分为左右两个节点块，以此类推。 &#125; private TreeNode constructBinaryTree(int[] pre, int[] in, int preStart, int preEnd, int inStart, int inEnd) &#123; if(preStart &gt; preEnd || inStart &gt; inEnd)&#123; return null; &#125; TreeNode node = new TreeNode(pre[preStart]); int mid = inStart; while (pre[preStart] != in[mid]) mid++; int preNumber = mid - inStart; node.left = constructBinaryTree(pre,in,preStart + 1,preStart + preNumber,inStart,mid - 1); node.right = constructBinaryTree(pre,in,preStart + preNumber + 1,preEnd,mid + 1,inEnd); return node; &#125;&#125; 非递归123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475/** * Definition for binary tree * public class TreeNode &#123; * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) &#123; val = x; &#125; * &#125; */import java.util.*;public class Solution &#123; public TreeNode reConstructBinaryTree(int [] pre,int [] in) &#123; //p用来保存两个序列的索引值 Stack&lt;Integer&gt; p = new Stack&lt;Integer&gt;(); Stack&lt;TreeNode&gt; l = new Stack&lt;TreeNode&gt;(); TreeNode cur = null; p.push(0); p.push(pre.length - 1); p.push(0); p.push(in.length - 1); int count = 1; int pStart = 0; int pEnd = pre.length - 1; int iStart = 0; int iEnd = in.length - 1; TreeNode root = new TreeNode(-1); l.push(root); while( count != 0)&#123; iEnd = p.pop(); iStart = p.pop(); pEnd = p.pop(); pStart = p.pop(); cur = l.pop(); count -= 1; int index = find(pre[pStart], in, iStart, iEnd); cur.val = pre[pStart]; int lenL = index - iStart; if(lenL == 0)&#123; &#125;else&#123; p.push(pStart + 1); p.push(pStart + lenL); p.push(iStart); p.push(index - 1); count += 1; cur.left = new TreeNode(-1); l.push(cur.left); &#125; int lenR = iEnd - index; if(lenR == 0)&#123; &#125;else&#123; p.push(pStart + lenL + 1); p.push(pEnd); p.push(index + 1); p.push(iEnd); count += 1; cur.right = new TreeNode(-1); l.push(cur.right); &#125; &#125; return root; &#125; int find(int target, int[] all, int start , int end)&#123; for(int i = start; i &lt;= end; ++i)&#123; if(all[i] == target) return i; &#125; return -1; &#125;&#125; 知识点补充Tips: 二叉树的前序，中序，后序遍历方法总结 前序递归和非递归算法前序递归递归的方法很容易实现，也很容易理解：我们先访问根节点，然后递归访问左子树，再递归访问右子树，即实现了根-&gt;左-&gt;右的访问顺序，因为使用的是递归方法，所以每一个子树都实现了这样的顺序。 1234567891011121314class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); preorderHelper(root, result); return result; &#125; private void preorderHelper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; result.add(root.val); // 访问根节点 preorderHelper(root.left, result); // 递归遍历左子树 preorderHelper(root.right, result); //递归遍历右子树 &#125;&#125; 前序非递归在迭代法中，我们使用栈来实现。由于出栈顺序和入栈顺序相反，所以每次添加节点的时候先添加右节点，再添加左节点。这样在下一轮访问子树的时候，就会先访问左子树，再访问右子树： 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); if (root == null) return result; Stack&lt;TreeNode&gt; toVisit = new Stack&lt;&gt;(); toVisit.push(root); TreeNode cur; while (!toVisit.isEmpty()) &#123; cur = toVisit.pop(); result.add(cur.val); // 访问根节点 if (cur.right != null) toVisit.push(cur.right); // 右节点入栈 if (cur.left != null) toVisit.push(cur.left); // 左节点入栈 &#125; return result; &#125;&#125; 中序递归和非递归算法中序递归无论对于哪种方式，递归的方法总是很容易实现的，也是很符合直觉的。对于中序遍历，就是先访问左子树，再访问根节点，再访问右子树，即 左-&gt;根-&gt;右： 1234567891011121314class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); inorderHelper(root, result); return result; &#125; private void inorderHelper(TreeNode root, List&lt;Integer&gt; result) &#123; if(root == null) return; inorderHelper(root.left, result); // 递归遍历左子树 result.add(root.val); // 访问根节点 inorderHelper(root.right, result); // 递归遍历右子树 &#125;&#125; 中序非递归中序遍历的迭代法要稍微复杂一点，因为最先遇到的根节点不是最先访问的，我们需要先访问左子树，再回退到根节点，再访问根节点的右子树，这里的一个难点是从左子树回退到根节点的操作，虽然可以用栈来实现回退，但是要注意在出栈时保存根节点的引用，因为我们还需要通过根节点来访问右子树： 123456789101112131415161718class Solution &#123; public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; toVisit = new Stack&lt;&gt;(); TreeNode cur = root; while (cur != null || !toVisit.isEmpty()) &#123; while (cur != null) &#123; toVisit.push(cur); // 添加根节点 cur = cur.left; // 循环添加左节点 &#125; cur = toVisit.pop(); // 当前栈顶已经是最底层的左节点了，取出栈顶元素，访问该节点 result.add(cur.val); cur = cur.right; // 添加右节点 &#125; return result; &#125;&#125; 在看这部分代码中，脑海中要有一个概念：当前树的根节点的左节点，是它的左子树的根节点。因此从不同的层次上看，左节点也是根节点。另外，LeetCode上也提供了关于中序遍历的动态图的演示，感兴趣的读者可以去看一看。 后序递归和非递归算法后序递归无论对于哪种方式，递归的方法总是很容易实现的，也是很符合直觉的。对于后序遍历，就是先访问左子树，再访问右子树，再访问根节点，即 左-&gt;右-&gt;根： 1234567891011121314class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); postorderHelper(root, result); return result; &#125; private void postorderHelper(TreeNode root, List&lt;Integer&gt; result) &#123; if (root == null) return; postorderHelper(root.left, result); // 遍历左子树 postorderHelper(root.right, result); // 遍历右子树 result.add(root.val); // 访问根节点 &#125;&#125; 后序非递归前面说过，与中序遍历不同的是，后序遍历在访问完左子树向上回退到根节点的时候不是立马访问根节点的，而是得先去访问右子树，访问完右子树后在回退到根节点，因此，在迭代过程中要复杂一点： 1234567891011121314151617181920212223242526class Solution &#123; public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123; List&lt;Integer&gt; result = new LinkedList&lt;&gt;(); Stack&lt;TreeNode&gt; toVisit = new Stack&lt;&gt;(); TreeNode cur = root; TreeNode pre = null; while (cur != null || !toVisit.isEmpty()) &#123; while (cur != null) &#123; toVisit.push(cur); // 添加根节点 cur = cur.left; // 递归添加左节点 &#125; cur = toVisit.peek(); // 已经访问到最左的节点了 //在不存在右节点或者右节点已经访问过的情况下，访问根节点 if (cur.right == null || cur.right == pre) &#123; toVisit.pop(); result.add(cur.val); pre = cur; cur = null; &#125; else &#123; cur = cur.right; // 右节点还没有访问过就先访问右节点 &#125; &#125; return result; &#125;&#125; 这里尤其注意后续遍历和中序遍历中对于从最左侧节点向上回退时的处理： 在后序遍历中，我们首先使用的是： 1cur = toVisit.peek(); 注意，这里使用的是peek而不是pop，这是因为我们需要首先去访问右节点，下面的： 1if (cur.right == null || cur.right == pre) 就是用来判断是否存在右节点，或者右节点是否已经访问过了，如果右节点已经访问过了，则接下来的操作就和中序遍历的情况差不多了，所不同的是，这里多了两步： 12pre = cur;cur = null; 这两步的目的都是为了在下一轮遍历中不再访问自己，cur = null很好理解，因为我们必须在一轮结束后改变cur的值，以添加下一个节点，所以它和cur = cur.right一样，目的都是指向下一个待遍历的节点，只是在这里，右节点已经访问过了，则以当前节点为根节点的整个子树都已经访问过了，接下来应该回退到当前节点的父节点，而当前节点的父节点已经在栈里了，所以我们并没有新的节点要添加，直接将cur设为null即可。 pre = cur 的目的有点类似于将当前节点标记为已访问，它是和if条件中的cur.right == pre配合使用的。注意这里的两个cur指的不是同一个节点。我们假设当前节点为C，当前节点的父节点为A，而C是A的右孩子，则当前cur是C，但在一轮中，cur将变成A，则： 123 A / \B C (pre) pre = cur 就是 pre = C if (cur.right == null || cur.right == pre) 就是 if (A.right == null || A.right == pre) 这里，由于A是有右节点的，它的右节点就是C，所以A.right == null不成立。但是C节点我们在上一轮已经访问过了，所以这里为了防止进入else语句重复添加节点，我们多加了一个A.right == pre条件，它表示A的右节点已经访问过了，我们得以进入if语句内，直接访问A节点。 用两个栈实现队列旋转数组的最小数字tips：只要是关于有序数组，基本就在考察二分法 斐波那契数列变态跳台阶]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>剑指offer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在macOS上使用GitHub Pages+Hexo搭建个人博客]]></title>
    <url>%2F2019%2F08%2F08%2F%E5%9C%A8macOS%E4%B8%8A%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[搭建环境操作系统：macos 10.14.5工具：github Desktop, Node.js, Git框架：Hexo, Github Pages 具体步骤安装git直接在终端输入git --version判断自己系统是否已有git，如果没有，点击该链接git下载，安装完后进入终端输入git --version检查是否安装成功。 安装node.js话不多说，上链接：node.js下载，然后傻瓜式安装就行。安装完之后请记得去控制台看看是否安装成功node --version,然后更新一下npm,输入:npm install -g npm 注册账号并创建博客仓库a.首先进入github官网：github,进行相应的注册登录，然后创建仓库，就在左上角那个猫猫旁边。b.戳进去之后,Respository name必须是:您的github账户名.github.io,然后勾选下面的创建readme，创建完成。c.进入仓库，点击Setting，启用GitHub Pages,此时你输入您的github账户名.github.io,就能看到不是404了，说明此时博客已经建立了，接下来就是利用Hexo框架让你的博客美起来啦！！！！ 安装配置Hexoa.首先建立一个文件夹(随便你建在哪)b.在该文件夹内打开终端，输入：1$ npm install hexo-cli -g 接下来你就能看到文件夹内的东西多了起来哈哈哈，如下图所示的文件结构：c.Hexo已经有了，github pages也有了，现在就剩把他们联系起来了，所以这步就是关键咯，打开上图第一个文件：_config.yml,然后在文本的结尾加上下面的一段代码：1234deploy: type: git repository: https://github.com/jeromememory/jeromememory.github.io.git branch: master 其中repository就是你最开始设置的仓库哟，记得替换自己的github用户名。 检测是否部署成功首先如果你想在本地预览你的博客，只需要打开终端,首先进入Hexo文件夹内，然后进行 hexo s即可：12$ cd /Users/jerome/Hexo $ hexo s 然后你就会看到在终端提示你在localhost:4000预览你的博客啦！！如果你想在网页上看到你的博客，只需要在终端输入：12$ hexo g$ hexo d 稍等一小会(github pages需要一小段时间才会更新)，你就能在你仓库对应的那个网址(您的github用户名.io.git)看到您的博客了，至此，您的博客应该就已经搭建完成了，当然您肯定会说这也太丑了吧，对，我也觉得，所以接下来请继续看下面的操作吧！！！ Hexo主题配置默认的主题很丑，所以这个时候我们就可以去github这个最大的开源网站找了，我推荐Hexo的next主题，我自己用的就是这个，极简至极，找到别人的主题之后，把他的代码clone下来，放到/Hexo/themes这个文件夹下：然后去开始的_config.yml中定位到theme，将后面的值改为你的主题名，别忘了，改完这些后，打开终端，输入：12$ hexo g$ hexo d 过一小会你就能看到自己的主题发生变化啦！剩下的具体配置，我就偷偷懒放个链接：NexT主题，其他主题的同学，你们也可以自己查一下对应的官网哟，都写的贼详细，好用！ 总结至此，个人博客就应该搭建好了，希望对大家有所收获！!(话说第一篇博客果然是狗屁不通啊大家凑合看吧)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
</search>
