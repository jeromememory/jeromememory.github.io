<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JAVA对数组的四种拷贝方式]]></title>
    <url>%2F2019%2F10%2F07%2FJAVA%E5%AF%B9%E6%95%B0%E7%BB%84%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%8B%B7%E8%B4%9D%E6%96%B9%E5%BC%8F.html</url>
    <content type="text"><![CDATA[数组拷贝的四种方式 for clone System.arraycopy arrays.copyof 赋值、浅拷贝、深拷贝在谈及四种数组拷贝方式之前，先来缕缕赋值、浅拷贝、深拷贝三者的关系和区别。 数据类型谈及深拷贝和浅拷贝，首先要弄清数据类型有哪些,数据分为基本数据类型(元数据)和引用数据类型(对象引用)。 基本数据类型的特点：直接存储在栈(stack)中的数据 引用数据类型的特点：存储的是该对象在栈中引用，真实的数据存放在堆内存里，引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。 深拷贝和浅拷贝 深拷贝和浅拷贝是只针对引用类型的数据而言的，对于基本数据类型来说，深拷贝和浅拷贝都是直接进行值传递的，与赋值的方式是一样的，三者没有任何区别，区别就在于对于引用数据类型来说，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存,所以如果修改对象的话会互相影响。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。 总而言之，在数组内都是基本数据类型时，是不会有深拷贝和浅拷贝这样的概念出现的，只有出现了引用类型的数据，才能谈深拷贝和浅拷贝。Tips: String不是基本数据类型，但是在深复制的时候并没有进行单独的复制，也就是说违反了深复制，仅仅复制了引用，而String没有实现cloneable接口，也就是说只能复制引用。 那么在修改克隆之后的对象之后，会不会将原来的值也改变了? 答案肯定是不会改变，因为String是在内存中不可以被改变的对象，就比如说在for大量循环中不推荐使用+的方式来拼凑字符串一样，每次使用都会新分配一块内存，不在原来上修改，原来的没有指向它的引用，会被回收。所以克隆相当于1个String内存空间有两个引用，当修改其中的一个值的时候，会新分配一块内存用来保存新的值，这个引用指向新的内存空间，原来的String因为还存在指向他的引用，所以不会被回收，这样，虽然是复制的引用，但是修改值的时候，并没有改变被复制对象的值。 数组拷贝方式之一——for()就是for循环咯！！！ 12345/** 1 for 循环拷贝*/int[] arr1 = new int[len];for (int i = 0; i &lt; len; i++) &#123; arr1[i] = arr0[i];&#125; 也是浅拷贝咯！ 数组拷贝方式之二——clone()（主要参考）细说 Java 的深拷贝和浅拷贝 在 Java 中，所有的 Class 都继承自 Object ，而在 Object 上，存在一个 clone() 方法，它被声明为了 protected ，所以我们可以在其子类中，使用它。而无论是浅拷贝还是深拷贝，都需要实现 clone() 方法，来完成操作。 首先需要说明的是，clone()是浅拷贝的方式！！！其次，我们应该如何实现深拷贝呢，有两种方法： 用多层浅拷贝达到深拷贝的目的，要知道，浅拷贝和深拷贝的区别就是在处理对象引用时，浅拷贝不会创造新的对象，而深拷贝会，但是如果一个对象的属性变成了基本类型数据，那么浅拷贝同样会创造新的对象，所以说，多层浅拷贝就能达到深拷贝的目的，例如：在对fatherClass和childClass进行两级浅拷贝之后，fatherB就有浅拷贝变成了深拷贝，因为此时基本数据类型和Child对象都是指向不同的地址的，也就是二者都是不同的对象，所以就是达到了深拷贝的目的了。 序列化（serialization）这个对象，再反序列化回来，就可以得到这个新的对象，无非就是序列化的规则需要我们自己来写。总结下来就是做了5件事： 确保对象图中的所有类都是可序列化的 创建输入输出流 使用这个输入输出流来创建对象输入和对象输出流 将你想要拷贝的对象传递给对象输出流 从对象输入流中读取新的对象并且转换回你所发送的对象的类 最后，推一个序列化实现深拷贝的例子：序列化的方式使得其变为深拷贝 数组拷贝方式之三——System.arraycopy()native方法，依旧是一个浅拷贝——–&gt; 详细传送门 数组拷贝方式之四——arrays.copyof()1234567891011public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings("unchecked") //根据class的类型是否是 Object[] 来决定是 new 还是反射去构造一个泛型数组 T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); //使用 native 方法批量赋值元素至新数组中。 System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy;&#125; 你看看，底层也在用System.arraycopy()这个native方法，所以就不再赘述了，这个在ArrayList源码分析中也有涉及哦！！！！]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>Array</tag>
        <tag>JAVA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合源码分析之ArrayList]]></title>
    <url>%2F2019%2F10%2F06%2F%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8BArrayList.html</url>
    <content type="text"><![CDATA[#]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ArrayList</tag>
        <tag>jdk</tag>
        <tag>源码分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Leetcode算法题]]></title>
    <url>%2F2019%2F10%2F05%2FLeetcode%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[两数之和题目给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。 示例给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1] 我的思路 先排序 排除比target大的数 从最靠近target的数开始遍历 记录找到的数的下标输出即可 我的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.util.Arrays;public class twoNumbersSum &#123; public int[] twoSum(int[] nums, int target) &#123; //先排序 int[] nums_copy = Arrays.copyOf(nums,nums.length); Arrays.sort(nums_copy); int i; //排除比target大的数 //从最靠近target的数开始遍历 //记录找到的数的下标，输出即可 int t; int k; for(i = nums_copy.length-1; i &gt; 0 ;i--)&#123; if(nums_copy[i] &lt;= target)&#123; if(Arrays.binarySearch(nums_copy,0,i,target-nums_copy[i]) &gt;= 0)&#123; if(nums_copy[i] * 2 == target) &#123; int[] twobro = new int[2]; int d=0; for(int h=0;h&lt;nums.length;h++)&#123; if(nums[h] == nums_copy[i])&#123; twobro[d] = h; d++; &#125; &#125; return twobro; &#125; else&#123; for(int m=0;m &lt; nums.length;m++)&#123; if(nums[m] == nums_copy[i])&#123; t = m; &#125; if(nums[m] == (target-nums_copy[i]))&#123; k = m; &#125; &#125; k = Arrays.binarySearch(nums,target-nums_copy[i]); t = Arrays.binarySearch(nums,nums_copy[i]); &#125; return new int[]&#123;k,t&#125;; &#125; &#125; &#125; return null; &#125; public static void main(String[] args) &#123; twoNumbersSum tws = new twoNumbersSum(); int[] receive = new int[20]; receive = tws.twoSum(new int[]&#123;0,4,3,0&#125;,0); if(receive == null) &#123; System.out.println("不存在"); &#125; else&#123; System.out.println(receive[0] + "\n" + receive[1]); &#125; &#125;&#125; 正确思路利用 HashMap 记录数组元素值和对应的下标，对于一个数 nums[i]，判断 target - nums[i] 是否存在 HashMap 中，存在的话，返回两个下标组成的数组。注意，已存在的元素下标在前，当前元素下标在后。 正确代码123456789101112class Solution &#123; public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); for (int i = 0; i &lt; nums.length; ++i) &#123; if (map.containsKey(target - nums[i])) &#123; return new int[] &#123;map.get(target - nums[i]), i&#125;; &#125; map.put(nums[i], i); &#125; return null; &#125;&#125; 涉及的知识点数组内容 一维和二维数组一维数组：int[] a = new int[4];二维数组： 1234//第一行4个元素，第二行5个元素int[][] a = new int[2][];a[0] = new int[4];a[1] = new int[5]; Arrays类java.util.Arrays类能够方便的操作数组，提供的所有方法都是静态的： 12345678910import java.util.Arrays;public int[] twoSum(int[] nums, int target) &#123; int[] nums_copy = Arrays.copyOf(nums,nums.length); Arrays.fill(nums,2); Integer index = Arrays.binarySearch(nums,target); Arrays.equals(nums,nums_copy); Arrays.sort(nums); return new int[]&#123;0,0,0&#125;;&#125; 总共5个方法，分别是copyOf,fill,binarySearch,equals,sort。第一个用来复制原始数组，方便后续排序的操作，fill是用来初始化数组比较方便，可以将所有数组中的值全部初始化为同一个值，binarySearch是二分查找，返回的是该数的索引值，sort是用来排序的。 binarySearch()自己写代码的时候用到了这个方法，首先该方法需要数组排好序才能调用，其次很特别的是，如果要找的值在数组中，则会返回搜索键的索引，但是，注意：值不存在于数组的话会返回-1或者是目标值需要插入的位置，从1开始数起，不是0哦！！！这个写的贼好哈哈哈哈：数组查询Arrays类的binarySearch()方法详解 map.containsKey和map.get()区别hashmap判断是否存在key时，使用get(key)==null判断还是containsKey？key值可能为null，若此时Map集合值对象为null，并且没有个数限制，所以当get()方法的返回值为null时，可能有两种情况，一种是在集合中没有该键对象，另一种是该键对象没有映射任何值对象，即值对象为null。因此，在Map集合中不应该利用get(Object key)方法来判断是否存在某个键，而应该利用containsKey()方法来判断,containsKey方法用来判断Map集合对象中是否包含指定的键名。一句话概括:get()如果得到null，可能这是键对应的值对象为null也可能是不存在该键，而containsKey则是false或true，不存在这种疑问。 扩充:map.containsKey()、map.containsValue()、map.get() get的过程是先计算hash，然后通过hash与table.length取摸计算index值，然后遍历table[index]上的链表，直到找到key，然后返回； 1234567891011121314public V get(Object key) &#123; if (key == null) return getForNullKey();//处理null值 int hash = hash(key.hashCode());//计算hash //在table[index]遍历查找key，若找到则返回value，找不到返回null for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; return null; &#125; containsKey方法也是先计算hash，然后使用hash和table.length取摸得到index值，遍历table[index]元素查找是否包含key相同的值； 123456789101112131415public boolean containsKey(Object key) &#123; return getEntry(key) != null; &#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; int hash = (key == null) ? 0 : hash(key.hashCode()); for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; return null; &#125; 看代码能看到区别，一个是返回key对应的value值，一个是返回是否有该key的boolean变量。 containsValue方法就比较粗暴了，就是直接遍历所有元素直到找到value，由此可见HashMap的containsValue方法本质上和普通数组和list的contains方法没什么区别，你别指望它会像containsKey那么高效。 1234567891011public boolean containsValue(Object value) &#123; if (value == null) return containsNullValue(); Entry[] tab = table; for (int i = 0; i &lt; tab.length ; i++) for (Entry e = tab[i] ; e != null ; e = e.next) if (value.equals(e.value)) return true; return false; &#125; 知识缺陷 压根没想到用Map去做 自己只考虑到了全是正数的情况，所以用了排序和跟0判断，如果含有负数的话就做不了了…… 收获在遇到数组问题时，可以考虑用map，因为索引和数值就是一个天生的map集合，如果我知道数值，我就可以通过map找到其索引，本题思路就是这样，当已知一个值是我所需要的，直接从map中拿出就行。 插入知识点既然复习到了map，那就给list、set和map来一个全部的复习吧！！！嘿嘿开始吧！！！先来上个链接，主要是看的这个写的：Java集合中List,Set以及Map等集合体系详解(史上最全) collection先上个图：这个图画的好啊哈哈哈哈哈哈哈不瞎的都看得到，Collection这个接口下有三个接口继承，分别是Set、List、Queue(我他妈好像没怎么用过Queue啊，以后要多用点了)，Set有三个实现类，分别是HashSet、LinkedHashSet、TreeSet，List有三个实现类，分别是ArrayList、Vector(感觉现在是不是用的比较少啊…)、LinkedList，咦这个LinkedList牛逼啊，竟然还是Queue的实现类，不过看别人博客好像是说继承Queue部分的LinkedList是被阉割了的实现类，也就是Queue不能访问到LinkedList的所有方法(管它呢我都没用过…)，还有一个PriorityQueue,看名字就知道是优先级队列啦！(妈呀看的资料太多，想单独开一篇来总结集合源码和Map源码了…算了先这样写着吧) ####先列个提纲： 1.先综述一下collection中三个儿子接口得各个实现类的特点，比如底层实现，优缺点等等； 2.分别阐述，分述时记得贴上源码分析 3.面试常问到的点 综述— List 有序,可重复 ArrayList优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程不安全，效率高特点: 允许null，不同步Vector优点: 底层数据结构是数组，查询快，增删慢。缺点: 线程安全，效率低tips:所谓的线程安全，是相对的，在vector内部内部内部，其所有方法不会被多线程所访问，单个方法的原子性（注：原子性，程序的原子性即不会被线程调度机制打断），并不能保证复合操作也具有原子性，所以如果是复合操作，同样线程不安全！！如果要保证真正的线程安全，还需要以vector对象为锁，来进行操作，但这样就跟ArrayList没啥区别了…———–&gt; Vector是线程安全吗特点：允许null，不同步LinkedList优点: 底层数据结构是双向链表，查询慢，增删快。缺点: 线程不安全，效率高特点：允许null，不同步 —Set 无序,唯一 HashSet（不同步，允许null）底层数据结构是哈希表(无序,唯一)，其实就是HashMap的实例，只不过值是key，value是一个固定的对象。如何来保证元素唯一性?1.依赖两个方法：hashCode()和equals() LinkedHashSet（不同步，允许null）底层数据结构是双向链表和哈希表。(FIFO插入有序,唯一)，实际上依旧是LinkedHashMap的实例，待会源码分析看看1.由链表保证元素有序2.由哈希表保证元素唯一 TreeSet（允许null，不同步）底层数据结构是红黑树。(唯一，有序，这里的有序指的是排序好的，不是说FIFO之类的)，实际上依旧是TreeMap的实例 如何保证元素排序的呢?自然排序(重写):1.Student类中实现 Comparable接口 2.重写Comparable接口中的Compareto方法比较器排序:1.单独创建一个比较类，这里以MyComparator为例，并且要让其继承Comparator接口 2.重写Comparator接口中的Compare方法2.如何保证元素唯一性的呢?根据比较的返回值是否是0来决定 -Queue PriorityQueue：优先级队列，按照大小排序好了的队列，并不遵循先进先出，不允许null元素，头部是最小元素，底层采用的数组和堆。 * PriorityQueue不是线程安全的。如果多个线程中的任意线程从结构上修改了列表， 则这些线程不应同时访问PriorityQueue 实例，这时请使用线程安全的PriorityBlockingQueue 类。 * 不允许插入 null 元素。 * PriorityQueue实现插入方法（offer、poll、remove() 和 add 方法） 的时间复杂度是O(log(n)) ；实现 remove(Object) 和 contains(Object) 方法的时间复杂度是O(n) ；实现检索方法（peek、element 和 size）的时间复杂度是O(1)。所以在遍历时，若不需要删除元素，则以peek的方式遍历每个元素。 * 方法iterator()中提供的迭代器并不保证以有序的方式遍历PriorityQueue中的元素。 剩余有关Queue队列看—–&gt; Java集合（七） Queue详解 分别阐述这个还是另开一篇吧…内容太多了…够写两星期了！！还是不放在这喧宾夺主了!! map]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.2----10.7]]></title>
    <url>%2F2019%2F10%2F02%2F10-2-10-7.html</url>
    <content type="text"><![CDATA[10.2 学习完ajax异步调用； 完成添加然后数据库里有数据并且能正常跳转； b站上再看看springboot+mybatis的结合； 总结博客，分别总结分页排序还要mongodb在springboot中的相关操作； 收获 springboot启动很慢的原因：未修改host目录的文件，导致每次启动都很慢。步骤 在terminal终端输入: 1$ hostname 复制下来，然后修改host文件中的localhost： 1$ sudo vim /etc/hosts 然后将自己hostname替换掉localhost 123127.0.0.1&lt;两个tab&gt;localhost 替换为$hostname255.255.255.255&lt;两个tab&gt;broadcasthost::1&lt;两个tab&gt;localhost 替换为$hostname 在js传值给controller时，一直不能将json数据传过去，原因是没有给data的值加上JSON.stringify()处理，具体错误：springboot 接收参数，解析json出现错误：was expecting ‘null’, ‘true’, ‘false’ or NaN解决方案：见—-&gt;js与controller之间传值常见问题 JQuery.ajaxajax和springboot传值 jquery中字符串转日期，日期转字符串 MyBatis主键回填策略 表中部分属性自动生成，不需要额外传入参数 先是尝试了在bean中加@value，加载配置文件中的随机数，但是发现执行一次，随机数是唯一的，这样就不能做到插入一条数据，随机数就变化； 后面发现可以在mybatis直接配置结果集，好像也不行…因为如果你用结果集将id转换为taskId,那原本bean中的id属性就会取不到值… jQuery获取html中的值获取html中的值 10.3收获使用最大的id！！！mysql插入数据后返回自增ID的方法（AUTO_INCREMENT） 10.4收获 复杂json转成多层map 12345678910111213141516171819public Map&lt;String, Object&gt; parseJSON2Map(@RequestBody String jsonStr)&#123; Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); JSONObject json = JSONObject.parseObject(jsonStr); for(Object k : json.keySet())&#123; Object v = json.get(k); if(v instanceof JSONArray)&#123; List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList&lt;Map&lt;String,Object&gt;&gt;(); Iterator it = ((JSONArray)v).iterator(); while(it.hasNext())&#123; Object json2 = it.next(); list.add(parseJSON2Map(json2.toString())); &#125; map.put(k.toString(), list); &#125; else &#123; map.put(k.toString(), v); &#125; &#125; return map; &#125; mac强制刷新缓存：command + shift + R普通刷新：command + R Springboot使用多线程 最近遇到一个需求，就是当服务器接到请求并不需要任务执行完成才返回结果，可以立即返回结果，让任务异步的去执行。开始考虑是直接启一个新的线程去执行任务或者把任务提交到一个线程池去执行，这两种方法都是可以的。但是 Spring 这么强大，肯定有什么更简单的方法，就 google 了一下，还真有呢。就是使用 @EnableAsync 和 @Async 这两个注解就 ok 了。传送门：SpringBoot非官方教程 | 第二十三篇： 异步方法 首先声明一下自己用了比较长的时间才弄出来的原因是，自己把异步方法写到了Controller层，导致在controller的另一个方法调用时无法开启异步功能，所以对此我有三点见解： 在@SpringBootApplication启动类 添加注解@EnableAsync 异步方法使用注解@Async ,返回值为void或者Future 切记一点，异步方法和调用方法一定要 写在不同的类中,如果写在一个类中，是没有效果的，至于为什么—-&gt;因为Spring像@Transaction @Async等这些都是使用了动态代理，Spring容器在初始化的时候就会将含有AOP注解的类对象替换为代理对象，再由Proxy对象去调用被增强方法，重点来了：方法里想用增强方法(第三点)则需要得到当前的Proxy对象，但如果是同一个类的话，是不会经过spring容器的，此时是真正的对象本身去调用方法，并不是代理对象，这样的话被增强方法就失效了，详情请看 -&gt;Spring的 AopContext.currentProxy()方法 解决方案 我采用的方案是，将异步方法写入service层，然后再controller层中调用，这样就经过了spring容器，调用方法时就是采用的代理对象。 第二种方法，我没有成功！！！！真的是气的不行，因为我看网上博客别人都成功了……就是用AopContext.currentProxy()这个方法,步骤为： 添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 在启动类中添加注释 1@EnableAspectJAutoProxy(exposeProxy=true,proxyTargetClass=true) 然后在调用方法处写： 1((TaskController)AopContext.currentProxy()).testAsy("www.baidu.com"); 按理说应该可以了的，结果吧，我一跑程序就报错，说我的哦代理怎么没暴露啊，我真是卧槽了，那他妈不是已经配置了暴露了嘛！！！我服了！！！算了，懒得搭理了…甩个跟这个原理一样的链接，学习一下：JDK动态代理给Spring事务埋下的坑！再甩一个链接，三种方法配置这个exposeProxy(然而我一个都没成功…)—-&gt;springboot中如何配置aop动态代理模式 (原创)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019-9-26]]></title>
    <url>%2F2019%2F09%2F26%2F2019-9-26.html</url>
    <content type="text"><![CDATA[今日任务 springboot + mongodb,完成mongo在springboot中的搭建，写一个小demo 最主要的是把repository这一层写完，业务逻辑可以放到明天来写 完成过程mongodb的安装macOS下mongodb的安装与启动 Springboot下的相关注解 @DataData注解使用 @Document标注在实体类上，类似于hibernate的entity注解，标明由mongo来维护该表，collection代表表的名称。SpringBoot中MongoDB中的相关注解 @Entity等一系列Spring Data JPA注解 @DynamicUpdate、@DynamicInsert 是hibernate里面的注解，这两个注解加上之后就不会为字段值不变的字段生成sql语句，这样sql的长度就减少了提高了传输效率和执行效率，在插入和修改数据的时候,语句中只包括要插入或者修改的字段。 @Entity 标识这个实体类是一个JPA实体，告诉JPA在程序运行的时候记得生成这个实体类所对应的表~！ GeneratedValue、GenericGenerator是用于主键生成策略的，具体见JPA注解主键生成策略-UUID @Column（name = “自定义字段名”，length = “自定义长度”，nullable = “是否可以空”，unique = “是否唯一”，columnDefinition = “自定义该字段的类型和长度”）。表示对这个变量所对应的字段名进行一些个性化的设置，例如字段的名字，字段的长度，是否为空和是否唯一等等设置。 剩余注释：Spring Data JPA中常用的注解详解 @Controller（Spring Boot之 Controller 接收参数和返回数据总结(包括上传、下载文件)）Controller层的注解大概有以下一些：（主要参考：Controller层主要注解） @Controller:标注 Controller 类，处理 http 请求 @RestController:标注 Controller 类，spring 4 新加注解，相当于@Controller + @ResponseBody ，主要是为了使 http 请求返回数据格式为 json 格式，正常情况下都是使用这个注解 @RequestMapping:配置 url 映射，可以作用于类上，也可以在方法上 123456789@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.GET) public String say() &#123; return "我是张少林"; &#125;&#125; @RequestMapping 定义在类上，指定该类下的所有接口 url 映射在 /users 下，定义在方法上，指定 请求方法，可以指定GET，POST，DELETE，PUT四种标准的 Restfulapi请求方法。那么此时的接口 url 为：http://127.0.0.1:8080/users/myInfo 请求方法：GET，类上也可以不用配置 url 映射的。 @PathVariable获取 url 中的数据，我们在 url 中拼接一个字符串 {username}，类似于地址占位符，由用户请求时添加，请求获取。注意注解中的参数必须与占位符参数一致 12345678@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo/&#123;username&#125;", method = RequestMethod.GET) public String say(@PathVariable("username") String username) &#123; return username; &#125;&#125; @RequestParam获取请求参数值，方法随意可以设置，但是通常需求都是使用 POST 请求处理表单提交。 12345678@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.POST) public String say(@RequestParam(value = "username") String username, @RequestParam(value = "password") String password) &#123; return username + password; &#125;&#125; 假如用户输入的的uri是:http://127.0.0.1:8080/users/myInfo?username=yangweijie&amp;password=123456，那么最后返回的是yangweijie123456，如果参数不带值且添加属性required=true，则会报错，此时就建议添加一个defaultValue属性： 12345678910@RestController//处理http请求，返回json格式@RequestMapping(value = "/users")//配置url，让该类下的所有接口url都映射在/users下public class UserController &#123; @RequestMapping(value = "/myInfo", method = RequestMethod.POST) public String say(@RequestParam(value = "username",required = false,defaultValue = "张少林") String username, @RequestParam(value = "password",required = false,defaultValue = "123456") String password) &#123; return username + password; &#125;&#125; @GetMapping、@PostMapping、@DeleteMapping、@PutMapping等是RequestMapping的组合注解，根据method的不同。 @RequestHeader可以把Request请求header部分的值绑定到方法的参数上。 @CookieValue可以把Request header中关于cookie的值绑定到方法的参数上。 RequestBody该注解常用来处理Content-Type: 不是application/x-www-form-urlencoded编码的内容，例如application/json, application/xml等；它是通过使用HandlerAdapter 配置的HttpMessageConverters来解析post data body，然后绑定到相应的bean上的。因为配置有FormHttpMessageConverter，所以也可以用来处理 application/x-www-form-urlencoded的内容，处理完的结果放在一个MultiValueMap&lt;String, String&gt;里，这种情况在某些特殊需求下使用，详情查看FormHttpMessageConverter api; ModelAttribute(参考：Spring MVC @ModelAttribute详解)@ModelAttribute有三种用法： 可以标注在方法上； 可以标注在方法中的参数上； 还可以和@RequestMapping一起标注在方法上；目的都是在RequestMapping之前进行model属性的注入，对RestController好像没用，因为是返回json数据，并不能将model里面的数据直接返回给页面。如果没用@RestController，则@ModelAttribute方法通常被用来填充一些公共需要的属性或数据，比如一个下拉列表所预设的几种状态，或者宠物的几种类型，或者去取得一个HTML表单渲染所需要的命令对象，比如Account等。@ModelAttribute标注方法有两种风格： 12345678910111213141516// Add one attribute// The return value of the method is added to the model under the name "account"// You can customize the name via @ModelAttribute("myAccount")@ModelAttributepublic Account addAccount(@RequestParam String number) &#123; return accountManager.findAccount(number);&#125;// Add multiple attributes@ModelAttributepublic void populateModel(@RequestParam String number, Model model) &#123; model.addAttribute(accountManager.findAccount(number)); // add more ... &#125; 在第一种写法中，方法通过返回值的方式默认地将添加一个属性，在第二种写法中，方法接收一个Model对象，然后可以向其中添加任意数量的属性，可以在根据需要，在两种风格中选择合适的一种。model里的数据会被放入到request中,页面通过request域可以获取到。 @SessionAttributes和@SessionAttribute@SessionAttributes注解的使用就是将属性放入session域内，然后可以在session域内进行相关的操作。 SpringMVC中@ModelAttribute和@SessionAttributes注解的使用 @id（好像如果表中数据字段是id，会比较特殊一点，springboot会自动检索传过来的参数是否有id，如果没有会自动添加id） Repository相关注解 Springboot的分页和排序操作由于采用的是Mongo数据库，所以先后使用了MongoTemplate()和MongoRepository(),MongoTemplate在写法上比MongoRepository 更复杂一些，但是带来更多的灵活性。对于复杂的查询操作，我们一般使用MongoTemplate，对于一些简单的查询我们会使用MongoRepository 。可以这么理解，MongoRepository 只是作为一种对于简单查询的简便操作，而MongoTemplate才是我们在做一些复杂查询时的首选。 MongoRepository自己还借用了下@Query和@Modifying注解，方便自己摆脱关键字的查询，如果需要进行更新或者删除数据，则需要在@Query之上加上@Modifing。]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>springboot</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[百度前端技术学院66天学习(争取一个月内完成！)]]></title>
    <url>%2F2019%2F09%2F23%2F%E7%99%BE%E5%BA%A6%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E5%AD%A6%E9%99%A266%E5%A4%A9%E5%AD%A6%E4%B9%A0-%E4%BA%89%E5%8F%96%E4%B8%80%E4%B8%AA%E6%9C%88%E5%86%85%E5%AE%8C%E6%88%90%EF%BC%81.html</url>
    <content type="text"><![CDATA[day 1:日期，今天的学习总用时，今天学习的目标是什么，是否达成 今天是2019.9.20，距离春招还有将近6个月的时间，预计1个半月将ife学完并且将js看完，后期开始刷leetcode和vue框架的学习 今天的学习时长总用时为30min 今天的学习目标是搭建好前端环境，做好长期准备学习的过程 目标已达成，将以博客的形式每天更新自己所学内容 哪些东西今天了解得比较透彻，说说自己的理解今天最大的收获是看到了许多非常极具创意的web，也激励自己能够更好的学习前端知识，希望半年后的自己能有一个大大的成长吧！！！ 哪些东西今天了解到了一些，还有哪些点需要后续继续深入阅读今天的内容好像没有什么难的，项目也比较忙，最近在看js，大概看完了前面4章了，后续尽量加快一些进度 哪些东西今天学了之后还有很多疑问没有被解答，把问题记录下来，以待后续解决今天暂无 立Flag，写下大家参加今年前端学院的目标找到一份好实习，找到一份好工作，成为更好的自己 day 2：问题： 这里面的可枚举属性名不知道啥意思； 个人暂时理解：就是是否可遍历的意思 对这个Object.prototype不熟悉！！！ day 3：问题： 图中为什么用Object.defineProperty()就可以完成对writable:false的属性的修改，但是直接用obj.属性的形式就不行？图中所谓的原型链又是什么意思？ 图中的JSON.stringify方法没有接触]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>ife</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS学习]]></title>
    <url>%2F2019%2F09%2F21%2FJS%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[学习过程：promise—&gt;箭头函数—&gt;作用域—&gt;闭包 js基础入门篇基本语法变量提升JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。其中，函数名同样被视为变量名，所以一样会被提升到代码头部。 标识符 不能以数字开头，可以以 _ 和 $ 开头 JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。 标签js允许语句前面可以带有标签，方便跳出块区域和多重循环，常与for循环、continue、break连用。 数据类型##null，布尔值 boolean如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为false，其他值都视为true。 undefined null false 0 NaN “”或’’（空字符串） 注意，{}和[]都是true。 数值 js中所有数都是小数，64位，其中符号位1位，表示指数的11位，剩余的52位表示精度，但是由于表示精度的最高位1.xxxx中的1被省略，所以可以表示53位精度； parseInt即将字符串转换为整数型，不管是不是字符串，都会先转换为字符串,再转为整数型，其中，parseInt可以传入两个参数，第二个参数可以是转换进制值； 字符串 想输出多行字符串，有一种利用多行注释的变通方法 12345678(function () &#123; /*line 1line 2line 3*/&#125;).toString().split('\n').slice(1, -1).join('\n')// "line 1// line 2// line 3" Base64转码 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。 JavaScript 原生提供两个 Base64 相关的方法。 btoa()：任意值转为 Base64 编码 atob()：Base64 编码转为原来的值 123var string = 'Hello World!';btoa(string) // "SGVsbG8gV29ybGQh"atob('SGVsbG8gV29ybGQh') // "Hello World!" * 要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。 12345678910function b64Encode(str) &#123; return btoa(encodeURIComponent(str));&#125;function b64Decode(str) &#123; return decodeURIComponent(atob(str));&#125;b64Encode('你好') // "JUU0JUJEJUEwJUU1JUE1JUJE"b64Decode('JUU0JUJEJUEwJUU1JUE1JUJE') // "你好" 对象 对象的引用两个变量同时指向同一个对象，其中任何一个变量添加属性，另一个变量都可以读写该属性，但是如果取消某个变量对于原对象的引用，并不会影响到另一个变量；注意:仅限于对象，如果两个变量同时指向同一个原始类型的值，那么变量此时都是值的拷贝而已； 如果行首是一个大括号，js引擎一律将其解释为代码块，如果想要表示为对象，则必须在大括号前加上一个圆括号，这种差异在eval语句（作用是对字符串求值）中体现的尤为明显； 12eval('&#123;foo: 123&#125;') // 123eval('(&#123;foo: 123&#125;)') // &#123;foo: 123&#125; 属性读取：一种使用点运算符，另外一种采用方括号运算符，注意若使用方括号运算符，键名必须放在引号里面，否则会被当做变量处理： 123456789var foo = 'bar';var obj = &#123; foo: 1, bar: 2&#125;;obj.foo // 1obj[foo] // 2 查看一个对象本身所有属性，可以使用Object.keys方法 1234567var obj = &#123; key1: 1, key2: 2&#125;;Object.keys(obj);// ['key1', 'key2'] 属性的遍历：for…in 循环: 它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。 它不仅遍历对象自身的属性，还遍历继承的属性。 123456789101112var obj = &#123;a: 1, b: 2, c: 3&#125;;for (var i in obj) &#123; console.log('键名：', i); console.log('键值：', obj[i]);&#125;// 键名： a// 键值： 1// 键名： b// 键值： 2// 键名： c// 键值： 3 with语句：作用是操作同一个对象的多个属性时，提供方便，但是不建议使用，因为在with语句里面没有改变作用域，导致绑定对象不明确，如果with区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。 12345678var obj = &#123;&#125;;with (obj) &#123; p1 = 4; p2 = 5;&#125;obj.p1 // undefinedp1 // 4 函数函数声明 function命令 123function print(s)&#123; console.log(s);&#125; 函数表达式(如果function后带函数名，函数名也只在函数体内部有效) 1var print = function()&#123;console.log(s)&#125;; Function构造函数 12345678910var add = new Function( 'x', 'y', 'return x + y');// 等同于function add(x, y) &#123; return x + y;&#125; 函数ToString可以解析注释实现多行字符串： 12345678910111213var multiline = function (fn) &#123; var arr = fn.toString().split('\n'); return arr.slice(1, arr.length - 1).join('\n');&#125;;function f() &#123;/* 这是一个 多行注释*/&#125;multiline(f);// " 这是一个// 多行注释" 函数作用域在ES6中，有三种作用域：全局作用域、块作用域、函数作用域。函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。 1234567891011var a = 1;var x = function () &#123; console.log(a);&#125;;function f() &#123; var a = 2; x();&#125;f() // 1 上面代码中，函数x是在函数f的外部声明的，所以它的作用域绑定外层，内部变量a不会到函数f体内取值，所以输出1，而不是2。 总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。所以说，如果函数A调用函数B,函数B不会引用函数A的内容。 参数传值 函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递； 函数参数如果是复合类型的值（数组、对象、其他函数），传递方式是传址传递； 函数内部修改的如果是参数对象的某个属性，那么会影响到原始值，如果是替换掉整个参数，则不会影响到原始值： 12345678var obj = [1, 2, 3];function f(o) &#123; o = [2, 3, 4];&#125;f(obj);obj // [1, 2, 3] arguments arguments对象包含了函数运行时的所有参数，但是它并不是一个数组，而是一个对象，所以它不能用数组中的slice和forEach方法； 在正常模式下，arguments对象可以在运行时修改，但是在严格模式下，修改arguments对象的值并不会改变真实参数的值； 如果要让arguments对象使用数组方法，真正的解决办法就是让arguments对象变为数组，常用的转换方法有两种，分别是slice方法和逐一填入新数组： 1234567var args = Array.prototype.slice.call(arguments);// 或者var args = [];for (var i = 0; i &lt; arguments.length; i++) &#123; args.push(arguments[i]);&#125; 闭包闭包，简而言之就是函数中的函数，闭包最大的特点，就是它可以“记住”诞生的环境，用处有三个： 1. 可以读取函数内部的变量； 2. 让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在; 3. 封装对象的私有属性和私有方法。 123456789101112131415161718192021222324252627282930313233function createIncrementor(start) &#123; return function () &#123; return start++; &#125;;&#125;var inc = createIncrementor(5);inc() // 5inc() // 6inc() // 7``` ```jsfunction Person(name) &#123; var _age; function setAge(n) &#123; _age = n; &#125; function getAge() &#123; return _age; &#125; return &#123; name: name, getAge: getAge, setAge: setAge &#125;;&#125;var p1 = Person('张三');p1.setAge(25);p1.getAge() // 25 “立即调用的函数表达式”（Immediately-Invoked Function Expression）123(function()&#123; /* code */ &#125;());// 或者(function()&#123; /* code */ &#125;)(); 通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。 eval 本质是在当前域中注入代码，可以接受一个字符串作为参数，并且将该字符串当做语句执行，如果识别不是字符串，则会原样返回。 同时，eval没有自己的作用域，会改变当前域原有变量的值，当然在严格模式下，eval内部自己声明的变量有自己的作用域，不会影响到外部作用域的值。 由于引擎无法分辨eval的别名调用，所以在eval使用别名时，一律都是全局作用域。 数组数组遍历 数组遍历可以考虑使用for循环、while循环、forEach循环，会返回键值（键名为整数），for…in…循环会同时遍历非整数键（返回的是键名）； 数组遍历空位时，需要格外注意，空位和undefined是不一样的，空位表示数组中没有这个元素，所以在for…in…和forEach循环中不会被遍历到，但是undefined代表数组有这个元素，是会遍历到的； 运算符算术运算符加法运算符 对象的相加如果运算子是对象，必须先转成原始类型的值，引擎会自动调用obj.valueof().toString(),所以我们可以重新valueOf()和toString()方法即可，其中有个特例，当运算子是一个Date对象的实例，那么会优先执行toString方法。 指数运算符** 为指数运算符，是右结合的，当然，三元条件运算符也是右结合的，当然还有赋值运算符（=）也是右结合的。 比较运算符 严格相等运算符JavaScript 提供两种相等运算符：== 和 === 。简单说，它们的区别是相等运算符（==）比较两个值是否相等，严格相等运算符（===）比较它们是否为“同一个值”。如果两个值不是同一类型，严格相等运算符（===）直接返回false，而相等运算符（==）会将它们转换成同一个类型，再用严格相等运算符进行比较。tip: undefined和null与自身严格相等布尔运算符略二进制位运算符略 其他运算符，运算顺序void 运算符void运算符的作用是执行一个表达式，然后不返回任何值，或者说返回undefined，主要用途是浏览器的书签工具，以及在超链接中插入代码防止网页跳转。 语法专题错误处理机制原生错误类型 SyntaxError ReferenceError RangeError TypeError URIError EvalError 自定义错误除了 JavaScript 原生提供的七种错误对象，还可以定义自己的错误对象 1234567function UserError(message) &#123; this.message = message || '默认信息'; this.name = 'UserError';&#125;UserError.prototype = new Error();UserError.prototype.constructor = UserError; 上面代码自定义一个错误对象UserError，让它继承Error对象。然后，就可以生成这种自定义类型的错误了 1new UserError('这是自定义的错误！'); 标准库Object四个用法： Object本身就是一个函数，可以将任意值转换为对象； 不仅可以当做工具函数使用，还可以当做构造函数使用，即前面可以加new命令； 1注意，通过var obj = new Object()的写法生成新对象，与字面量的写法var obj = &#123;&#125;是等价的。或者说，后者只是前者的一种简便写法。 Object的静态方法，例如Object.print,指部署在Object对象自身的方法； Object的实例方法，即定义在Object.prototype对象上的方法。 Object.prototype.valueof() Object.prototype.toString() Object.prototype.toLocaleString() Object.prototype.hasOwnProperty() Object.prototype.isPrototypeof() Object.prototype.propertyIsEnumerable() 属性描述对象js提供了一个内部数据结构，用来描述对象的属性，比如是否可写可读可遍历，这个内部数据结构就称之为“属性描述对象”。 tip:Object.getOwnPropertyNames方法返回一个数组，成员是参数对象自身的全部属性的属性名，不管该属性是否可遍历。而这跟Object.keys的行为不同，Object.keys只返回对象自身的可遍历属性的全部属性名。 123456789101112Object.keys([]) // []Object.getOwnPropertyNames([]) // [ 'length' ]Object.keys(Object.prototype) // []Object.getOwnPropertyNames(Object.prototype)// ['hasOwnProperty',// 'valueOf',// 'constructor',// 'toLocaleString',// 'isPrototypeOf',// 'propertyIsEnumerable',// 'toString'] 上面代码中，数组自身的length属性是不可遍历的，Object.keys不会返回该属性。第二个例子的Object.prototype也是一个对象，所有实例对象都会继承它，它自身的属性都是不可遍历的。 Object.defineProperty(),Object.defineProperties()Object.defineProperty()方法接收三个参数，依次如下： Object：属性所在的对象 propertyName:字符串，表示属性名 attributesObject:属性描述对象 1234567891011var obj = Object.defineProperty(&#123;&#125;, 'p', &#123; value: 123, writable: false, enumerable: true, configurable: false&#125;);obj.p // 123obj.p = 246;obj.p // 123 Object.defineProperties()接收两个参数，如下： 123456789101112var obj = Object.defineProperties(&#123;&#125;, &#123; p1: &#123; value: 123, enumerable: true &#125;, p2: &#123; value: 'abc', enumerable: true &#125;, p3: &#123; get: function () &#123; return this.p1 + this.p2 &#125;, enumerable:true, configurable:true &#125;&#125;);obj.p1 // 123obj.p2 // "abc"obj.p3 // "123abc" Object.prototype.propertyIsEnumerable()返回一个布尔值，用来判断自身属性是否可以遍历。Object.keys是返回所有可以遍历的属性，不包括继承的属性，而Object.getOwnPropertyNames则是返回包括继承的属性在内的所有可以遍历的属性。 es6入门len和const命令lenlen没有变量提升必须先声明后才能使用，注意len变量只在块区域内有用，是块级作用域，而var不同，var具有全局作用域、函数作用域； 暂时性死区123456var tmp = 123;if (true) &#123; tmp = 'abc'; // ReferenceError let tmp;&#125; 在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。非常隐蔽的“死区”： 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。但在ES6中，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined node js入门]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>js</tag>
        <tag>nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Microsoft Remote Desktop for mac 和 Spark邮箱]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%BD%BF%E7%94%A8Microsoft-Remote-Desktop-for-mac-%E5%92%8C-Spark%E9%82%AE%E7%AE%B1.html</url>
    <content type="text"><![CDATA[前言由于近期需要远程控制windows服务器，所以需要选择一个远程操控的软件，由于mac端并没有嵌入相关的功能，只能选择Microsoft Remote Desktop，并且遗憾的是，在中国区的app store并没有允许其上线，所以要做的第一步就是申请一个美区账号。 步骤 chrome打开apple id注册 按步骤注册，国家填写美国，注册完成之后需要登录一下 登录的时候会要求填写地址，以下是可用的信息街道: 4114 Sepulveda Blvd，城市: Culver City，州: CA邮编: 90230电话: (626) 339-6***商家名称: Clippinger Chevrolet Oldsmobile注意电话号码后三位随便填写几个数字 登录App Store，然后下载即可使用 Spark写这个主要是想吐槽一下，看到网上b乎各种说spark可以接收推送，即使没有打开软件，我想说简直是放屁啊，导致我查了几个小时都没能成功，根本做不到好吗！！！不信？看官网怎么说的 ——–&gt;Spark帮助中心所以只能一直开着了…垃圾的一批！！！！！！]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[最近事宜]]></title>
    <url>%2F2019%2F09%2F01%2F%E6%9C%80%E8%BF%91%E4%BA%8B%E5%AE%9C.html</url>
    <content type="text"><![CDATA[最近生病了…加上开学事情很多…停更了一个星期 接下来会慢慢跟上的加油🆙]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Flask + PyJWT 实现基于Json Web Token的用户认证授权]]></title>
    <url>%2F2019%2F08%2F23%2FFlask-PyJWT-%E5%AE%9E%E7%8E%B0%E5%9F%BA%E4%BA%8EJson-Web-Token%E7%9A%84%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E6%8E%88%E6%9D%83.html</url>
    <content type="text"><![CDATA[前言这注定又将是一篇长文，接触到的第一个关于python的框架flask，本文将从最开始的安装flask，到与mysql结合，最后到用pyjwt和flask-jwt和restful写一个带有token的接口。 技术栈简介Flask是一个使用Python编写的轻量级Web应用框架。基于Werkzeug WSGI(PythonWeb服务器网关接口（Python Web Server Gateway Interface，缩写为WSGI)是Python应用程序或框架和Web服务器之间的一种接口，已经被广泛接受, 它已基本达成它的可移植性方面的目标)工具箱和Jinja2 模板引擎。 Flask使用BSD授权。 Flask也被称为“microframework”，因为它使用简单的核心，用extension增加其他功能。Flask没有默认使用的数据库、窗体验证工具。然而，Flask保留了扩增的弹性，可以用Flask-extension加入这些功能：ORM、窗体验证工具、文件上传、各种开放式身份验证技术 SQLAlchemyFlask是一个微型框架，自身没有提供数据库管理，表单验证，cookie处理等功能，很多功能需要通过扩展才能实现，数据库管理就需要SQLAlchemy。SqlAlchemy是Python编程语言下的一款ORM框架，该框架建立在数据库API之上，使用关系对象映射进行数据库操作，简而言之：将对象转换成SQL，然后使用数据API执行SQL并获取执行结果。 The first demo123456789from flask import Flaskapp = Flask(__name__)@app.route("/")def index(): return "hello world"if __name__ == '__main__': app.run() 第一行 from…import…就是导入flask中的Flask模块，不同于直接import，from…import简单来说就是帮我从车里拿瓶水，而import则是把车拿过来，所以二者在使用的时候还是有些区别的，在导入某个.py文件时，使用from…import…可以直接在该文件夹下使用import后的函数名，而如果是import，如果要调用函数必须用类.模块。 第二行 这行代码里有一个参数name，这个参数用到告诉flask你的application的名字，官方有一句话： 12If you are using a single module,__name__ is always the correct value.If you however are using a package, it’s usually recommended to hardcode the name ofyour package there. 意思就是说，如果是单一的应用，用name就可以了，如果是一个应用程序包，就hardcode一个名字给这个参数。比如： 1app = Flask(“myApp”) 由于目前我们的应用都相对简单，所以统一使用name作为参数。 第三行 使用route()修饰器注明通过什么样的url可以访问我们的函数，同时在函数中返回要显示在浏览器中的信息。 最后 调用run()方法，运行flask web应用程序 12if __name__ == '__main__': app.run() 其中if __name__==&#39;__main__&#39;的意思是，如果此文件是直接运行的才会执行app.run()这个方法，如果是通过import在其它py文件中调用的话是不会执行的。 比如我们修改code.py中的hello_world方法，如下： 1234567@app.route('/index')def hello_world(): if __name__=='main': return 'Hello World!' else: return "hello my name is "+__name__ 即当name为main时还是执行原来的逻辑，返回hello world，如果不是则输出此时的名字。 然后我们新建一个sub.py文件然后导入code.py，并且执行hello_world方法: 1234567import codedef CallCodeFun(): result = code.hello_world() print(result)CallCodeFun()print(__name__) 此时的name是Code而不是main，而此时，在sub.py中加一句print(name)可以发现sub.py中的name变成了main 由此我们可以得出 name 如果是 main 那么代表他是一个入口文件，直接执行的。 tip:建文件时文件名最好不要叫code，因为python有模块名就叫code。 flask-sqlalchemy 数据库配置，上demo 12345678910111213141516171819202122from flask_sqlalchemy import SQLAlchemyfrom flask import Flaskimport configparser# 告诉flask app的名字app = Flask(__name__)//通过configparser获取读取配置文件的解释器my_config = configparser.ConfigParser()my_config.read('db.conf')# dialect+driver://username:password@host:port/database?charset=utf8# 配置 sqlalchemy 数据库驱动://数据库用户名:密码@主机地址:端口/数据库?编码# py3无法继续使用sqldb，所以采用pymysqlapp.config['SQLALCHEMY_DATABASE_URI'] = 'mysql://' + my_config.get('DB', 'DB_USER') + ':' + \ my_config.get('DB', 'DB_PASSWORD') + '@' + my_config.get('DB', 'DB_HOST') + '/' + \ my_config.get('DB', 'DB_DB') # 设为True 表示每次请求结束后都会自动提交数据库的变动，但像add delete insert等仍需要commit,建议不要设为trueapp.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = Truemydb = SQLAlchemy()mydb.init_app(app)if __name__ == "__main__": app.run(debug=True) 为了使代码结构更清晰，这里使用另一种配置方式，即使用单独配置文件的文件来做全局Flask配置 管控所有的配置文件conf.py: 1234567DB_USER = 'root'DB_PASSWORD = 'jwyjwy9951206-=-'DB_HOST = 'localhost'DB_DB = 'flask_migrate_demo'DEBUG = True SQLALCHEMY_TRACK_MODIFICATIONS = FalseSQLALCHEMY_DATABASE_URI = 'mysql+pymysql://' + DB_USER + ':' + DB_PASSWORD + '@' + DB_HOST + '/' + DB_DB SQLAlchemy允许我们根据数据库的表结构来创建数据模型，反之亦可。 所以我们一般无须手动的登录到数据库中使用 SQL 语句来创建表, 我们只需把数据模型定义好了之后, 表结构也就有了 新建model.py，并定义一个用户表数据模型 12345678from flask_sqlalchemy import SQLAlchemydb = SQLAlchemy()class User(db.Model):user_id = db.Column(db.Integer, primary_key=True)user_name = db.Column(db.String(60), nullable=False)user_password = db.Column(db.String(30), nullable=False)user_nickname = db.Column(db.String(50))user_email = db.Column(db.String(30), nullable=False) 新建db.py，利用Flask-Script和Flask-Migrate，搭建db和app之间的桥梁 1234567891011from flask import Flaskfrom flask_script import Managerfrom flask_migrate import Migrate, MigrateCommandfrom model import dbapp = Flask(__name__)app.config.from_object('conf')migrate = Migrate(app, db)manager = Manager(app)manager.add_command('db', MigrateCommand)if __name__ == '__main__':manager.run() Flask-Script和Flask-Migrate使用 最后，在pycharm的控制台打下三行迁移代码，这样就能在数据库中看见跟model字段一样的表了 123python db.py db initpython db.py db migratepython db.py db upgrade 示例接口实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091# 用到flask中的Flask框架，jsonify返回json数据，request将前端字段传入后端from flask import Flask, jsonify, request# 将model中的User，db对象传入from model import db, User# 告诉flask这个app要用它app = Flask(__name__)# 读取配置文件，主要是连接mysqlapp.config.from_object('conf')# 初始化db.init_app(app)# 开始路由@app.route('/')def index(): return '&lt;h1&gt;Hello Flask!&lt;/h1&gt;'# 增@app.route('/user', methods=['POST'])def addUser(): user_name = request.form.get('user_name') user_password = request.form.get('user_password') user_nickname = request.form.get('user_nickname') user_email = request.form.get('user_email') user = User(user_name=user_name, user_password=user_password, user_nickname=user_nickname, user_email=user_email) try: db.session.add(user) db.session.commit() except: db.session.rollback() db.session.flush() userId = user.user_id if (user.user_id is None): result = &#123;'msg': '添加失败'&#125; return jsonify(data=result) data = User.query.filter_by(user_id=userId).first() result = &#123;'user_id': data.user_id, 'user_name': data.user_name, 'user_nickname': data.user_nickname, 'user_email': data.user_email&#125; return jsonify(data=result)# 查@app.route('/user/&lt;int:userId&gt;', methods=['GET'])def getUser(userId): user = User.query.filter_by(user_id=userId).first() if (user is None): result = &#123;'msg': '找不到数据'&#125; else: result = &#123;'user_id': user.user_id, 'user_name': user.user_name, 'user_nickname': user.user_nickname, 'user_email': user.user_email&#125; return jsonify(data=result)# 改@app.route('/user/&lt;int:userId&gt;', methods=['PATCH'])def updateUser(userId): user_name = request.form.get('user_name') user_password = request.form.get('user_password') user_nickname = request.form.get('user_nickname') user_email = request.form.get('user_email') try: user = User.query.filter_by(user_id=userId).first() if (user is None): result = &#123;'msg': '找不到要修改的记录'&#125; return jsonify(data=result) else: user.user_name = user_name user.user_password = user_password user.user_nickname = user_nickname user.user_email = user_email db.session.commit() except: db.session.rollback() db.session.flush() userId = user.user_id data = User.query.filter_by(user_id=userId).first() result = &#123;'user_id': data.user_id, 'user_name': data.user_name, 'user_password': data.user_password, 'user_nickname': data.user_nickname, 'user_email': data.user_email&#125; return jsonify(data=result)# 查全部@app.route('/user', methods=['GET'])def getUsers(): data = User.query.all() data_all = [] for user in data: data_all.append(&#123;'user_id': user.user_id, 'user_name': user.user_name, 'user_nickname': user.user_nickname, 'user_email': user.user_email&#125;) return jsonify(users=data_all)# 删@app.route('/user/&lt;int:userId&gt;', methods=['DELETE'])def deleteUser(userId): # 删除数据 User.query.filter_by(user_id=userId).delete() db.session.commit() return getUsers()if __name__ == '__main__': app.run(debug=app.config['DEBUG']) SQLAlchemy 几种查询方式总结 使用Flask-RESTful快速创建RESTful API接口先容我把项目做完…待续…….无聊看看文档：flask-restful中文官方文档 使用Flask + PyJWT 实现基于Json Web Token的用户认证授权待更…无聊看看文档：Flask + PyJWT 实现基于Json Web Token的用户认证授权 问题1.主要问题就是flask和mysql的连接问题，出现的最棘手的问题首先是mysqldb是py2的，py3没有，用pymysql代替，在SQLALCHEMY_DATABASE_URI注意修改driver驱动。2.最终修改方案是自己用一个demo建好了数据库和表(记得保存好demo)，demo如下，然后再运行就可以了。 12345678910111213141516from sqlalchemy import create_engine,Table,Column,Integer,String,MetaData,ForeignKeyengine=create_engine("mysql+pymysql://root:a5230411@localhost:3306/test",echo=True)metadata=MetaData(engine)user=Table('user',metadata, Column('id',Integer,primary_key=True), Column('name',String(20)), Column('fullname',String(40)), )address_table = Table('address', metadata, Column('id', Integer, primary_key=True), Column('user_id', None, ForeignKey('user.id')), Column('email', String(128), nullable=False) )metadata.create_all() 3.解决 sqlalchemy 报错:(1193, “Unknown system variable ‘tx_isolation’”): 传送门 参考网址 Flask + PyJWT 实现基于Json Web Token的用户认证授权 使用 Flask 设计 RESTful 的认证 使用Flask-RESTful快速创建RESTful API接口 Flask + flask-jwt 实现基于Json Web Token的用户认证授权 Flask程序目录结构——构建可扩展的Flask应用程序 Python的flask：models.py来创建mysql数据库 python使用sqlalchemy连接mysql数据库 深入浅出Flask(学习教程) 深入浅出理解Python装饰器 flask-restful中文官方文档]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>flask</tag>
        <tag>PyJWT</tag>
        <tag>restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java核心技术]]></title>
    <url>%2F2019%2F08%2F20%2FJava%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF.html</url>
    <content type="text"><![CDATA[第一章Java的11个关键术语 简单性 面向对象 分布式 健壮性 安全性 体系结构中立 可移植性 解释型 高性能 多线程 动态性 Java applet在网页中运行的Java程序称为applet 第二章部分术语 JDK(java development kit):java开发工具包 JRE(Java Runtime Environment):运行java程序用户所使用的软件 SDK(Software Development Kit):软件开发包 安装过程MAC中JAVA环境变量配置以及Intellij IDEA如何配置JDKIDEA的校园邮箱激活方式IntelliJ IDEA 常用快捷键 之 Mac 版Intellij IDEA快捷生成常用代码 琐碎知识点 0x1.0p-3:0x表示16进制，使用p表示指数，所以就是1.0*2的-3次方 三个特殊的浮点数值：正无穷大(Double.POSITIVE_INFINITY)、负无穷大(Double.NEGATIVE_INFINITY)、NaN(Double.NaN) 浮点数值不适用于无法接受舍入误差的计算中，要想完全没有误差，需要使用BigDecimal类 部分特殊字符的转义序列：\b 退格 \t 制表 \n 换行 \r 回车 \“双引号 \反斜杠 强烈建议不要在程序中使用char类型，因为unicode早已经超过了65536个 第三章部分术语 类常量：static final,类常量的定义在main方法的外部 整数被0除将会产生异常，浮点数被0除将会得到无穷大或NaN结果 public static strictfp void main(String[] args)，在该main函数中所有指令都将使用严格的浮点计算 condition ? expression1 : expression2 eg: x&lt;y ? x : y 位运算符：&amp;、|、^、~拓展：奇数个数，两个两个成对最有一个单独，如何找出这个单独的数字是几，复杂度在O(n)以内：用异或的思想即可，全部异或 移位运算符: &lt;&lt;(算数移位)&gt;&gt; &gt;&gt;&gt;(逻辑右移),其中&gt;&gt;&gt;会用0填充高位，移位运算符的右操作数要满足模32的运算(如果左边操作数是long则要满足模64)，1&lt;&lt;35 == 1&lt;&lt;3 == 8 枚举类型：enum Size{SMALL,MEDIUM,LARGE } 字符串 子串: 12String greeting = "Hello";String s = greeting.substring(0,3); 拼接:直接用+连接、如果需要多个字符串放在一起，并且用一个定界符分割，可以采用静态join方法： 12String all = String.join("/","S","M","L","XL")// string: "S/M/L/XL" java中不允许修改字符，但是可以修改字符串变量*字符串比较用equals方法，例如：”Hello”.equals(greeting),”Hello”.equalsIgnoreCase(“hello”)「无视大小写的比较」 java.lang.string部分apiString类常用方法之charAt()、codePointAt()示例offsetByCodePoints()与codePointAt() 注意lastIndexOf(int cp,int fromindex)，是返回从index位置开始找到的第一个符合的字符串的位置 12345678910111213141516public int lastIndexOf(int ch, int fromIndex) &#123; if (ch &lt; Character.MIN_SUPPLEMENTARY_CODE_POINT) &#123; // handle most cases here (ch is a BMP code point or a // negative value (invalid code point)) final char[] value = this.value; int i = Math.min(fromIndex, value.length - 1); for (; i &gt;= 0; i--) &#123; if (value[i] == ch) &#123; return i; &#125; &#125; return -1; &#125; else &#123; return lastIndexOfSupplementary(ch, fromIndex); &#125; &#125; input Scanner在util包中，当使用的类不在java.lang中时，都需要导包 1234567Scanner sc = new Scanner(System.in); String nextLine = sc.nextLine(); System.out.println("please input your name:" + nextLine); int nextInt = sc.nextInt(); System.out.println("please input your age:" + nextInt);String next = sc.next();System.out.println("please input your name:" + next);]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活好难啊]]></title>
    <url>%2F2019%2F08%2F18%2F%E7%94%9F%E6%B4%BB%E5%A5%BD%E9%9A%BE%E5%95%8A.html</url>
    <content type="text"><![CDATA[今天被打击了…卧槽这个大数据怎么这么枯燥…再次怀疑不适合学计算机…把我看睡着了可还行（吐血…算了还是接着干吧）]]></content>
      <categories>
        <category>吐槽</category>
      </categories>
      <tags>
        <tag>负情绪</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kafka]]></title>
    <url>%2F2019%2F08%2F18%2Fkafka.html</url>
    <content type="text"><![CDATA[初识kafkakafka概念Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者在网站中的所有动作流数据,是用于构建实时数据管道和流应用程序。 四个术语 TopicKafka将消息种子(Feed)分门别类，每一类的消息称之为一个主题(Topic)。 Producer发布消息的对象称之为主题生产者(Kafka topic producer)。生产者发布消息时要选定Topic上的分区。 Consumer订阅消息并处理发布的消息的种子的对象称之为主题消费者(consumers)。一般消费者模型可以分为两类：队列和发布-订阅式。队列的处理方式就是一条消息只有一个消费者知道并处理，发布-订阅的处理方式则是消息被所有人都知道，所有人都可以来处理该消息，kafka为这两种模型提供了单一抽象模型：消费者组（cosumer group）。每个消费者都有一个组名，当所有人的组名都不一样的时候，这个时候就是发布-订阅模式，因为消息要按照消费者组为单位发出的，这意味着此时每个消费者都会收到消息并可以进行处理；当所有人的消费者组名字都一样时，意味着只会有一个消费者收到消息并可以进行处理，此时就是队列模式了。 Broker已发布的消息保存在一组服务器中，称之为Kafka集群。集群中的每一个服务器都是一个代理(Broker). 消费者可以订阅一个或多个主题（topic），并从Broker拉数据，从而消费这些已发布的消息。 三个关键能力 发布和订阅消息流，在这方面，它类似于一个消息队列或企业消息系统 以容错的方式存储消息（流) 在消息流发生时处理他们 四个核心API 应用程序使用 Producer API 发布消息到1个或多个topic（主题）。 应用程序使用 Consumer API 来订阅一个或多个topic，并处理产生的消息 应用程序使用 Streams API 充当一个流处理器，从1个或多个topic消费输入流，并生产一个输出流到1个或多个输出topic，有效地将输入流转换到输出流。 Connector API允许构建或运行可重复使用的生产者或消费者，将topic连接到现有的应用程序或数据系统。例如，一个关系数据库的连接器可捕获每一个变化。 kafka安装过程 kafka的安装 1brew install kafka 安装会依赖zookeeper 注意：安装目录：/usr/local/Cellar/kafka/0.10.2.0 安装的配置文件位置/usr/local/etc/kafka/server.properties/usr/local/etc/kafka/zookeeper.properties 启动zookeeper 1zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties &amp; 启动kafka 1kafka-server-start /usr/local/etc/kafka/server.properties &amp; 创建topic让我们使用单个分区和只有一个副本创建一个名为“test”的主题 1kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test 查看创建的topic我们现在可以看到该主题，如果我们运行list topic命令： 1kafka-topics --list --zookeeper localhost:2181 发送消息Kafka提供了一个命令行客户端，它将从文件或标准输入接收输入，并将其作为消息发送到Kafka集群。默认情况下，每行都将作为单独的消息发送。运行生产者，然后在控制台中键入一些消息发送到服务器。 1kafka-console-producer --broker-list localhost:9092 --topic test 消费消息Kafka还有一个命令行消费者，将消息转储到标准输出。 1kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginning TipQ:安装kafka出现错误： 1234kafka: Java 1.8 is required to install this formula.Install AdoptOpenJDK 8 with Homebrew Cask: brew cask install homebrew/cask-versions/adoptopenjdk8Error: An unsatisfied requirement failed this build. A: 1brew cask install homebrew/cask-versions/adoptopenjdk8 bilibili学习kafkahttps://www.bilibili.com/video/av36607048?p=2 zookeeper 默认是前台启动(关闭了控制台停止)，可以在最前面加上 nohup，这样就可以后台启动了。 三个目录 bin目录1cd usr/local/Cellar/kafka/2.2.1/bin * config文件 1/usr/local/etc/kafka/server.properties * 日志 1234############################# Log Basics ############################## A comma separated list of directories under which to store log fileslog.dirs=/usr/local/var/lib/kafka-logs 删除topic1kafka-topics --delete --zookeeper localhost:2181 --topic test]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>kafka</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python实践winrm，实现远程连接调度Windows服务器]]></title>
    <url>%2F2019%2F08%2F17%2Fpython%E5%AE%9E%E8%B7%B5winrm%EF%BC%8C%E5%AE%9E%E7%8E%B0%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E8%B0%83%E5%BA%A6Windows%E6%9C%8D%E5%8A%A1%E5%99%A8.html</url>
    <content type="text"><![CDATA[前言最近有个需求：用自己主机控制多个windows节点，实时获取他们的cpu和运存占用情况，通过查询，决定采用python中的winrm。Tip:winrm服务是windows 一种方便远程管理的服务；开启winrm service,便于在日常工作中，远程管理服务器，或通过脚本，同时管理多台服务器，来提高工作效率。 常规做法配置远程主机,使其支持被远程控制 查看winrm service listener（分为http和https）:1winrm e winrm/config/listener 如果没有返回，则没有开启winrm服务。 开启winrm服务： 1winrm quickconfig 为winrm service 配置auth: 1winrm set winrm/config/service/auth @&#123;Basic="true"&#125; 为winrm service 配置加密方式为允许非加密： 1winrm set winrm/config/service @&#123;AllowUnencrypted="true"&#125; 查看winrm服务的配置： 1winrm get winrm/config 客户端主机 装winrm 1pip install pywinrm 测试 1234import winrmwintest = winrm.Session('http://47.98.149.160:5985/wsman',auth=('Administrator','Jwy12345a'))ret = wintest.run_cmd('ipconfig')print(ret) 遇到的问题及解决措施 在测试环节，导入winrm包后，控制台显示：winrm has no attribute session 解决办法：pip导错了包，应该是pywinrm这个包，将pip原来的包删除，重新导入一遍。 pycharm问题：module ‘pip’ has no attribute ‘main’ 解决办法：pip升级导致无法导包 测试的时候，报出以下错误： 1requests.exceptions.ConnectTimeout: HTTPConnectionPool(host='47.98.149.160', port=5985): Max retries exceeded with url: /wsman (Caused by ConnectTimeoutError(&lt;urllib3.connection.HTTPConnection object at 0x104921650&gt;, 'Connection to 47.98.149.160 timed out. (connect timeout=30)')) 解决办法：由于云服务器有公网ip地址，所以本机可以ping通服务器，但是由于本机不存在公网地址，是局域网地址，所以服务器不能ping通主机，导致二者不能正常通信，只能换一种方法，也就是在云服务器端运行程序，程序提供了当前cpu运行情况和运存情况，本机可以随时访问并得到信息。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485import timeimport psutil # cd C:\Python36-32\Scripts pip install psutil# 获取本机磁盘使用率和剩余空间G信息import pymysqlconn = pymysql.connect(user="root", passwd="No.93329332", host="134.175.5.88", port=3306, db="node_status")cur = conn.cursor()flag = 0while(True): # 循环磁盘分区 content = "" for disk in psutil.disk_partitions(): # 读写方式 光盘 or 有效磁盘类型 if 'cdrom' in disk.opts or disk.fstype == '': continue disk_name_arr = disk.device.split(':') disk_name = disk_name_arr[0] disk_info = psutil.disk_usage(disk.device) # 磁盘剩余空间，单位G free_disk_size = disk_info.free // 1024 // 1024 // 1024 # 当前磁盘使用率和剩余空间G信息 if (disk_name == 'C'): disk_c_name = disk_name disk_c_info = disk_info free_c_disk_size = free_disk_size info = "%s盘使用率：%s%%， 剩余空间：%iG" % (disk_c_name, str(disk_c_info.percent), free_c_disk_size) # print(info) # print(disk_name) if (disk_name == 'C'): # 拼接多个磁盘的信息 content = content + info print(content) # return content # cpu信息 cpu_percent = psutil.cpu_percent(interval=1) cpu_info = "CPU使用率：%i%%" % cpu_percent print(cpu_info) # return cpu_info # 内存信息 virtual_memory = psutil.virtual_memory() used_memory = virtual_memory.used / 1024 / 1024 / 1024 free_memory = virtual_memory.free / 1024 / 1024 / 1024 memory_percent = virtual_memory.percent memory_info = "内存使用：%0.2fG，使用率%0.1f%%，剩余内存：%0.2fG" % (used_memory, memory_percent, free_memory) print(memory_info) # return memory_info now = time.asctime() if(flag == 0): sql = "INSERT INTO status(ip, \ disk_percent, disk_freesize, CPU_percent, memory_used,memory_free,memory_percent,mytime) \ VALUES ('%s', '%s', '%s', '%s', '%s','%s','%s','%s')" % \ ('106.13.70.159', str(disk_c_info.percent) + "%", str(free_c_disk_size) + "G", str(cpu_percent) + "%",str(used_memory)[:3] + "G",str(free_memory)[:3] + "G",str(memory_percent) + "%",now) flag = 1 else: used_memory_float = str(used_memory)[:3] + 'G' free_memory_folat = str(free_memory)[:3] + 'G' disk_c_info_percent_str = str(disk_c_info.percent) + '%' free_c_disk_size_str = str(free_c_disk_size) + 'G' cpu_percent_str = str(cpu_percent) + '%' memory_percent_str = str(memory_percent) + '%' sql = "update status set disk_percent = '%s', disk_freesize = '%s', \ CPU_percent = '%s', memory_used = '%s' , memory_free = '%s' ,\ memory_percent = '%s' , mytime = '%s' where ip = '106.13.70.159'" % \ (disk_c_info_percent_str,free_c_disk_size_str,cpu_percent_str,used_memory_float,free_memory_folat,memory_percent_str,now) flag = 2 try: # 执行sql语句 cur.execute(sql) # 执行sql语句 conn.commit() if(flag==1): print("insert ok") else: print("update ok") except Exception as e: # 发生错误时回滚 conn.rollback() print("failed") print(e) time.sleep(60)# 关闭数据库连接conn.close() sql中update也可以 1sql = "update table set ss = '%s'where id = '1'"% disk]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>winrm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Hexo的NexT主题---从入门到入土]]></title>
    <url>%2F2019%2F08%2F15%2F%E5%9F%BA%E4%BA%8EHexo%E7%9A%84NexT%E4%B8%BB%E9%A2%98-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E5%9C%9F.html</url>
    <content type="text"><![CDATA[前言本篇文章主要是针对nexT主题的优化说明，使用hexo其他主题的童靴请绕道~~整理一下大概优化：1.标题部分优化，颜色样式；2.设置博客文章连接为year/month/day/title.html格式3.Menu增加关于、标签、分类、互动、搜索菜单4.禁用关于、标签、分类菜单评论功能5.添加RSS6.设置背景图片7.Canvas_nest动态背景8.图片快速加载设置9.微信支付宝打赏功能10.点击出现桃心效果11.主页文章添加阴影效果12.设置代码高亮13.顶栏背景色14.底栏背景色15.修改文章内链接文本样式16.修改文章底部标签样式17.在文章末尾添加“文章结束”标记18.设置头像19.网站底部加上访问量20.网站底部字数统计21.网站底部添加网站运行时间22.网站底部添加动态桃心23.底部隐藏由Hexo强力驱动、主题–NexT.Mist24.设置网站的图标Favicon25.实现文章文字统计功能和阅读时长26.加来必力云跟帖功能27.去掉底部重复字数统计28.修改字体大小29.侧边栏社交小图标设置30.添加侧栏推荐阅读31.修改侧边栏背景图片32.添加侧边栏音乐33.修改侧边栏文字颜色34.在文章底部增加版权信息35.Hexo博客添加站内搜索36.修改选中字符的颜色37.添加aplay音乐播放38.添加博客左下角门神(看门🐶)39.增加了3D库three_waves，默认关闭40.增加了canvas页面丝带(话说这玩意真的很吃cpu，一开我的mac就铁板烧了)41.增加了首页pace加载进度42.增加图片懒加载lazyload43.增加了fancybox44.增加了fastclick解决延迟问题45.增加了gulp压缩网页css js样式46.截断首页文章内容47.代码复制功能 hexo目录结构主目录结构 _config.yml全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。 package.jsonhexo框架的参数和所依赖插件。 scaffoldsscaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。 source这个目录很重要，新建的文章都是在保存在这个目录下的._posts，需要新建的博文都放在_posts目录下。_posts目录下是一个个 markdown 文件。你应该可以看到一个 hello-world.md 的文件，文章就在这个文件中编辑。_posts 目录下的md文件，会被编译成html文件，放到 public （此文件现在应该没有，因为你还没有编译过）文件夹下。里面还有一个重要文件夹：images，是用来存放博文的图片的，这里建议使用七牛云图床来存储图片，因为可以更快的加载图片。同时强烈建议大家用一款hexo—client来进行可视化博客的书写，一站式服务，支持七牛云图床，接好传送门：hexoclient。 themes网站主题目录，我用的就是nexT主题。 node_moduleshexo依赖的组件都在其中。 主题目录结构12345678910111213141516171819202122232425262728293031323334353637├── .github #git信息├── languages #多语言| ├── default.yml #默认语言| └── zh-Hans.yml #简体中文| └── zh-tw.yml #繁体中文├── layout #布局，根目录下的*.ejs文件是对主页，分页，存档等的控制| ├── _custom #可以自己修改的模板，覆盖原有模板| | ├── _header.swig #头部样式| | ├── _sidebar.swig #侧边栏样式| ├── _macro #可以自己修改的模板，覆盖原有模板| | ├── post.swig #文章模板| | ├── reward.swig #打赏模板| | ├── sidebar.swig #侧边栏模板| ├── _partial #局部的布局| | ├── head #头部模板| | ├── search #搜索模板| | ├── share #分享模板| ├── _script #局部的布局| ├── _third-party #第三方模板| ├── _layout.swig #主页面模板| ├── index.swig #主页面模板| ├── page #页面模板| └── tag.swig #tag模板├── scripts #script源码| ├── tags #tags的script源码| ├── marge.js #页面模板├── source #源码| ├── css #css源码| | ├── _common #*.styl基础css| | ├── _custom #*.styl局部css| | └── _mixins #mixins的css| ├── fonts #字体| ├── images #图片| ├── uploads #添加的文件| └── js #javascript源代码├── _config.yml #主题配置文件└── README.md #用GitHub的都知道 高度定制优化篇标题部分优化，颜色样式首先你要确定你是主题中的哪个scheme：Muse、Mist、Pisces、Gemini，我的是Mist,所以我就去themes/nexT/source/css/_schemes/Mist/_header.styl下，添加以下代码：12345//可以加图片，也可以自己调色彩.header &#123; //background: url('/images/headbg.jpg') repeat !important; background: rgba(#EBF2EA,1) none repeat scroll !important; &#125; 设置背景图片默认禁用，可以在themes/nexT/source/css/_custom/custon.styl文件中启用12345678//设置背景图片body &#123; background:url(http://pw5u1sbg2.bkt.clouddn.com/145676.jpg); background-repeat: repeat; background-attachment:fixed; background-position:50% 50%; background-size:cover;&#125; Canvas_nest动态背景背景的几何线条是采用的nest效果, 一个基于html5 canvas绘制的网页背景效果, 非常赞！来自github的开源项目canvas-nest 特性 不依赖任何框架或者内库，比如不依赖jQuery，使用原生的javascript 非常小，只有1.66kb，如果开启gzip，可以更小 非常容易实现，配置简单，即使你不是web开发者，也能简单搞定说明 color：线条颜色，默认： ‘0,0,0’ ；三个数字分别为(R,G,B)，这里推荐一个颜色采集器：ColorSlurp，在AppStore中就可以搜到 opacity：线条透明度（0~1），默认: 0.5 count：线条的总数量， 默认：150 zIndex：背景的z-index属性，css属性用于控制所在层的位置，默认：-1不足内存占用过高做法直接找到主题配置文件，将canvas改为true即可。RSS在你的hexo站点目录下：1$ npm install hexo-generator-feed --save 打开站点目录下的_config.yml:12345678# feed# Dependencies: https://github.com/hexojs/hexo-generator-feedfeed: type: atom path: atom.xml limit: 20 hub: content: 来必力评论系统等第三方插件登录 来必力 ，获取LiveRe UID，编辑主题配置文件，编辑livere_uid字段，将id填入即可，更多第三方集成插件可见：nexT官网，包括评论系统、数据统计与分析、内容分享服务、搜索服务等等。 打赏功能nexT集成了支付宝微信打赏功能，直接在主题配置文件搜索wechat或者alipay即可,然后跟上自己的微信和支付宝的收钱码图片地址即可。 点击出现桃心效果1!function(e,t,a)&#123;function n()&#123;c(".heart&#123;width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);&#125;.heart:after,.heart:before&#123;content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;&#125;.heart:after&#123;top: -5px;&#125;.heart:before&#123;left: -5px;&#125;"),o(),r()&#125;function r()&#123;for(var e=0;e&lt;d.length;e++)d[e].alpha&lt;=0?(t.body.removeChild(d[e].el),d.splice(e,1)):(d[e].y--,d[e].scale+=.004,d[e].alpha-=.013,d[e].el.style.cssText="left:"+d[e].x+"px;top:"+d[e].y+"px;opacity:"+d[e].alpha+";transform:scale("+d[e].scale+","+d[e].scale+") rotate(45deg);background:"+d[e].color+";z-index:99999");requestAnimationFrame(r)&#125;function o()&#123;var t="function"==typeof e.onclick&amp;&amp;e.onclick;e.onclick=function(e)&#123;t&amp;&amp;t(),i(e)&#125;&#125;function i(e)&#123;var a=t.createElement("div");a.className="heart",d.push(&#123;el:a,x:e.clientX-5,y:e.clientY-5,scale:1,alpha:1,color:s()&#125;),t.body.appendChild(a)&#125;function c(e)&#123;var a=t.createElement("style");a.type="text/css";try&#123;a.appendChild(t.createTextNode(e))&#125;catch(t)&#123;a.styleSheet.cssText=e&#125;t.getElementsByTagName("head")[0].appendChild(a)&#125;function s()&#123;return"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"&#125;var d=[];e.requestAnimationFrame=function()&#123;return e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e)&#123;setTimeout(e,1e3/60)&#125;&#125;(),n()&#125;(window,document); 新建 clicklove.js 文件并且将以上代码复制进去，然后保存。 将 clicklove.js文件放到路径 /themes/next/source/js/src 里面 然后打开 \themes\next\layout\_layout.swig 文件,在末尾（在前面引用会出现找不到的bug）添加以下代码：12&lt;!-- 页面点击小红心 --&gt;&lt;script type="text/javascript" src="/js/src/clicklove.js"&gt;&lt;/script&gt; 主页文章添加阴影效果打开 themes/next/source/css/_custom/custom.styl，向里面加代码:12345678// 主页文章添加阴影效果.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 代码高亮直接在主题配置文件搜索 highlight_theme：1234# Code Highlight theme# Available values: normal | night | night eighties | night blue | night bright# https://github.com/chriskempson/tomorrow-themehighlight_theme: night bright 顶部底部背景色改变首先你要确定你是主题中的哪个scheme：Muse、Mist、Pisces、Gemini，我的是Mist,所以我就themes/nexT/source/css/_schemes/Mist/_header.styl下，将颜色进行修改即可。底部颜色则在themes/nexT/source/css/_schemes/Mist/index.styl中进行修改：123456789101112131415161718// Footer// --------------------------------------------------.footer &#123; margin-top: 80px; padding: 10px 0; //background: url('/images/headbg.jpg') repeat !important; background: rgba(#EBF2EA,1) none repeat scroll !important; color: $grey-dim;&#125;.footer-inner &#123; margin: 0 auto; text-align: left; +mobile() &#123; width: auto; text-align: center; &#125;&#125; 修改文章内文本连接样式打开 themes/next/source/css/_custom/custom.styl,添加代码：1234567891011// 文章内链接文本样式.post-body p a&#123; color: #0593d3; border-bottom: none; border-bottom: 1px solid #0593d3; &amp;:hover &#123; color: #fc6423; border-bottom: none; border-bottom: 1px solid #fc6423; &#125;&#125; 修改网页底部 在图标库中找到你自己喜欢的图标, 修改桃心,打开 themes/next_config.yml ,搜索关键字 authoricon,替换图标名： 12# icon between year and author @Footerauthoricon: id-card 隐藏网页底部 Hexo 强力驱动 打开主题配置文件,搜索关键字 copyright ，如下: 12# Footer `powered-by` and `theme-info` copyrightcopyright: false 添加文章结束标记在themes/next/layout/_macro/post.swig中, 在wechat-subscriber.swig之前添加如下代码:123&lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;---------------- The End ----------------&lt;/div&gt; 统计功能，统计功能,显示文章字数统计,阅读时长,总字数在站点的根目录下：1$ npm i --save hexo-wordcount 打开 themes/next/_config.yml ，搜索关键字 post_wordcount：1234567891011# Post wordcount display settings# Dependencies: https://github.com/willin/hexo-wordcountpost_wordcount: item_text: true #字数统计 wordcount: true #预览时间 min2read: true #总字数,显示在页面底部 totalcount: true separated_meta: true 设置头像打开 themes/next/_config.yml ，搜索关键字 avatar：123456789101112# Sidebar Avataravatar: # In theme directory (source/images): /images/avatar.gif # In site directory (source/uploads): /uploads/avatar.gif # You can also use other linking images. url: http://pw5u1sbg2.bkt.clouddn.com/avatar.png #/images/avatar.png # If true, the avatar would be dispalyed in circle. rounded: true # The value of opacity should be choose from 0 to 1 to set the opacity of the avatar. opacity: 1 # If true, the avatar would be rotated with the cursor. rotated: false 底部添加访问量和字数统计运用第三方插件，见nexT官网，推荐百度统计和不蒜子统计。 底部添加运行时间找到\themes\next\layout\_partials\下面的footer.swig文件，在末尾添加所示代码：12345678910111213141516171819&lt;div class="run_time" style=" text-align:center;"&gt; &lt;span id="timeDate"&gt;载入天数...&lt;/span&gt;&lt;span id="times"&gt;载入时分秒...&lt;/span&gt; &lt;script&gt; var now = new Date(); function createtime() &#123; var grt= new Date("08/06/2019 19:00:00");//此处修改你的建站时间或者网站上线时间 now.setTime(now.getTime()+250); days = (now - grt ) / 1000 / 60 / 60 / 24; dnum = Math.floor(days); hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours); if(String(hnum).length ==1 )&#123;hnum = "0" + hnum;&#125; minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum); mnum = Math.floor(minutes); if(String(mnum).length ==1 )&#123;mnum = "0" + mnum;&#125; seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum); snum = Math.round(seconds); if(String(snum).length ==1 )&#123;snum = "0" + snum;&#125; document.getElementById("timeDate").innerHTML = "本站已安全运行 "+dnum+" 天 "; document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒"; &#125; setInterval("createtime()",250); &lt;/script&gt;&lt;/div&gt; 底部添加红心打开 themes/next/_config.yml ，搜索关键字 footer：123456789101112131415footer: # Specify the date when the site was setup. If not defined, current year will be used. since: 2019 # visitors count counter: true # Icon between year and copyright info. icon: # Icon name in fontawesome, see: https://fontawesome.com/v4.7.0/icons/ # `heart` is recommended with animation in red (#ff0000). name: heart # If you want to animate the icon, set it to true. animated: true # Change the color of icon, using Hex Code. color: "#ff0000" 添加侧边栏音乐框去往网易云音乐搜索喜欢的音乐，点击生成外链播放器， 复制代码直接放到博文末尾即可，height设为0可隐藏播放器，但仍然可以播放音乐，auto设成0可手动播放，默认是1自动播放，可把代码放到themes/next/layout/_custom/sidebar.swig文件里，播放器会显示在站点预览中,示例代码如下：12&lt;iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=110 src="//music.163.com/outchain/player?type=0&amp;id=2588481240&amp;auto=1&amp;height=90"&gt;&lt;/iframe&gt; 添加aplayer音乐播放由于我想在单独的页面加入歌单，所以额外创了个页面，也可以直接在文章中插入，原理都是一样的。 新建页面，命名为guestbook： 1hexo new page guestbook 这时候在 /Hexo/source 文件夹下会生成一个guestbook文件夹，打开里面的index.md，示例如下： 123456789101112---title: 留言互动date: 2019-08-15 12:18:09type: "guestbook"---&lt;div align="center"&gt; &lt;img src="https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1558956326532&amp;di=82cc9907fc903cfb978a35206986d3f6&amp;imgtype=0&amp;src=http%3A%2F%2Fimg.mp.itc.cn%2Fupload%2F20160809%2F31283a3e2d7f411492d3fb27297180ec_th.jpg" /&gt;&lt;/div&gt;[//]: #(aplay音频播放https://github.com/MoePlayer/hexo-tag-aplayer)&#123;% meting "2331951308" "netease" "playlist" "autoplay" "mutex:false" "order:random" "listmaxheight:250px" "preload:none" "theme:#f7f7f7"%&#125; meting中配置参数含义如下： 选项 默认值 描述 id 必须值 歌曲 id / 播放列表 id / 相册 id / 搜索关键字 server 必须值 音乐平台: netease, tencent, kugou, xiami, baidu type 必须值 song, playlist, album, search, artist fixed false 开启固定模式 mini false 开启固定模式 loop all 列表循环模式：all, one,none order list 列表播放模式： list, random volume 0.7 播放器音量 lrctype 0 歌词格式类型 listfolded false 指定音乐播放列表是否折叠 storagename metingjs LocalStorage 中存储播放器设定的键名 autoplay true 自动播放，移动端浏览器暂时不支持此功能 mutex true 该选项开启时，如果同页面有其他 aplayer 播放，该播放器会暂停 theme #ad7a86 播放器风格色彩设置 listmaxheight 340px 播放列表的最大长度 preload auto 音乐文件预载入模式，可选项： none, metadata, auto 打开主题_config.yml文件，在menu下新建一个名为guestbook的类，完成后如下所示： 1234567menu: home: / || home tags: /tags/ || tags categories: /categories/ || bookmark archives: /archives/ || archive about: /about/ || user 互动: /guestbook/ || comments 打开/Hexo/themes/hexo-theme-next/languages/zh-Hans.yml，添加对应的中文翻译： 12menu: guestbook: 互动 至此，歌单页面创建完成，现在只需要在站点配置文件中开启meting模式，在_config.yml中搜索meting： 12aplayer: meting: true Tip同一个歌单不能做到实时刷新，需要24小时后aplayer才会自动更新缓存 添加博客左下角门神安装依赖:12npm install --save hexo-helper-live2dnpm install --save live2d-widget-model-wanko 站点配置添加:12345678910111213141516171819202122# hexo-helper-live2d配置, 参考https://github.com/EYHN/hexo-helper-live2d/blob/master/README.zh-CN.mdlive2d: enable: true scriptFrom: local pluginRootPath: live2dw/ pluginJsPath: lib/ pluginModelPath: assets/ tagMode: false debug: false model: scale: 1 use: live2d-widget-model-wanko display: superSample: 2 # 超采样等级 width: 100 height: 100 position: left # 位置 mobile: show: false react: opacityDefault: 0.9 # 默认透明度 opacityOnHover: 0.5 # 鼠标移上透明度 增加首页pace加载进度打开主题配置文件：12345678# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true# Themes list:# pace-theme-big-counter | pace-theme-bounce | pace-theme-barber-shop | pace-theme-center-atom# pace-theme-center-circle | pace-theme-center-radar | pace-theme-center-simple | pace-theme-corner-indicator# pace-theme-fill-left | pace-theme-flash | pace-theme-loading-bar | pace-theme-mac-osx | pace-theme-minimalpace_theme: pace-theme-bounce 增加图片懒加载lazyload打开主题配置文件：123# Vanilla JavaScript plugin for lazyloading images.# Dependencies: https://github.com/theme-next/theme-next-jquery-lazyloadlazyload: true 增加fancybox和fastclick解决延迟问题打开主题配置文件：123456789# Fancybox. There is support for old version 2 and new version 3.# Choose only one variant, do not need to install both.# To install 2.x: https://github.com/theme-next/theme-next-fancybox# To install 3.x: https://github.com/theme-next/theme-next-fancybox3fancybox: true# Polyfill to remove click delays on browsers with touch UIs.# Dependencies: https://github.com/theme-next/theme-next-fastclickfastclick: true 截断首页文章内容打开主题配置文件，搜索auto_excerpt：12345# Automatically Excerpt (Not recommend).# Use &lt;!-- more --&gt; in the post to control excerpt accurately.auto_excerpt: enable: true length: 150 代码复制功能 复制该网页的代码，传送门：clipboard.min.js，然后在themes\next\source\js\src下新建clipboard.min.js文件，将以上内容复制进去即可； 在themes\next\source\js\src目录下，创建clipboard-use.js，文件内容如下： 123456789101112131415161718 /*页面载入完成后，创建复制按钮*/ !function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = ''; copyHtml += '&lt;button class="btn-copy" data-clipboard-snippet=""&gt;'; //fa fa-globe可以去字体库替换自己想要的图标copyHtml += ' &lt;i class="fa fa-clipboard"&gt;&lt;/i&gt;&lt;span&gt;copy&lt;/span&gt;'; copyHtml += '&lt;/button&gt;'; $(".highlight .code pre").before(copyHtml); new ClipboardJS('.btn-copy', &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode(); &#125;(window, document); 在themes\next\source\css\_custom\custom.styl样式文件中添加下面代码： 123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 在themes\next\layout\_layout.swig文件中，添加引用（注：在 swig 末尾或 body 结束标签（L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"superSample":1,"width":250,"height":300,"position":"left"},"mobile":{"show":false},"react":{"opacityDefault":0.9,"opacityOnHover":0.5},"log":false});）之前添加）： 123&lt;!-- 代码块复制功能 --&gt;&lt;script type="text/javascript" src="/js/src/clipboard.min.js"&gt;&lt;/script&gt; &lt;script type="text/javascript" src="/js/src/clipboard-use.js"&gt;&lt;/script&gt; 尝试了但未实现的功能1.用mob_share的app_key未能实现share的功能，经过其官方人员电话沟通，已经不再支持pc端博客服务2.aplay音乐播放歌单，不能做到实时更新歌单，究其原因是其api设置了24小时缓存，同一个歌单24小时内不会发生改变 非常有益的网址 NexT主题进阶 基于Hexo的个人博客搭建(进阶版) Hexo+Next主题优化]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>NexT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法题]]></title>
    <url>%2F2019%2F08%2F12%2F%E7%AE%97%E6%B3%95%E9%A2%98.html</url>
    <content type="text"><![CDATA[二维数组中的查找题目描述在一个二维数组中（每个一维数组的长度相同），每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 解题思路要求时间复杂度 O(M + N)，空间复杂度 O(1)。其中 M 为行数，N 为列数。该二维数组中的一个数，小于它的数一定在其左边，大于它的数一定在其下边。因此，从右上角开始查找，就可以根据 target 和当前元素的大小关系来缩小查找区间，当前元素的查找区间为左下角的所有元素。 My code1234567891011121314151617# -*- coding:utf-8 -*-class Solution: # array 二维列表 def Find(self, target, array): # write code here row = len(array) col = len(array[0]) c = col - 1 r = 0 while(r &lt;= row-1 and c &gt;=0): if(target == array[r][c]): return True elif(target &gt; array[r][c]): r+=1 else: c-=1 return False 替换空格题目描述请实现一个函数，将一个字符串中的每个空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 解题思路将字符串复制给一个新的列表，碰到空格则替换，没有则copy原字符串，最后对列表进行join，返回字符串。 易错点 My code12345678910111213141516171819202122# -*- coding:utf-8 -*-class Solution: # s 源字符串 def replaceSpace(self, s): # write code here t = len(s) j = 0 m = list(s) for i in range(0,t): if(s[i] == ' '): m[j] = '%20' j+=1 else: m[j] = s[i] j+=1 pass return ''.join(m)# s = 'I want to sleep'# solution = Solution()# ss = solution.replaceSpace(s)# print(ss) 从尾到头打印链表题目描述输入一个链表，按链表值从尾到头的顺序返回一个ArrayList。 解题思路知识点补充python中链表的操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768class Node(): '创建节点' def __init__(self,data): self.data = data self.next = None class LinkList(): '创建列表' def __init__(self, node): '初始化列表' self.head = node self.head.next = None self.tail = self.head def add_node(self, node): '添加节点' self.tail.next = node self.tail = self.tail.next def view(self): '查看列表' node = self.head link_str = '' while node is not None: if node.next is not None: link_str += str(node.data) + '--&gt;' else: link_str += str(node.data) node = node.next print ('The Linklist is:' + link_str) def length(self): '列表长度' node = self.head count = 1 while node.next is not None: count += 1 node = node.next print ('The length of linklist are %d' % count) return count def delete_node(self, index): '删除节点' if index+1 &gt; self.length(): raise IndexError('index out of bounds') num = 0 node = self.head while True: if num == index-1: break node = node.next num += 1 tmp_node = node.next node.next = node.next.next return tmp_node.data def find_node(self, index): '查看具体节点' if index+1 &gt; self.length(): raise IndexError('index out of bounds') num = 0 node = self.head while True: if num == index: break node = node.next num += 1 return node.data My code123456789101112131415# -*- coding:utf-8 -*-# class ListNode:# def __init__(self, x):# self.val = x# self.next = Noneclass Solution: # 返回从尾部到头部的列表值序列，例如[1,2,3] def printListFromTailToHead(self, listNode): # write code here res=[] while listNode: res.append(listNode.val) listNode=listNode.next return res[::-1] #逆序打印]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>剑指</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在macOS上使用GitHub Pages+Hexo搭建个人博客]]></title>
    <url>%2F2019%2F08%2F08%2F%E5%9C%A8macOS%E4%B8%8A%E4%BD%BF%E7%94%A8GitHub-Pages-Hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[搭建环境操作系统：macos 10.14.5工具：github Desktop, Node.js, Git框架：Hexo, Github Pages 具体步骤安装git直接在终端输入git --version判断自己系统是否已有git，如果没有，点击该链接git下载，安装完后进入终端输入git --version检查是否安装成功。 安装node.js话不多说，上链接：node.js下载，然后傻瓜式安装就行。安装完之后请记得去控制台看看是否安装成功node --version,然后更新一下npm,输入:npm install -g npm 注册账号并创建博客仓库a.首先进入github官网：github,进行相应的注册登录，然后创建仓库，就在左上角那个猫猫旁边。b.戳进去之后,Respository name必须是:您的github账户名.github.io,然后勾选下面的创建readme，创建完成。c.进入仓库，点击Setting，启用GitHub Pages,此时你输入您的github账户名.github.io,就能看到不是404了，说明此时博客已经建立了，接下来就是利用Hexo框架让你的博客美起来啦！！！！ 安装配置Hexoa.首先建立一个文件夹(随便你建在哪)b.在该文件夹内打开终端，输入：1$ npm install hexo-cli -g 接下来你就能看到文件夹内的东西多了起来哈哈哈，如下图所示的文件结构：c.Hexo已经有了，github pages也有了，现在就剩把他们联系起来了，所以这步就是关键咯，打开上图第一个文件：_config.yml,然后在文本的结尾加上下面的一段代码：1234deploy: type: git repository: https://github.com/jeromememory/jeromememory.github.io.git branch: master 其中repository就是你最开始设置的仓库哟，记得替换自己的github用户名。 检测是否部署成功首先如果你想在本地预览你的博客，只需要打开终端,首先进入Hexo文件夹内，然后进行 hexo s即可：12$ cd /Users/jerome/Hexo $ hexo s 然后你就会看到在终端提示你在localhost:4000预览你的博客啦！！如果你想在网页上看到你的博客，只需要在终端输入：12$ hexo g$ hexo d 稍等一小会(github pages需要一小段时间才会更新)，你就能在你仓库对应的那个网址(您的github用户名.io.git)看到您的博客了，至此，您的博客应该就已经搭建完成了，当然您肯定会说这也太丑了吧，对，我也觉得，所以接下来请继续看下面的操作吧！！！ Hexo主题配置默认的主题很丑，所以这个时候我们就可以去github这个最大的开源网站找了，我推荐Hexo的next主题，我自己用的就是这个，极简至极，找到别人的主题之后，把他的代码clone下来，放到/Hexo/themes这个文件夹下：然后去开始的_config.yml中定位到theme，将后面的值改为你的主题名，别忘了，改完这些后，打开终端，输入：12$ hexo g$ hexo d 过一小会你就能看到自己的主题发生变化啦！剩下的具体配置，我就偷偷懒放个链接：NexT主题，其他主题的同学，你们也可以自己查一下对应的官网哟，都写的贼详细，好用！ 总结至此，个人博客就应该搭建好了，希望对大家有所收获！!(话说第一篇博客果然是狗屁不通啊大家凑合看吧)]]></content>
      <categories>
        <category>程序猿</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>GitHub Pages</tag>
      </tags>
  </entry>
</search>
